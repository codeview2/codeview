####$$$$ dlm/DESCRIPTION
Package: dlm
Title: Bayesian and Likelihood Analysis of Dynamic Linear Models
Version: 1.1-4
Date: 2014-09-16
Suggests: MASS
Author: Giovanni Petris <GPetris@uark.edu>.
  Original C code for ARMS by Wally Gilks.
Description: Maximum likelihood, Kalman filtering and smoothing, and Bayesian
  analysis of Normal linear State Space models, also known as 
  Dynamic Linear Models 
Maintainer: Giovanni Petris <GPetris@uark.edu>
License: GPL (>= 2)
Packaged: 2014-09-16 17:17:15 UTC; gpetris
NeedsCompilation: yes
Repository: CRAN
Date/Publication: 2014-09-16 23:53:05
####$$$$ dlm/MD5
51db4439052d10d2f986f5a76edcb51d *DESCRIPTION
9f8cceb9f83449d33064778d0a0d36fb *NAMESPACE
90dc116a08063be30d387b6b71fdc0bf *NEWS
4594fa0053099904beacb4916b8620c3 *R/DLM.R
312d1ccc2effcb9802392cc41cd01f54 *R/arms.R
bdf8a917d3b9cf3779eaac5ec96cc05b *R/zzz.R
e7ee8f67aac4f997bd3e7904971511d9 *README
f8db75bb0d6972e42c1dfa4019005822 *build/vignette.rds
c54b0d175bc358e96f1ff67709eb559e *data/NelPlo.rda
0e5e467ab7aef1f3b982e32918bdf14f *data/USecon.rda
bc2e63a74f02804a213e3b4cfad3df38 *inst/CITATION
19e6d78b914bb4279daf6575e47d12ba *inst/doc/dlm.R
860f74f3cb8acf9c54f974a1a5e2b7c7 *inst/doc/dlm.Rnw
6f34607f67c2f3040308dec313f2754e *inst/doc/dlm.pdf
7f6857db40ee5f3ee044decd88eb5160 *man/ARtransPars.Rd
8cf55f2456a9a5ad15f061b292dd54c7 *man/FF.Rd
654de1a3180e8f3b89e038c0f1be4b99 *man/NelPlo.Rd
0050e57276310804d78b6f20f8ae8449 *man/USecon.Rd
d1d7c84ff4e48998dcdab089118a3bc0 *man/arms.Rd
19fe67fb1e294b921ce6b7d98e771b54 *man/bdiag.Rd
333ff64a466a1f2d982f6f949b28a73e *man/convex.bounds.Rd
b3611501a5d436d27524ea44bf0ddb9d *man/dlm.Rd
0512692b02e9464b68281d4c6b56b84f *man/dlmBSample.Rd
d2c51ccb5a21a1c33965c4df566ef377 *man/dlmFilter.Rd
381305871802cf9a84df16040fdb7371 *man/dlmForecast.Rd
d74a21853754fec965a155f651947105 *man/dlmGibbsDIG.Rd
506e8fa7d48447c7d4f642a1ee86308d *man/dlmLL.Rd
dc0fd53dc0a09d17d6ac5ae3f76f1eb5 *man/dlmMLE.Rd
204157829c612103a7cd4015d74e4f9a *man/dlmModARMA.Rd
52d9235a4eccbeec6c2237d163134b9b *man/dlmModPoly.Rd
24eb07ebc1faa4e6bb9982e60094327a *man/dlmModReg.Rd
57625872e215c3b57ec9d5e32a49beb8 *man/dlmModSeas.Rd
f20b3ba8dadbd5f1cb58119c22045cf9 *man/dlmModTrig.Rd
e4506e789d790dc962ea3f8939c2dc6e *man/dlmRandom.Rd
7d060d893a06cf63386f6b0b76705231 *man/dlmSmooth.Rd
06268788cacbb8971529a89cd4bae8fc *man/dlmSum.Rd
cd449a98ba8d57d878122b6c0a0e05aa *man/dlmSvd2var.Rd
7bd7da6b91291fac440c6d9c505a7b9c *man/dropFirst.Rd
09dfcf940727d50a3a60b3bbe158f0ad *man/mcmc.Rd
436875910abe524f75bcb9588a1e3417 *man/residuals.dlmFiltered.Rd
a4e697177302079349af13818b10da20 *man/rwishart.Rd
2a6f9e9e044a78154d3cfda5936d6f48 *src/Makevars
a255d69e222cf5acc26565c68935aae0 *src/arms-R.c
087683aa1d097602149318fc773fdb9f *src/dlm.c
860f74f3cb8acf9c54f974a1a5e2b7c7 *vignettes/dlm.Rnw
####$$$$ dlm/NAMESPACE
useDynLib(dlm)
exportPattern("^dlm")
export(arms, ARtransPars, as.dlm, bdiag, convex.bounds, is.dlm,
       rwishart, mcmcMean, mcmcMeans, mcmcSD, ergMean, "%+%", dropFirst,
       FF, "FF<-", V, "V<-", GG, "GG<-", W, "W<-", C0, "C0<-", m0, "m0<-",
       JFF, "JFF<-", JV, "JV<-", JGG, "JGG<-", JW, "JW<-", X, "X<-")
importFrom(stats, tsdiag)
S3method(print, dlm)
S3method(FF, dlm)
S3method("FF<-", dlm)
S3method(GG, dlm)
S3method("GG<-", dlm)
S3method(V, dlm)
S3method("V<-", dlm)
S3method(W, dlm)
S3method("W<-", dlm)
S3method(C0, dlm)
S3method("C0<-", dlm)
S3method(m0, dlm)
S3method("m0<-", dlm)
S3method(JFF, dlm)
S3method("JFF<-", dlm)
S3method(JGG, dlm)
S3method("JGG<-", dlm)
S3method(JV, dlm)
S3method("JV<-", dlm)
S3method(JW, dlm)
S3method("JW<-", dlm)
S3method(X, dlm)
S3method("X<-", dlm)
S3method(print, mcmcMean)
S3method("+", dlm)
S3method(dlmSmooth, dlmFiltered)
S3method(residuals, dlmFiltered)
S3method(tsdiag, dlmFiltered)
####$$$$ dlm/NEWS
Changes to package dlm

Version 1.1-0, 2010-02-15
  - In functions dlmLL and dlmFilter, whenever the observation
    variance V is found to be numerically singular, an 'epsilon' 
    is added to it (with a warning) in order to make the SVD-based 
    algorithms work. 

####$$$$ dlm/README
1. Put any C/C++/Fortran code in 'src'
2. If you have compiled code, add a .First.lib() function in 'R'
   to load the shared library
3. Edit the help file skeletons in 'man'
4. Run R CMD build to create the index files
5. Run R CMD check to check the package
6. Run R CMD build to make the package file


Read "Writing R Extensions" for more information.
####$$$$ dlm\inst/CITATION
citHeader("To cite dlm in publications use:")

citEntry(entry = "Article",
  title        = "An {R} Package for Dynamic Linear Models",
  author       = personList(as.person("Giovanni Petris")),
  journal      = "Journal of Statistical Software",
  year         = "2010",
  volume       = "36",
  number       = "12",
  pages        = "1--16",
  url          = "http://www.jstatsoft.org/v36/i12/",

  textVersion  =
  paste("Giovanni Petris (2010).",
        "An R Package for Dynamic Linear Models.",
        "Journal of Statistical Software, 36(12), 1-16.",
        "URL http://www.jstatsoft.org/v36/i12/.")
)

citEntry(entry = "Book",
         title = "Dynamic Linear Models with R",
         author = personList(as.person("Giovanni Petris"),
         as.person("Sonia Petrone"),
         as.person("Patrizia Campagnoli")),
         year = 2009,
         series = "useR!",
         publisher = "Springer-Verlag, New York",
         textVersion = 
	 paste("Petris, Petrone, and Campagnoli.", 
	       "Dynamic Linear Models with R.",
               "Springer (2009).")
)

####$$$$ dlm\inst\doc/dlm.R
### R code from vignette source 'dlm.Rnw'

###################################################
### code chunk number 1: dlm.Rnw:26-29
###################################################
options(digits=3)
library(dlm)
set.seed(1963)


###################################################
### code chunk number 2: dlm.Rnw:77-78
###################################################
dlm(FF = 1, V = 0.8, GG = 1, W = 0.1, m0 = 0, C0 = 100)


###################################################
### code chunk number 3: dlm.Rnw:85-86
###################################################
dlmModPoly(order = 1, dV = 0.8, dW = 0.1, C0 = 100)


###################################################
### code chunk number 4: dlm.Rnw:100-101
###################################################
myMod <- dlmModPoly()


###################################################
### code chunk number 5: dlm.Rnw:108-112
###################################################
FF(myMod)
W(myMod)
m0(myMod)
V(myMod) <- 0.8


###################################################
### code chunk number 6: dlm.Rnw:193-194
###################################################
myMod <- dlmModPoly() + dlmModSeas(4)


###################################################
### code chunk number 7: dlm.Rnw:250-253
###################################################
dlmModPoly(dV = 0.2, dW = c(0, 0.5)) %+% 
    (dlmModSeas(4, dV = 0, dW = c(0, 0, 0.35)) + 
     dlmModPoly(1, dV = 0.1, dW = 0.03))


###################################################
### code chunk number 8: dlm.Rnw:286-290
###################################################
u <- rnorm(25)
myMod <- dlmModReg(u, dV = 14.5)
myMod$JFF
head(myMod$X)


###################################################
### code chunk number 9: dlm.Rnw:311-314
###################################################
buildFun <- function(x) {
    dlmModPoly(1, dV = exp(x[1]), dW = exp(x[2]))
}


###################################################
### code chunk number 10: dlm.Rnw:320-325
###################################################
fit <- dlmMLE(Nile, parm = c(0,0), build = buildFun)
fit$conv
dlmNile <- buildFun(fit$par)
V(dlmNile)
W(dlmNile)


###################################################
### code chunk number 11: dlm.Rnw:330-331
###################################################
StructTS(Nile, "level")


###################################################
### code chunk number 12: dlm.Rnw:339-352
###################################################
buildFun <- function(x) {
    m <- dlmModPoly(1, dV = exp(x[1]))
    m$JW <- matrix(1)
    m$X <- matrix(exp(x[2]), nc = 1, nr = length(Nile))
    j <- which(time(Nile) == 1899)
    m$X[j,1] <- m$X[j,1] * (1 + exp(x[3]))
    return(m)
}
fit <- dlmMLE(Nile, parm = c(0,0,0), build = buildFun)
fit$conv
dlmNileJump <- buildFun(fit$par)
V(dlmNileJump)
dlmNileJump$X[c(1, which(time(Nile) == 1899)), 1]


###################################################
### code chunk number 13: figFilter
###################################################
nileJumpFilt <- dlmFilter(Nile, dlmNileJump)
plot(Nile, type = 'o', col = "seagreen")
lines(dropFirst(nileJumpFilt$m), type = 'o', 
      pch = 20, col = "brown")


###################################################
### code chunk number 14: dlm.Rnw:405-413
###################################################
nileJumpFilt <- dlmFilter(Nile, dlmNileJump)
plot(Nile, type = 'o', col = "seagreen")
lines(dropFirst(nileJumpFilt$m), type = 'o', 
      pch = 20, col = "brown")
attach(nileJumpFilt)
v <- unlist(dlmSvd2var(U.C, D.C))
pl <- dropFirst(m) + qnorm(0.05, sd = sqrt(v[-1]))
pu <- dropFirst(m) + qnorm(0.95, sd = sqrt(v[-1]))
detach()
lines(pl, lty = 2, col = "brown") 
lines(pu, lty = 2, col = "brown") 


###################################################
### code chunk number 15: dlm.Rnw:433-440
###################################################
attach(nileJumpFilt)
v <- unlist(dlmSvd2var(U.C, D.C))
pl <- dropFirst(m) + qnorm(0.05, sd = sqrt(v[-1]))
pu <- dropFirst(m) + qnorm(0.95, sd = sqrt(v[-1]))
detach()
lines(pl, lty = 2, col = "brown") 
lines(pu, lty = 2, col = "brown") 


###################################################
### code chunk number 16: figSmooth
###################################################
nileJumpSmooth <- dlmSmooth(nileJumpFilt)
plot(Nile, type = 'o', col = "seagreen")
attach(nileJumpSmooth)
lines(dropFirst(s), type = 'o', pch = 20, col = "brown")
v <- unlist(dlmSvd2var(U.S, D.S))
pl <- dropFirst(s) + qnorm(0.05, sd = sqrt(v[-1]))
pu <- dropFirst(s) + qnorm(0.95, sd = sqrt(v[-1]))
detach()
lines(pl, lty = 2, col = "brown") 
lines(pu, lty = 2, col = "brown") 


###################################################
### code chunk number 17: dlm.Rnw:472-473
###################################################
nileJumpSmooth <- dlmSmooth(nileJumpFilt)
plot(Nile, type = 'o', col = "seagreen")
attach(nileJumpSmooth)
lines(dropFirst(s), type = 'o', pch = 20, col = "brown")
v <- unlist(dlmSvd2var(U.S, D.S))
pl <- dropFirst(s) + qnorm(0.05, sd = sqrt(v[-1]))
pu <- dropFirst(s) + qnorm(0.95, sd = sqrt(v[-1]))
detach()
lines(pl, lty = 2, col = "brown") 
lines(pu, lty = 2, col = "brown") 


###################################################
### code chunk number 18: dlm.Rnw:484-495
###################################################
lGas <- log(UKgas)
dlmGas <- dlmModPoly() + dlmModSeas(4)
buildFun <- function(x) {
    diag(W(dlmGas))[2:3] <- exp(x[1:2])
    V(dlmGas) <- exp(x[3])
    return(dlmGas)
}
(fit <- dlmMLE(lGas, parm = rep(0, 3), build = buildFun))$conv
dlmGas <- buildFun(fit$par)
drop(V(dlmGas))
diag(W(dlmGas))[2:3]


###################################################
### code chunk number 19: dlm.Rnw:502-506
###################################################
gasSmooth <- dlmSmooth(lGas, mod = dlmGas)
x <- cbind(lGas, dropFirst(gasSmooth$s[,c(1,3)]))
colnames(x) <- c("Gas", "Trend", "Seasonal")
plot(x, type = 'o', main = "UK Gas Consumption")


###################################################
### code chunk number 20: dlm.Rnw:511-512
###################################################
plot(x, type = 'o', main = "UK Gas Consumption")


###################################################
### code chunk number 21: dlm.Rnw:524-540
###################################################
gasFilt <- dlmFilter(lGas, mod = dlmGas)
gasFore <- dlmForecast(gasFilt, nAhead = 20)
sqrtR <- sapply(gasFore$R, function(x) sqrt(x[1,1]))
pl <- gasFore$a[,1] + qnorm(0.05, sd = sqrtR)
pu <- gasFore$a[,1] + qnorm(0.95, sd = sqrtR)
x <- ts.union(window(lGas, start = c(1982, 1)), 
              window(gasSmooth$s[,1], start = c(1982, 1)),
              gasFore$a[,1], pl, pu) 
plot(x, plot.type = "single", type = 'o', pch = c(1, 0, 20, 3, 3),
     col = c("darkgrey", "darkgrey", "brown", "yellow", "yellow"),
     ylab = "Log gas consumption")
legend("bottomright", legend = c("Observed", 
                      "Smoothed (deseasonalized)", 
                      "Forecasted level", "90% probability limit"),
       bty = 'n', pch = c(1, 0, 20, 3, 3), lty = 1,
       col = c("darkgrey", "darkgrey", "brown", "yellow", "yellow"))


###################################################
### code chunk number 22: dlm.Rnw:545-553
###################################################
plot(x, plot.type = "single", type = 'o', pch = c(1, 0, 20, 3, 3),
     col = c("darkgrey", "darkgrey", "brown", "yellow", "yellow"),
     ylab = "Log gas consumption")
legend("bottomright", legend = c("Observed", 
                      "Smoothed (deseasonalized)", 
                      "Forecasted level", "90% probability limit"),
       bty = 'n', pch = c(1, 0, 20, 3, 3), lty = 1,
       col = c("darkgrey", "darkgrey", "brown", "yellow", "yellow"))


###################################################
### code chunk number 23: dlm.Rnw:618-622
###################################################
plot(Nile, type = 'o', col = "seagreen")
nileFilt <- dlmFilter(Nile, dlmNile)
for (i in 1:10) # 10 simulated "true" levels 
    lines(dropFirst(dlmBSample(nileFilt)), col = "brown") 


###################################################
### code chunk number 24: dlm.Rnw:626-629
###################################################
plot(Nile, type = 'o', col = "seagreen")
for (i in 1:10) # 10 simulated "true" levels 
    lines(dropFirst(dlmBSample(nileFilt)), col = "brown") 


###################################################
### code chunk number 25: dlm.Rnw:658-662
###################################################
lmixnorm <- function(x, weights, means, sds) {
    log(crossprod(weights, exp(-0.5 * ((x - means) / sds)^2 
                               - log(sds))))
}


###################################################
### code chunk number 26: dlm.Rnw:669-681
###################################################
y <- arms(0, myldens = lmixnorm, 
          indFunc = function(x,...) (x > (-100)) * (x < 100), 
          n = 5000, weights = c(1, 3, 2), 
          means = c(-10, 0, 10), sds = c(7, 5, 2))
summary(y)
library(MASS)
truehist(y, prob = TRUE, ylim = c(0, 0.08), bty = 'o')
curve(colSums(c(1, 3, 2) / 6 *
              dnorm(matrix(x, 3, length(x), TRUE), 
                    mean = c(-10, 0, 10), sd = c(7, 5, 2))), 
      add = TRUE)
legend(-25, 0.07, "True density", lty = 1, bty = 'n')


###################################################
### code chunk number 27: dlm.Rnw:685-690
###################################################
truehist(y, prob = TRUE, ylim = c(0, 0.08), bty = 'o')
curve(colSums(c(1, 3, 2) / 6 *
              dnorm(matrix(x, 3, length(x), TRUE), 
                    mean = c(-10, 0, 10), sd = c(7, 5, 2))), add = TRUE)
legend(-25, 0.07, "True density", lty = 1, bty = 'n')


###################################################
### code chunk number 28: dlm.Rnw:768-773
###################################################
outGibbs <- dlmGibbsDIG(lGas, dlmModPoly(2) + dlmModSeas(4),
                        a.y = 1, b.y = 1000, a.theta = 1, 
                        b.theta = 1000,
                        n.sample = 1100, ind = c(2, 3),
                        save.states = FALSE)


###################################################
### code chunk number 29: dlm.Rnw:778-794
###################################################
burn <- 100
attach(outGibbs)
par(mfrow=c(2,3), mar=c(3.1,2.1,2.1,1.1))
plot(dV[-(1:burn)], type = 'l', xlab="", ylab="", main=expression(sigma^2))
plot(dW[-(1:burn),1], type = 'l', xlab="", ylab="", main=expression(sigma[beta]^2))
plot(dW[-(1:burn),2], type = 'l', xlab="", ylab="", main=expression(sigma[s]^2))
use <- length(dV) - burn
from <- 0.05 * use
at <- pretty(c(0,use),n=3); at <- at[at>=from]
plot(ergMean(dV[-(1:burn)], from), type="l", xaxt="n",xlab="", ylab="")
axis(1, at=at-from, labels=format(at))
plot(ergMean(dW[-(1:burn),1], from), type="l", xaxt="n",xlab="", ylab="")
axis(1, at=at-from, labels=format(at))
plot(ergMean(dW[-(1:burn),2], from), type="l", xaxt="n",xlab="", ylab="")
axis(1, at=at-from, labels=format(at))
detach()


###################################################
### code chunk number 30: dlm.Rnw:805-829
###################################################
burn <- 100
attach(outGibbs)
dV <- dV[-(1:burn)]
dW <- dW[-(1:burn), ]
detach()
par(mfrow=c(2,3), mar=c(3.1,2.1,2.1,1.1))
plot(dV, type = 'l', xlab = "", ylab = "", 
     main = expression(sigma^2))
plot(dW[ , 1], type = 'l', xlab = "", ylab = "", 
     main = expression(sigma[beta]^2))
plot(dW[ , 2], type = 'l', xlab = "", ylab = "", 
     main = expression(sigma[s]^2))
use <- length(dV) - burn
from <- 0.05 * use
at <- pretty(c(0, use), n = 3); at <- at[at >= from]
plot(ergMean(dV, from), type = 'l', xaxt = 'n',
     xlab = "", ylab = "")
axis(1, at = at - from, labels = format(at))
plot(ergMean(dW[ , 1], from), type = 'l', xaxt = 'n',
     xlab = "", ylab = "")
axis(1, at = at - from, labels = format(at))
plot(ergMean(dW[ , 2], from), type = 'l', xaxt = 'n',
     xlab = "", ylab = "")
axis(1, at =  at - from, labels = format(at))


###################################################
### code chunk number 31: dlm.Rnw:836-837
###################################################
mcmcMean(cbind(dV[-(1:burn)], dW[-(1:burn), ]))


###################################################
### code chunk number 32: dlm.Rnw:839-840
###################################################
rm(dV, dW)


####$$$$ dlm\inst\doc/dlm.Rnw
\documentclass[11pt]{article}
\usepackage{amsmath}
%\VignetteIndexEntry{dlm: MLE and Bayesian analysis of Dynamic Linear Models}
%\VignettePackage{dlm}
%\VignetteKeyword{State space models}
%\VignetteKeyword{Kalman filter}
%\VignetteKeyword{Bayesian analysis}

\SweaveOpts{keep.source=TRUE, width=10, height=6}
\newcommand{\Y}{\mathord{\mathcal{Y}}}
\newcommand{\tr}{\mathop{\mathrm{tr}}}
\newcommand{\rlan}{\texttt{R}}
\newcommand{\dlm}{\texttt{dlm}}
\newcommand{\code}[1]{\texttt{#1}}

\title{\dlm{}: an \rlan{}  package for Bayesian analysis of Dynamic Linear Models} 
\author{Giovanni Petris\\
{\small University of Arkansas, Fayetteville AR}}
\date{2009-01-14}

\begin{document}
\setkeys{Gin}{width=0.9\textwidth}

\maketitle

<<echo=false, results=hide>>=
options(digits=3)
library(dlm)
set.seed(1963)
@

\section{Defining and manipulating Dynamic Linear Models}
Package \dlm{} focuses on Bayesian analysis of Dynamic Linear Models (DLMs),
also known as linear state space models (see \cite{Harvey:1989,
  West+Harrison:1997}). The package also includes functions for maximum
likelihood estimation of the parameters of a DLM and for Kalman filtering. The
algorithms used for Kalman filtering, likelihood evaluation, and sampling from
the state vectors are based on the singular value decomposition (SVD) of the
relevant variance matrices (see \cite{Zhang+Li:1996}), which improves
numerical stability over other algorithms.  \bigskip

\subsection{The model}
A DLM is specified by the following equations:
$$\left\{ 
  \begin{aligned}
    y_t &= F_t\theta_t + v_t, & v_t&\sim \mathcal{N}(0,V_t)\\
    \theta_t &= G_t\theta_{t-1} + w_t, & w_t&\sim \mathcal{N}(0,W_t)
  \end{aligned}\right.
$$
for $t=1,\dots, n$, together with a \emph{prior} distribution for $\theta_0$: 
$$ \theta_0\sim \mathcal{N}(m_0, C_0).$$
Here $y_t$ is an $m$-dimensional vector, representing the observation at time
$t$, while $\theta_t$ is a generally unobservable $p$-dimensional vector
representing the state of the system at time $t$. The $v_t$'s are observation
errors and the $w_t$'s evolution errors. The matrices $F_t$ and $G_t$ have
dimension $m$ by $p$ and $p$ by $p$, respectively, while $V_t$ and $W_t$ are
variance matrices of the appropriate dimension. 

\subsection{Defining DLMs with \dlm{}}
One of the simplest DLMs is the random walk plus noise model, also called
first order polynomial model. It is used to model univariate observations,
the state vector is unidimensional, and it is described by the equations
$$\left\{ 
  \begin{aligned}
    y_t &= \theta_t + v_t, & v_t&\sim \mathcal{N}(0,V)\\
    \theta_t &= \theta_{t-1} + w_t, & w_t&\sim \mathcal{N}(0,W)
  \end{aligned}\right.
$$
The model is \emph{constant}, i.e., the various matrices defining its
dynamics are time-invariant. Moreover, $F_t = G_t = [1]$. The only parameters
of the model are the observation and evolution variances $V$ and $W$. These
are usually estimated from available data using maximum likelihood or Bayesian
techniques. In package \dlm{} a constant DLM is represented as a list with
components \code{FF, V, GG, W}, having class \code{"dlm"}. A random walk plus
noise model, with $V = 0.8$ and $W = 0.1$, can be defined in R as follows:

<<results = hide>>=
dlm(FF = 1, V = 0.8, GG = 1, W = 0.1, m0 = 0, C0 = 100)
@ 

Note that the mean and variance of the prior distribution of $\theta_0$ must
be specified, as they are an integral part of the model definition. An
alternative way to define the same models is 

<<results = hide>>=
dlmModPoly(order = 1, dV = 0.8, dW = 0.1, C0 = 100)
@ 

This function has default values for \code{m0, C0, dV} and \code{dW} (the
last two are used to specify the \emph{diagonal} of $V$ and $W$,
respectively). In fact it also has a default value for the \emph{order} of the
polynomial model, so the user must be aware of these defaults before using
them light-heartedly. In particular, the default values for \code{dV} and
\code{dW} should be more correctly thought as place holders that are there
just to allow a complete specification of the model. 
\bigskip

Consider the second-order polynomial model obtained as

<<>>=
myMod <- dlmModPoly()
@ 
%
Individual components of the model can be accessed and modified in a natural
way by using the exctractor and replacement functions provided by the
package.

<<>>= 
FF(myMod)
W(myMod)
m0(myMod)
V(myMod) <- 0.8
@ 

In addition to \code{dlmModPoly}, \dlm{} provides other functions to create
DLMs of standard types. They are summarized in Table~\ref{tab:dlmMod}. 
\begin{table}[htbp]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \multicolumn{1}{|c}{Function} & \multicolumn{1}{|c|}{Model}\\
    \hline\hline
    \code{dlmModARMA}&              ARMA process\\
    \code{dlmModPoly}&              $n$th order polynomial DLM\\
    \code{dlmModReg}&               Linear regression\\
    \code{dlmModSeas}&              Periodic -- Seasonal factors\\
    \code{dlmModTrig}&              Periodic -- Trigonometric form\\
    \hline
  \end{tabular}
  \caption{Creator functions for special models.}
  \label{tab:dlmMod}
\end{table}
With the exception of \code{dlmModARMA}, which handles also the multivariate case, the
other creator functions are limited to the case of univariate observations.
More complicated DLMs can be explicitely defined using the general function
\code{dlm}. 

\subsection{Combining models: sums and outer sums}
From a few basic models, one can obtain more general models by means of
different forms of ``addition''. In general, suppose that one has $k$
independent DLMs for $m$-dimensional observations, where the $i$th one is
defined by the system
\begin{equation}
  \label{eq:component}
  \left\{ 
    \begin{aligned}
      y^{(i)}_t &= F^{(i)}_t \theta^{(i)}_t + v^{(i)}_t, & v^{(i)}_t&\sim 
      \mathcal{N}(0,V^{(i)})\\ 
      \theta^{(i)}_t &= G^{(i)}_t \theta^{(i)}_{t-1} + w^{(i)}_t, &
      w^{(i)}_t&\sim \mathcal{N}(0,W^{(i)}) 
    \end{aligned}\right.
\end{equation}
$m^{(i)}_0$ and $C^{(i)}_0$ are the mean and variance of the initial state
in DLM $i$. Note that the state vectors may have different dimensions $p_1,
\dots, p_k$ across different DLMs. Each model may represent a simple feature
of the observation process, such as a stochastic trend, a periodic
component, and so on, so that $y_t = y^{(1)}_t + \cdot + y^{(k)}_t$ is the
actual observation at time $t$. This suggests to combine, or add, the DLMs
into a comprehensive one by defining the state of the system by $\theta_t' =
\bigl( {\theta^{(1)}_t}', \dots, {\theta^{(k)}_t}' \bigr)$, together with the
matrices 
\begin{align*}
  F_t &= \bigl( F^{(1)}_t\mid\ldots\mid F^{(k)}_t\bigr), & V_t &= \sum_{i=1}^k
  V^{(i)}_t,\\
  G_t &= 
  \begin{bmatrix}
    G^{(1)}_t & &\\
    & \ddots &\\
    && G^{(k)}_t
  \end{bmatrix}, &
 W_t &= 
  \begin{bmatrix}
    W^{(1)}_t & &\\
    & \ddots &\\
    && W^{(k)}_t
  \end{bmatrix},\\
  m_0' &= \bigl({m^{(1)}_0}', \ldots, {m^{(k)}_0}'\bigr), &
  C_0 &=  
  \begin{bmatrix}
    C^{(1)}_0 & &\\
    & \ddots &\\
    && C^{(k)}_0
  \end{bmatrix}.
\end{align*}
The form just described of model composition can be thought of as a sum of
models. Package \dlm{} provides a method function for the generic \code{+} for
objects of class \code{dlm} which performs this sum of DLMs.

For example, suppose one wants to model a time series as a sum of a stochastic
linear trend and a quarterly seasonal component, observed with noise. The
model can be set up as follows:

<<results = hide>>= 
myMod <- dlmModPoly() + dlmModSeas(4)
@ 
%
The nonzero entries in the $V$ and $W$ matrices can be specified to have more
meaningful values in the calls to \code{dlmModPoly} and/or \code{dlmModSeas},
or changed after the combined model is set up. 
\bigskip

There is another natural way of combining DLMs which resembles an ``outer''
sum. Consider again the $k$ models \eqref{eq:component}, but suppose the
dimension of the observations may be different for each model, say $m_1,\dots,
m_k$. An obvious way of obtaining a multivariate model including all the
$y^{(i)}_t$ is to consider the models to be independent and set $y_t' = \bigl(
{y^{(1)}_t}', \dots, {y^{(k)}_t}' \bigr)$. Note that each $y^{(i)}_t$ may
itself be a random vector. This corresponds to the definition of a new DLM
with state vector $\theta_t' = \bigl( {\theta^{(1)}_t}', \dots,
{\theta^{(k)}_t}' \bigr)$, as in the previous case, and matrices
\begin{align*}
  F_t &= 
  \begin{bmatrix}
    F^{(1)}_t & &\\
    & \ddots &\\
    && F^{(k)}_t
  \end{bmatrix}, &
 V_t &= 
  \begin{bmatrix}
    V^{(1)}_t & &\\
    & \ddots &\\
    && V^{(k)}_t
  \end{bmatrix},\\
  G_t &= 
  \begin{bmatrix}
    G^{(1)}_t & &\\
    & \ddots &\\
    && G^{(k)}_t
  \end{bmatrix}, &
 W_t &= 
  \begin{bmatrix}
    W^{(1)}_t & &\\
    & \ddots &\\
    && W^{(k)}_t
  \end{bmatrix},\\
  m_0' &= \bigl({m^{(1)}_0}', \ldots, {m^{(k)}_0}'\bigr), &
  C_0 &=  
  \begin{bmatrix}
    C^{(1)}_0 & &\\
    & \ddots &\\
    && C^{(k)}_0
  \end{bmatrix}.
\end{align*}

For example, suppose you have two time series, the first following a
stochastic linear trend and the second a random noise plus a quarterly
seasonal component, both series being observed with noise. A joint DLM for the
two series, assuming independence, can be set up in \rlan{} as follow.

<<results = hide>>= 
dlmModPoly(dV = 0.2, dW = c(0, 0.5)) %+% 
    (dlmModSeas(4, dV = 0, dW = c(0, 0, 0.35)) + 
     dlmModPoly(1, dV = 0.1, dW = 0.03))
@ 

\subsection{Time-varying models}
In a time-varying DLM at least one of the entries of $F_t$, $V_t$, $G_t$, or
$W_t$ changes with time. We can think of any such entry as a time series or,
more generally, a numeric vector. All together, the time-varying entries of
the model matrices can be stored as a multivariate time series or a numeric
matrix. This idea forms the basis for the internal representation of a
time-varying DLM. A object \code{m} of class \code{dlm} may contain components
named \code{JFF, JV, JGG, JW}, and \code{X}. The first four are matrices of
integers of the same dimension as \code{FF, V, GG, W}, respectively, while
\code{X} is an $n$ by $m$ matrix, where $n$ is the number of observations in
the data. Entry $(i, j)$ of \code{JFF} is zero if the corresponding entry of
\code{FF} is time invariant, or $k$ if the vector of values of $F_t[i,j]$ at
different times is stored in \code{X[,k]}. In this case the actual value of
\code{FF[i,j]} in the model object is not used. Similarly for the remaining
matrices of the DLM. For example, a dynamic linear regression can be modeled
as
$$\left\{ 
  \begin{aligned}
    y_t &= \alpha_t + x_t\beta_t + v_t & v_t&\sim \mathcal{N}(0,V_t)\\
    \alpha_t &= \alpha_{t-1} + w_{\alpha,t}, & w_{\alpha,t} &\sim
    \mathcal{N}(0,W_{\alpha,t})\\ 
    \beta_t &= \beta_{t-1} + w_{\beta,t}, & w_{\beta,t} &\sim
    \mathcal{N}(0,W_{\beta,t}). 
  \end{aligned}\right.
$$
Here the state of the system is $\theta_t = (\alpha_t,\; \beta_t)'$, with
$\beta_t$ being the regression coefficient at time $t$ and $x_t$ being a
covariate at time $t$, so that $F_t = [1,\; x_t]$. Such a DLM can be set up in
\rlan{} as follows,

<<>>=
u <- rnorm(25)
myMod <- dlmModReg(u, dV = 14.5)
myMod$JFF
head(myMod$X)
@ 

Currently the outer sum of time-varying DLMs is not implemented.

\section{Maximum likelihood estimation}\label{sec:mle}
It is often the case that one has unknown parameters in the matrices defining
a DLM. While package \dlm{} was primarily developed for Bayesian inference, it
offers the possibility of estimating unknown parameters using maximum
likelihood. The function \code{dlmMLE} is essentially a wrapper around a call
to \code{optim}. In addition to the data and starting values for the
optimization algorithm, the function requires a function argument that
``builds'' a DLM from any specific value of the unknown parameter vector. We
illustrate the usage of \code{dlmMLE} with a couple of simple examples.
\bigskip

Consider the Nile river data set. A reasonable model can be a random walk plus
noise, with unknown system and observation variances. Parametrizing variances
on a log scale, to ensure positivity, the model can be build using the
function defined below.

<<>>= 
buildFun <- function(x) {
    dlmModPoly(1, dV = exp(x[1]), dW = exp(x[2]))
}
@ 

Starting the optimization from the arbitrary $(0,0)$ point, the MLE of the
parameter can be found as follows.

<<>>= 
fit <- dlmMLE(Nile, parm = c(0,0), build = buildFun)
fit$conv
dlmNile <- buildFun(fit$par)
V(dlmNile)
W(dlmNile)
@ 

For comparison, the estimated variances obtained using \code{StructTS} are

<<>>=
StructTS(Nile, "level")
@ 

As a less trivial example, suppose one wants to take into account a jump in
the flow of the river following the construction of Ashwan dam in 1898. This
can be done by inflating the system variance in 1899 using a multiplier bigger
than one.\label{p:nileJump}

<<>>=
buildFun <- function(x) {
    m <- dlmModPoly(1, dV = exp(x[1]))
    m$JW <- matrix(1)
    m$X <- matrix(exp(x[2]), nc = 1, nr = length(Nile))
    j <- which(time(Nile) == 1899)
    m$X[j,1] <- m$X[j,1] * (1 + exp(x[3]))
    return(m)
}
fit <- dlmMLE(Nile, parm = c(0,0,0), build = buildFun)
fit$conv
dlmNileJump <- buildFun(fit$par)
V(dlmNileJump)
dlmNileJump$X[c(1, which(time(Nile) == 1899)), 1]
@ 

The conclusion is that, after accounting for the 1899 jump, the level of the
series is essentially constant in the periods before and after that year.


\section{Filtering, smoothing and forecasting}
Thanks to the fact that the joint distribution of states and observations is
Gaussian, when all the parameters of a DLM are known it is fairly easy to
derive conditional distributions of states or future observations conditional
on the observed data. In what follows, for any pair of integers $(i,j)$, with
$i\leq j$, we will denote by $y_{i:j}$ the observations from the $i$th to the
$j$th, inclusive, i.e., $y_i, \dots, y_j$; a similar notation will be used for
states. The \emph{filtering} distribution at time $t$ is the conditional
distribution of $\theta_t$ given $y_{1:t}$. The \emph{smoothing} distribution
at time $t$ is the conditional distribution of $\theta_{0:t}$ given $y_{1:t}$,
or sometimes, with an innocuous abuse of language, any of its marginals, e.g.,
the conditional distribution of $\theta_s$ given $y_{1:t}$, with $s\leq t$.
Clearly, for $s = t$ this marginal coincides with the filtering distribution.
We speak of \emph{forecast} distribution, or \emph{predictive} distribution,
to denote a conditional distribution of future states and/or observations,
given the data up to time $t$.  Recursive algorithms, based on the celebrated
Kalman filter algorithm or extensions thereof, are available to compute
filtering and smoothing distributions. Predictive distributions can be easily
derived recursively from the model definition, using as ``prior'' mean and
variance -- $m_0$ and $C_0$ -- the mean and variance of the filtering
distribution. This is the usual Bayesian sequential updating, in which the
posterior at time $t$ takes the role of a prior distribution for what concerns
the observations after time $t$. Note that any marginal or conditional
distribution, in particular the filtering, smoothing and predictive
distributions, is Gaussian and, as such, it is identified by its mean and
variance. 


\subsection{Filtering}
Consider again the last model fitted to the Nile river data on page
\pageref{p:nileJump}. Taking the estimated parameters as known, we can compute
the filtering distribution using \code{dlmFilter}. If $n$ is the number of
observations in the data set, \code{dlmFilter} returns the mean and variance
of the $n+1$ filtering distributions that can be computed from the data, i.e.,
the distribution of $\theta_t$ given $y_{1:t}$ for $t = 0,1, \dots, n$ (for
$t=0$, this is by convention the prior distribution of $\theta_0$).

<<figFilter>>=  
nileJumpFilt <- dlmFilter(Nile, dlmNileJump)
plot(Nile, type = 'o', col = "seagreen")
lines(dropFirst(nileJumpFilt$m), type = 'o', 
      pch = 20, col = "brown")
@ 

\begin{figure}[htbp]
  \centering
<<echo=false, fig=true>>=  
<<figFilter>>
attach(nileJumpFilt)
v <- unlist(dlmSvd2var(U.C, D.C))
pl <- dropFirst(m) + qnorm(0.05, sd = sqrt(v[-1]))
pu <- dropFirst(m) + qnorm(0.95, sd = sqrt(v[-1]))
detach()
lines(pl, lty = 2, col = "brown") 
lines(pu, lty = 2, col = "brown") 
@ 
  \caption{Nile data with filtered level}
  \label{fig:nileFilter}
\end{figure}

The variances $C_0, \dots, C_n$ of the filtering distributions are returned in
terms of their singular value decomposition (SVD). The SVD of a symmetric
nonnegative definite matrix $\Sigma$ is $\Sigma = UD^2U'$, where $U$ is
orthogonal and $D$ is diagonal. In the list returned by \code{dlmFilter}, the
$U$ and $D$ matrices corresponding to the SVD of $C_0, \dots, C_n$ can be
found as components \code{U.C} and \code{D.C}, respectively. While \code{U.C}
is a list of matrices, since the $D$ part in the SVD is diagonal, \code{D.C}
consists in a matrix, storing in each row the diagonal entries of succesive
$D$ matrices. This decomposition is useful for further calculations one may be
interested in, such as smoothing. However, if the filtering variances are of
interest per se, then \dlm{} provides the utility function \code{dlmSvd2var},
which reconstructs the variances from their SVD. Variances can then be used
for example to compute filtering probability intervals, as illustrated below.

<<>>=
attach(nileJumpFilt)
v <- unlist(dlmSvd2var(U.C, D.C))
pl <- dropFirst(m) + qnorm(0.05, sd = sqrt(v[-1]))
pu <- dropFirst(m) + qnorm(0.95, sd = sqrt(v[-1]))
detach()
lines(pl, lty = 2, col = "brown") 
lines(pu, lty = 2, col = "brown") 
@ 

In addition to filtering means and variances, \code{dlmFilter} also returns
means and variances of the distributions of $\theta_t$ given $y_{1:{t-1}}$,
$t=1, \dots, n$ (one-step-ahead forecast distributions for the states) and
means of the distributions of $y_t$ given $y_{1:{t-1}}$, $t=1, \dots, n$
(one-step-ahead forecast distributions for the observations). The variances
are returned also in this case in terms of their SVD.

\subsection{Smoothing}
The function \code{dlmSmooth} computes means and variances of the smoothing
distributions. It can be given a data vector or matrix together with a
specific object of class \code{dlm} or, alternatively, a ``filtered DLM''
produced by \code{dlmFilter}. The following \rlan{} code shows how to use the
function in the Nile river example.

<<figSmooth>>=
nileJumpSmooth <- dlmSmooth(nileJumpFilt)
plot(Nile, type = 'o', col = "seagreen")
attach(nileJumpSmooth)
lines(dropFirst(s), type = 'o', pch = 20, col = "brown")
v <- unlist(dlmSvd2var(U.S, D.S))
pl <- dropFirst(s) + qnorm(0.05, sd = sqrt(v[-1]))
pu <- dropFirst(s) + qnorm(0.95, sd = sqrt(v[-1]))
detach()
lines(pl, lty = 2, col = "brown") 
lines(pu, lty = 2, col = "brown") 
@ 

\begin{figure}[htbp]
  \centering
<<echo=false, fig=true>>=
<<figSmooth>>
@ 
  \caption{Nile river data with smoothed level}
  \label{fig:nileSmooth}
\end{figure}

As a second example, consider the UK gas consumption data set. On a
logarithmic scale, this can be reasonably modeled by a DLM containing a
quarterly seasonal component and a local linear trend, in the form of an
integrated random walk. We first estimate the unknown variances by ML.

<<>>=
lGas <- log(UKgas)
dlmGas <- dlmModPoly() + dlmModSeas(4)
buildFun <- function(x) {
    diag(W(dlmGas))[2:3] <- exp(x[1:2])
    V(dlmGas) <- exp(x[3])
    return(dlmGas)
}
(fit <- dlmMLE(lGas, parm = rep(0, 3), build = buildFun))$conv
dlmGas <- buildFun(fit$par)
drop(V(dlmGas))
diag(W(dlmGas))[2:3]
@ 

Based on the fitted model, we can compute the smoothing estimates of the
states. This can be used to obtain a decomposition of the data into a smooth
trend plus a stochastic seasonal component, subject to measurement error.

<<>>= 
gasSmooth <- dlmSmooth(lGas, mod = dlmGas)
x <- cbind(lGas, dropFirst(gasSmooth$s[,c(1,3)]))
colnames(x) <- c("Gas", "Trend", "Seasonal")
plot(x, type = 'o', main = "UK Gas Consumption")
@ 

\begin{figure}[htbp]
  \centering
<<echo=false, fig=true>>=
plot(x, type = 'o', main = "UK Gas Consumption")
@ 
  \caption{Gas consumption with ``trend + seasonal'' decomposition}
  \label{fig:gasDecomposition}
\end{figure}

\subsection{Forecasting}
Means and variances of the forecast distributions of states and observations
can be obtained with the function \code{dlmForecast}, as illustrated in the
code below. Means and variances of future states and observations are returned
in a list as components \code{a, R, f,} and \code{Q}.

<<>>=
gasFilt <- dlmFilter(lGas, mod = dlmGas)
gasFore <- dlmForecast(gasFilt, nAhead = 20)
sqrtR <- sapply(gasFore$R, function(x) sqrt(x[1,1]))
pl <- gasFore$a[,1] + qnorm(0.05, sd = sqrtR)
pu <- gasFore$a[,1] + qnorm(0.95, sd = sqrtR)
x <- ts.union(window(lGas, start = c(1982, 1)), 
              window(gasSmooth$s[,1], start = c(1982, 1)),
              gasFore$a[,1], pl, pu) 
plot(x, plot.type = "single", type = 'o', pch = c(1, 0, 20, 3, 3),
     col = c("darkgrey", "darkgrey", "brown", "yellow", "yellow"),
     ylab = "Log gas consumption")
legend("bottomright", legend = c("Observed", 
                      "Smoothed (deseasonalized)", 
                      "Forecasted level", "90% probability limit"),
       bty = 'n', pch = c(1, 0, 20, 3, 3), lty = 1,
       col = c("darkgrey", "darkgrey", "brown", "yellow", "yellow"))
@ 

\begin{figure}[htbp]
  \centering
<<echo=false, fig=true>>=
plot(x, plot.type = "single", type = 'o', pch = c(1, 0, 20, 3, 3),
     col = c("darkgrey", "darkgrey", "brown", "yellow", "yellow"),
     ylab = "Log gas consumption")
legend("bottomright", legend = c("Observed", 
                      "Smoothed (deseasonalized)", 
                      "Forecasted level", "90% probability limit"),
       bty = 'n', pch = c(1, 0, 20, 3, 3), lty = 1,
       col = c("darkgrey", "darkgrey", "brown", "yellow", "yellow"))
@ 
  \caption{Gas consumption forecast}
  \label{fig:gasForecast}
\end{figure}


\section{Bayesian analysis of Dynamic Linear Models}
If all the parameters defining a DLM are known, then the functions for
smoothing and forecasting illustrated in the previous section are all is
needed to perform a Bayesian analysis. At least, this is true if one is
interested in posterior estimates of unobservable states and future
observations or states. In almost every real world application a DLM contains
in its specification one or more unknown parameters that need to be estimated.
Except for a few very simple models and special priors, the posterior
distribution of the unknown parameters -- or the joint posterior of parameters
and states -- does not have a simple form, so the common approach is to use
Markov chain Monte Carlo (MCMC) methods to generate a sample from the
posterior\footnote{%
  An alternative to MCMC is provided by Sequential Monte Carlo methods, which
  will not be discussed here.}. % 
MCMC is highly model- and prior-dependent, even within the class of DLMs, and
therefore we cannot give a general algorithm or canned function that works in
all cases. However, package \dlm{} provides a few functions to facilitate
posterior simulation via MCMC. In addition, the package provides a minimal set
of tools for analyzing the output of a sampler.

\subsection{Forward filtering backward sampling}
One way of obtaining a sample from the joint posterior of parameters and
unobservable states is to run a Gibbs sampler, alternating draws from the full
conditional distribution of the states and from the full conditionals of the
parameters. While generating the parameters is model dependent, a draw from
the full conditional distribution of the states can be obtained easily in a
general way using the so-called Forward Filtering Backward Sampling (FFBS)
algorithm, developed independently by \cite{Carter+Kohn:1994, Fruewirth:1994,
  Shephard:1994}. The algorithm consists essentially in a simulation version
of the Kalman smoother. An alternative algorithm can be found in
\cite{Durbin+Koopman:2001}.  Note that, within a Gibbs sampler, when
generating the states, the model parameters are fixed at their most recently
generated value. The problem therefore reduces to that of drawing from the
conditional distribution of the states given the observations for a completely
specified DLM, which is efficiently done based on the general structure of a
DLM. 

In many cases, even if one is not interested in the states but only in the
unknown parameters, keeping also the states in the posterior distribution
simplifies the Gibbs sampler. This typically happens when there are unknown
parameters in the system equation and system variances, since usually
conditioning on the states makes those parameters independent of the data and
results in simpler full conditional distributions. In this framework,
including the states in the sampler can be seen as a data augmentation
technique.

In package \dlm{}, FFBS is implemented in the function
\code{dlmBSample}. To be more precise, this function only performs the
backward sampling part of the algorithm, starting from a filtered model. The
only argument of \code{dlmBSample} is in fact a \code{dlmFiltered} object, or
a list that can be interpreted as such. 

In the code below we generate and plot (Figure~\ref{fig:nileFFBS}) ten
simulated realizations from the posterior distribution of the unobservable
``true level'' of the Nile river, using the random walk plus noise model
(without level jump, see Section~\ref{sec:mle}). Model parameters are fixed for
this example to their MLE.

<<>>=
plot(Nile, type = 'o', col = "seagreen")
nileFilt <- dlmFilter(Nile, dlmNile)
for (i in 1:10) # 10 simulated "true" levels 
    lines(dropFirst(dlmBSample(nileFilt)), col = "brown") 
@ 
\begin{figure}[htbp]
  \centering
<<echo=false, fig=true>>=
plot(Nile, type = 'o', col = "seagreen")
for (i in 1:10) # 10 simulated "true" levels 
    lines(dropFirst(dlmBSample(nileFilt)), col = "brown") 
@ 
  \caption{Nile river with simulated \emph{true level}s}
  \label{fig:nileFFBS}
\end{figure}
%
The figure would look much different had we used the model with a jump!

\subsection{Adaptive rejection Metropolis sampling}
Gilks and coauthors developed in \cite{Gilks+Best+Tan:1995} a clever adaptive
method, based on rejection sampling, to generate a random variable from any
specified continuous distribution. Although the algorithm requires the support
of the target distribution to be bounded, if this is not the case one can, for
all practical purposes, restrict the distribution to a very large but bounded
interval. Package \dlm{} provides a port to the original C code written by
Gilks with the function \code{arms}. The arguments of \code{arms} are a
starting point, two functions, one returning the log of the target density and
the other being the indicator of its support, and the size of the requested
sample. Additional arguments for the log density and support indicator can be
passed via the \code{...} argument. The help page contain several examples,
most of them unrelated to DLMs. A nontrivial one is the following, dealing
with a mixture of normals target. Suppose the target is
$$f(x) = \sum_{i=1}^k p_i \phi(x; \mu_i, \sigma_i),
$$
where $\phi(\cdot;\mu, \sigma)$ is the density of a normal random variable
with mean $\mu$ and variance $\sigma^2$.
The following is an \rlan{} function that returns the log density at the point
\code{x}: 

<<>>=
lmixnorm <- function(x, weights, means, sds) {
    log(crossprod(weights, exp(-0.5 * ((x - means) / sds)^2 
                               - log(sds))))
}
@ 

Note that the weights $p_i$'s, as well as means and standard deviations, are
additional arguments of the function. Since the support of the density is the
entire real line, we use a reasonably large interval as ``practical support''.

<<>>=
y <- arms(0, myldens = lmixnorm, 
          indFunc = function(x,...) (x > (-100)) * (x < 100), 
          n = 5000, weights = c(1, 3, 2), 
          means = c(-10, 0, 10), sds = c(7, 5, 2))
summary(y)
library(MASS)
truehist(y, prob = TRUE, ylim = c(0, 0.08), bty = 'o')
curve(colSums(c(1, 3, 2) / 6 *
              dnorm(matrix(x, 3, length(x), TRUE), 
                    mean = c(-10, 0, 10), sd = c(7, 5, 2))), 
      add = TRUE)
legend(-25, 0.07, "True density", lty = 1, bty = 'n')
@ 
\begin{figure}[htbp]
  \centering
<<echo=false, fig=true>>=
truehist(y, prob = TRUE, ylim = c(0, 0.08), bty = 'o')
curve(colSums(c(1, 3, 2) / 6 *
              dnorm(matrix(x, 3, length(x), TRUE), 
                    mean = c(-10, 0, 10), sd = c(7, 5, 2))), add = TRUE)
legend(-25, 0.07, "True density", lty = 1, bty = 'n')
@ 
  \caption{Mixture of 3 Normals}
  \label{fig:armsUni}
\end{figure}

A useful extension in the function \code{arms} is the possibility of
generating samples from multivariate target densities. This is obtained by
generating a random line through the starting, or current, point and applying
the univariate ARMS algorithm along the selected line. Several examples of
this type of application are contained in the help page.

\subsection{Gibbs sampling: an example}
We provide in this section a simple example of a Gibbs sampler for a DLM with
unknown variances. This type of model is rather common in applications and is
sometimes referred to as \emph{$d$-inverse-gamma} model. 

Consider again the UK gas consumption data modeled as a local linear trend
plus a seasonal component, observed with noise. The model is based on the
unobserved state
$$\theta_t = \bigl(\mu_t\;\beta_t\; s^{(1)}_t\; s^{(2)}_t\; s^{(3)}_t\bigr)',
$$
where $\mu_t$ is the current level, $\beta_t$ is the slope of the trend,
$s^{(1)}_t, s^{(2)}_t$ and $s^{(3)}_t$ are the seasonal components during the
current quarter, previous quarter, and two quarters back. The observation at
time $t$ is given by
$$y_t = \mu_t + s^{(1)}_t + v_t, \qquad v_t\sim\mathcal{N}(0, \sigma^2).
$$
We assume the following dynamics for the unobservable states:
\begin{align*}
  \mu_t &= \mu_{t-} + \beta_{t-1},\\
  \beta_t &= \beta_{t-1} + w^\beta_t,\qquad w^\beta_t\sim\mathcal{N}(0,
  \sigma_\beta^2) \\
  s^{(1)}_t &= -s^{(1)}_{t-1} - s^{(2)}_{t-1} - s^{(3)}_{t-1} + w^s_t,\qquad
  w^\beta_t\sim\mathcal{N}(0, \sigma_s^2)\\
  s^{(2)}_t &= s^{(1)}_{t-1},\\
  s^{(3)}_t &= s^{(2)}_{t-1}.
\end{align*}
In terms of the DLM representing the model, the above implies
\begin{align*}
  V &= [\sigma^2],\\
  W &= \mathrm{diag}(0, \sigma_\beta^2, \sigma_s^2, 0, 0).
\end{align*}
For details on the model, see \cite{West+Harrison:1997}. The unknown
parameters are therefore the three variances $\sigma^2, \sigma_\beta^2$, and
$\sigma_s^2$. We assume for their inverse, i.e., for the three precisions,
independent gamma priors with mean $a, a_{\theta,2}, a_{\theta,3}$ and
variance $b, b_{\theta,2}, b_{\theta,3}$, respectively.  

Straightforward calculations show that, adding the unobservable states as
latent variables, a Gibbs sampler can be run based on the following full
conditional distributions:
\begin{align*}
  \theta_{0:n} &\sim\mathcal{N}(),\\
  \sigma^2 &\sim\mathcal{IG}\left( \frac{a^2}{b} + \frac{n}{2},
    \frac{a}{b} + \frac{1}{2} SS_y \right),\\
  \sigma_\beta^2 &\sim\mathcal{IG}\left( \frac{a_{\theta,2}^2}{b_{\theta,2}}
    + \frac{n}{2}, \frac{a_{\theta,2}}{b_{\theta,2}} + \frac{1}{2}
    SS_{\theta,2} \right),\\
  \sigma_s^2 &\sim\mathcal{IG}\left( \frac{a_{\theta,3}^2}{b_{\theta,3}}
    + \frac{n}{2}, \frac{a_{\theta,3}}{b_{\theta,3}} + \frac{1}{2}
    SS_{\theta,3} \right),
\end{align*}
with
\begin{align*}
  SS_y &= \sum_{t=1}^n (y_t - F_t\theta_t)^2,\\
  SS_{\theta,i} &= \sum_{t=1}^T (\theta_{t,i} - (G_t\theta_{t-1})_i)^2, \qquad
  i = 2, 3.
\end{align*}
The full conditional of the states is normal with some mean and variance that
we don't need to derive explicitely, since \code{dlmBSample} will take care of
generating $\theta_{0:n}$ from the appropriate distribution. 

The function \code{dlmGibbsDIG}, included in the package more for didactical
reasons than anything else, implements a Gibbs sampler based on the full
conditionals described above. A piece of \rlan{} code that runs the sampler
will look like the following.

<<>>=
outGibbs <- dlmGibbsDIG(lGas, dlmModPoly(2) + dlmModSeas(4),
                        a.y = 1, b.y = 1000, a.theta = 1, 
                        b.theta = 1000,
                        n.sample = 1100, ind = c(2, 3),
                        save.states = FALSE)
@ 
\begin{figure}[htbp]
  \SweaveOpts{width=6, height=6}
  \centering
<<echo=false, fig=true>>=
burn <- 100
attach(outGibbs)
par(mfrow=c(2,3), mar=c(3.1,2.1,2.1,1.1))
plot(dV[-(1:burn)], type = 'l', xlab="", ylab="", main=expression(sigma^2))
plot(dW[-(1:burn),1], type = 'l', xlab="", ylab="", main=expression(sigma[beta]^2))
plot(dW[-(1:burn),2], type = 'l', xlab="", ylab="", main=expression(sigma[s]^2))
use <- length(dV) - burn
from <- 0.05 * use
at <- pretty(c(0,use),n=3); at <- at[at>=from]
plot(ergMean(dV[-(1:burn)], from), type="l", xaxt="n",xlab="", ylab="")
axis(1, at=at-from, labels=format(at))
plot(ergMean(dW[-(1:burn),1], from), type="l", xaxt="n",xlab="", ylab="")
axis(1, at=at-from, labels=format(at))
plot(ergMean(dW[-(1:burn),2], from), type="l", xaxt="n",xlab="", ylab="")
axis(1, at=at-from, labels=format(at))
detach()
@ 
  \caption{Trace plots (top) and running ergodic means (bottom)}
  \label{fig:gibbsUKgas}
\end{figure}


After discarding the first 100 values as burn in, plots of simulated values
and running ergodic means can be obtained as follows, see
Figure~\ref{fig:gibbsUKgas}.

<<>>=
burn <- 100
attach(outGibbs)
dV <- dV[-(1:burn)]
dW <- dW[-(1:burn), ]
detach()
par(mfrow=c(2,3), mar=c(3.1,2.1,2.1,1.1))
plot(dV, type = 'l', xlab = "", ylab = "", 
     main = expression(sigma^2))
plot(dW[ , 1], type = 'l', xlab = "", ylab = "", 
     main = expression(sigma[beta]^2))
plot(dW[ , 2], type = 'l', xlab = "", ylab = "", 
     main = expression(sigma[s]^2))
use <- length(dV) - burn
from <- 0.05 * use
at <- pretty(c(0, use), n = 3); at <- at[at >= from]
plot(ergMean(dV, from), type = 'l', xaxt = 'n',
     xlab = "", ylab = "")
axis(1, at = at - from, labels = format(at))
plot(ergMean(dW[ , 1], from), type = 'l', xaxt = 'n',
     xlab = "", ylab = "")
axis(1, at = at - from, labels = format(at))
plot(ergMean(dW[ , 2], from), type = 'l', xaxt = 'n',
     xlab = "", ylab = "")
axis(1, at =  at - from, labels = format(at))
@ 

Posterior estimates of the three unknown variances, from the Gibbs sampler
output, together with their Monte Carlo standard error, can be obtained using
the function \code{mcmcMean}.

<<>>=
mcmcMean(cbind(dV[-(1:burn)], dW[-(1:burn), ]))
@
<<echo = false, results = hide>>=
rm(dV, dW)
@ 

\section{Concluding remarks}
We have described and illustrated the main features of package \dlm{}.
Although the package has been developed with Bayesian MCMC-based applications
in mind, it can also be used for maximum likelihood estimation and Kalman
filtering/smoothing.  The main design objectives had been flexibility and
numerical stability of the filtering, smoothing, and likelihood evaluation
algorithms. These two goals are somewhat related, since naive implementations
of the Kalman filter are known to suffer from numerical instability for
general DLMs. Therefore, in an environment where the user is free to specify
virtually any type of DLM, it was important to try to avoid as much as
possible the aforementioned instability problems. The algorithms used in the
package are based on the sequential evaluation of variance matrices in terms
of their SVD. While this can be seen as a form of square root filter
(smoother), it is much more robust than the standard square root filter based
on the propagation of Cholesky decomposition. In fact, the SVD-based algorithm
does not even require the matrix $W$ to be invertible. (It does require $V$ to
be nonsingular, however).

As far as Bayesian inference is concerned, the package provides the tools to
easily implement a Gibbs sampler for any univariate or multivariate DLM. The
functions \code{dlmBSample} to generate the states and \code{arms}, the
multivariate estension of ARMS, can be used alone or in combination in a Gibbs
sampler, allowing the user to carry out Bayesian posterior inference for a
wide class of models and priors.


\clearpage
\begin{thebibliography}{9}
\bibitem[CK]{Carter+Kohn:1994} Carter, C.K. and Kohn, R. (1994). On Gibbs
  sampling for state space models. {\em Biometrika}, 81.
\bibitem[DK]{Durbin+Koopman:2001} Durbin, J. and Koopman, S.J. (2001). {\em
    Time Series analysis by state space methods}. Oxford University Press.
\bibitem[FS]{Fruewirth:1994} Fr\"uwirth-Schnatter, S. (1994). Data augmentation
  and dynamic linear models. {\em journal of Time Series Analysis}, 15.  
\bibitem[GBT]{Gilks+Best+Tan:1995} Gilks, W.R., Best, N.G. and Tan, K.K.C.
  (1995).  Adaptive rejection Metropolis sampling within Gibbs sampling (Corr:
  97V46 p541-542 with Neal, R.M.), \emph{Applied Statistics}, 44.
\bibitem[H]{Harvey:1989} Harvey, A.C. (1989). {\em Forecasting,
    Structural Time Series Models, and the Kalman Filter}.
  Cambridge University Press.
\bibitem[S]{Shephard:1994} Shephard, N. (1994). Partial non-Gaussian state
  space models. {\em Biometrika}, 81.
\bibitem[WH]{West+Harrison:1997} West, M. and Harrison, J. (1997). {\em
    Bayesian forecasting and dynamic models}.  (Second
  edition. First edition: 1989), Springer, N.Y.
\bibitem[ZL]{Zhang+Li:1996} Zhang, Y. and Li, R. (1996). Fixed-interval
  smoothing algorithm based on singular value decomposition. {\em  Proceedings
  of the 1996 IEEE international conference on control applications}. 
\end{thebibliography}

\end{document}

####$$$$ dlm\man/arms.Rd
\name{arms}
\alias{arms}
\title{Function to perform Adaptive Rejection Metropolis Sampling}
\description{
Generates a sequence of random variables using ARMS. For multivariate densities, 
ARMS is used along randomly selected straight lines through the current point.
}
\usage{
arms(y.start, myldens, indFunc, n.sample, ...)
}
\arguments{
  \item{y.start}{initial point}
  \item{myldens}{univariate or multivariate log target density}
  \item{indFunc}{indicator function of the convex support of the target density}
  \item{n.sample}{desired sample size}
  \item{...}{parameters passed to \code{myldens} and \code{indFunc}}
}
\details{
Strictly speaking, the support of the target density must be a bounded convex set. 
When this is not the case, the following tricks usually work.
If the support is not bounded, restrict it to a bounded set having probability 
practically one. 
A workaround, if the support is not convex, is to consider the convex set 
generated by the support 
and define \code{myldens} to return \code{log(.Machine$double.xmin)} outside
the true support (see the last example.)

The next point is generated along a randomly selected line through the current
point using arms.

Make sure the value returned by \code{myldens} is never smaller than
\code{log(.Machine$double.xmin)}, to avoid divisions by zero.
}
\value{
An \code{n.sample} by \code{length(y.start)} matrix, whose rows are the 
sampled points.
}
\references{
Gilks, W.R., Best, N.G. and Tan, K.K.C. (1995)
Adaptive rejection Metropolis sampling within Gibbs sampling
  (Corr: 97V46 p541-542 with Neal, R.M.), \emph{Applied Statistics}
  \bold{44}:455--472.
}

\author{Giovanni Petris \email{GPetris@uark.edu}}
\note{The function is based on original C code by W. Gilks for the 
univariate case, 
\url{http://www.mrc-bsu.cam.ac.uk/pub/methodology/adaptive_rejection/}.
}


\examples{
#### ==> Warning: running the examples may take a few minutes! <== ####    
\dontrun{
set.seed(4521222)
### Univariate densities
## Unif(-r,r) 
y <- arms(runif(1,-1,1), function(x,r) 1, function(x,r) (x>-r)*(x<r), 5000, r=2)
summary(y); hist(y,prob=TRUE,main="Unif(-r,r); r=2")
## Normal(mean,1)
norldens <- function(x,mean) -(x-mean)^2/2 
y <- arms(runif(1,3,17), norldens, function(x,mean) ((x-mean)>-7)*((x-mean)<7),
          5000, mean=10)
summary(y); hist(y,prob=TRUE,main="Gaussian(m,1); m=10")
curve(dnorm(x,mean=10),3,17,add=TRUE)
## Exponential(1)
y <- arms(5, function(x) -x, function(x) (x>0)*(x<70), 5000)
summary(y); hist(y,prob=TRUE,main="Exponential(1)")
curve(exp(-x),0,8,add=TRUE)
## Gamma(4.5,1) 
y <- arms(runif(1,1e-4,20), function(x) 3.5*log(x)-x,
          function(x) (x>1e-4)*(x<20), 5000)
summary(y); hist(y,prob=TRUE,main="Gamma(4.5,1)")
curve(dgamma(x,shape=4.5,scale=1),1e-4,20,add=TRUE)
## Gamma(0.5,1) (this one is not log-concave)
y <- arms(runif(1,1e-8,10), function(x) -0.5*log(x)-x,
          function(x) (x>1e-8)*(x<10), 5000)
summary(y); hist(y,prob=TRUE,main="Gamma(0.5,1)")
curve(dgamma(x,shape=0.5,scale=1),1e-8,10,add=TRUE)
## Beta(.2,.2) (this one neither)
y <- arms(runif(1), function(x) (0.2-1)*log(x)+(0.2-1)*log(1-x),
          function(x) (x>1e-5)*(x<1-1e-5), 5000)
summary(y); hist(y,prob=TRUE,main="Beta(0.2,0.2)")
curve(dbeta(x,0.2,0.2),1e-5,1-1e-5,add=TRUE)
## Triangular
y <- arms(runif(1,-1,1), function(x) log(1-abs(x)), function(x) abs(x)<1, 5000)     
summary(y); hist(y,prob=TRUE,ylim=c(0,1),main="Triangular")
curve(1-abs(x),-1,1,add=TRUE)
## Multimodal examples (Mixture of normals)
lmixnorm <- function(x,weights,means,sds) {
    log(crossprod(weights, exp(-0.5*((x-means)/sds)^2 - log(sds))))
}
y <- arms(0, lmixnorm, function(x,...) (x>(-100))*(x<100), 5000, weights=c(1,3,2),
          means=c(-10,0,10), sds=c(1.5,3,1.5))
summary(y); hist(y,prob=TRUE,main="Mixture of Normals")
curve(colSums(c(1,3,2)/6*dnorm(matrix(x,3,length(x),byrow=TRUE),c(-10,0,10),c(1.5,3,1.5))),
      par("usr")[1], par("usr")[2], add=TRUE)

### Bivariate densities 
## Bivariate standard normal
y <- arms(c(0,2), function(x) -crossprod(x)/2,
          function(x) (min(x)>-5)*(max(x)<5), 500)
plot(y, main="Bivariate standard normal", asp=1)
## Uniform in the unit square
y <- arms(c(0.2,.6), function(x) 1,
          function(x) (min(x)>0)*(max(x)<1), 500)
plot(y, main="Uniform in the unit square", asp=1)
polygon(c(0,1,1,0),c(0,0,1,1))
## Uniform in the circle of radius r
y <- arms(c(0.2,0), function(x,...) 1,
          function(x,r2) sum(x^2)<r2, 500, r2=2^2)
plot(y, main="Uniform in the circle of radius r; r=2", asp=1)
curve(-sqrt(4-x^2), -2, 2, add=TRUE)
curve(sqrt(4-x^2), -2, 2, add=TRUE)
## Uniform on the simplex
simp <- function(x) if ( any(x<0) || (sum(x)>1) ) 0 else 1
y <- arms(c(0.2,0.2), function(x) 1, simp, 500)
plot(y, xlim=c(0,1), ylim=c(0,1), main="Uniform in the simplex", asp=1)
polygon(c(0,1,0), c(0,0,1))
## A bimodal distribution (mixture of normals)
bimodal <- function(x) { log(prod(dnorm(x,mean=3))+prod(dnorm(x,mean=-3))) }
y <- arms(c(-2,2), bimodal, function(x) all(x>(-10))*all(x<(10)), 500)
plot(y, main="Mixture of bivariate Normals", asp=1)

## A bivariate distribution with non-convex support
support <- function(x) {
    return(as.numeric( -1 < x[2] && x[2] < 1 &&
                      -2 < x[1] &&
                      ( x[1] < 1 || crossprod(x-c(1,0)) < 1 ) ) )
}
Min.log <- log(.Machine$double.xmin) + 10
logf <- function(x) {
    if ( x[1] < 0 ) return(log(1/4))
    else
        if (crossprod(x-c(1,0)) < 1 ) return(log(1/pi))
    return(Min.log)
}
x <- as.matrix(expand.grid(seq(-2.2,2.2,length=40),seq(-1.1,1.1,length=40)))
y <- sapply(1:nrow(x), function(i) support(x[i,]))
plot(x,type='n',asp=1)
points(x[y==1,],pch=1,cex=1,col='green')
z <- arms(c(0,0), logf, support, 1000)
points(z,pch=20,cex=0.5,col='blue')
polygon(c(-2,0,0,-2),c(-1,-1,1,1))
curve(-sqrt(1-(x-1)^2),0,2,add=TRUE)
curve(sqrt(1-(x-1)^2),0,2,add=TRUE)
sum( z[,1] < 0 ) # sampled points in the square
sum( apply(t(z)-c(1,0),2,crossprod) < 1 ) # sampled points in the circle
}
}
\keyword{distribution}% at least one, from doc/KEYWORDS
\keyword{multivariate}% __ONLY ONE__ keyword per line
\keyword{misc}
####$$$$ dlm\man/ARtransPars.Rd
\name{ARtransPars}
\alias{ARtransPars}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{Function to parametrize a stationary AR process}
\description{%
  The function maps a vector of length p to the vector of autoregressive
  coefficients of a stationary AR(p) process. It can be used to
  parametrize a stationary AR(p) process 
}
\usage{
ARtransPars(raw)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{raw}{a vector of length p}
}
\details{
  The function first maps each element of \code{raw} to (0,1) using
  tanh. The numbers obtained are treated as the first partial
  autocorrelations of a stationary AR(p) process and the vector of the
  corresponding autoregressive coefficients is computed and returned.
}
\value{
  The vector of autoregressive coefficients of a stationary AR(p) process
  corresponding to the parameters in \code{raw}. 
}
\references{Jones, 1987. Randomly choosing parameters from the
  stationarity and invertibility region of autoregressive-moving average
  models. \emph{Applied Statistics}, 36.}
\author{Giovanni Petris, \email{GPetris@uark.edu}}

\examples{
(ar <- ARtransPars(rnorm(5)))
all( Mod(polyroot(c(1,-ar))) > 1 ) # TRUE
}

\keyword{misc}

####$$$$ dlm\man/bdiag.Rd
\name{bdiag}
\alias{bdiag}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{Build a block diagonal matrix}
\description{
  The function builds a block diagonal matrix. 
}
\usage{
bdiag(...)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{...}{individual matrices, or a list of matrices.}
}
\value{
  A matrix obtained by combining the arguments.
}
\author{Giovanni Petris \email{GPetris@uark.edu}}

\examples{
bdiag(matrix(1:4,2,2),diag(3))
bdiag(matrix(1:6,3,2),matrix(11:16,2,3))
}
\keyword{misc}% at least one, from doc/KEYWORDS

####$$$$ dlm\man/convex.bounds.Rd
\name{convex.bounds}
\alias{convex.bounds}
\title{Find the boundaries of a convex set}
\description{
Finds the boundaries of a bounded convex set along a specified 
straight line, using a bisection approach. It is mainly intended for 
use within \code{\link{arms}}.
}
\usage{
convex.bounds(x, dir, indFunc, ..., tol=1e-07)
}
\arguments{
  \item{x}{a point within the set}
  \item{dir}{a vector specifying a direction}
  \item{indFunc}{indicator function of the set}
  \item{...}{parameters passed to \code{indFunc}}
  \item{tol}{tolerance}
}
\details{
Uses a bisection algorithm along a line having parametric representation
\code{x + t * dir}.
}
\value{
A vector \code{ans} of length two. The boundaries of the set are
\code{x + ans[1] * dir} and \code{x + ans[2] * dir}.
}
\author{Giovanni Petris \email{GPetris@uark.edu}}

\examples{
## boundaries of a unit circle
convex.bounds(c(0,0), c(1,1), indFunc=function(x) crossprod(x)<1)
}

\keyword{misc}% at least one, from doc/KEYWORDS

####$$$$ dlm\man/dlm.Rd
\name{dlm}
\alias{dlm}
\alias{as.dlm}
\alias{is.dlm}
\title{dlm objects}
\description{
  The function \code{dlm} is used to create Dynamic Linear Model objects.
  \code{as.dlm} and \code{is.dlm} coerce an object to a Dynamic Linear
  Model object and test whether an object is a Dynamic Linear Model. 
}
\usage{
dlm(...)
as.dlm(obj)
is.dlm(obj)
}
\arguments{
  \item{...}{list with named elements \code{m0},
    \code{C0}, \code{FF}, \code{V}, \code{GG}, \code{W} and,
    optionally, 
    \code{JFF}, \code{JV}, \code{JGG}, \code{JW}, and
    \code{X}. The first six are the usual vector and matrices that define
    a time-invariant DLM. The remaining elements are used for time-varying
    DLM. \code{X}, if present, should be a matrix. If \code{JFF} is not
    \code{NULL}, then it must be a matrix of the 
    same dimension of \code{FF}, with the \eqn{(i,j)} element being zero if
    \code{FF[i,j]} is time-invariant, and a positive integer \eqn{k}
    otherwise. In this case the \eqn{(i,j)} element of \code{FF} at time
    \eqn{t} will be \code{X[t,k]}. A similar interpretation holds for
    \code{JV}, \code{JGG}, and \code{JW}. \code{...} may have additional
    components, that are not used by \code{dlm}. The named components
    may also be passed to the function as individual arguments.}     
  \item{obj}{an arbitrary \R object.}
}
\details{
  The function \code{dlm} is used to create Dynamic Linear Model
  objects. These are lists with the named elements described above and
  with class of \code{"dlm"}. 

  Class \code{"dlm"} has a number of methods. In particular, consistent
  DLM can be added together to produce another DLM.
}
\value{
  For \code{dlm}, an object of class \code{"dlm"}.}
\references{Giovanni Petris (2010), An R Package for Dynamic Linear
  Models. Journal of Statistical Software, 36(12), 1-16.
  \url{http://www.jstatsoft.org/v36/i12/}.\cr
  Petris, Petrone, and Campagnoli, Dynamic Linear Models with
  R, Springer (2009).\cr
  West and Harrison, Bayesian forecasting and
  dynamic models (2nd ed.), Springer (1997).
} 
\seealso{\code{\link{dlmModReg}}, \code{\link{dlmModPoly}},
  \code{\link{dlmModARMA}}, \code{\link{dlmModSeas}}, to create
  particular objects of class \code{"dlm"}.   
}
\examples{
## Linear regression as a DLM
x <- matrix(rnorm(10),nc=2)
mod <- dlmModReg(x)
is.dlm(mod)

## Adding dlm's
dlmModPoly() + dlmModSeas(4) # linear trend plus quarterly seasonal component
}
\author{Giovanni Petris \email{GPetris@uark.edu}}
\keyword{misc}
####$$$$ dlm\man/dlmBSample.Rd
\name{dlmBSample}
\alias{dlmBSample}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{Draw from the posterior distribution of the state vectors}
\description{
  The function simulates one draw from the posterior distribution
  of the state vectors. 
}
\usage{
dlmBSample(modFilt)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{modFilt}{%
    a list, typically the ouptut from \code{dlmFilter}, with elements
    \code{m}, \code{U.C}, \code{D.C}, \code{a}, \code{U.R}, \code{D.R} (see
    the value returned by \code{dlmFilter}), and \code{mod} The latter is an
    object of class \code{"dlm"} or a list with elements \code{GG}, \code{W}
    and, optionally, \code{JGG}, \code{JW}, and \code{X}}
}
\details{
  The calculations are based on singular value decomposition.
}
\value{
  The function returns a draw from the posterior distribution 
  of the state vectors. If \code{m} is a time series then the returned 
  value is a time series with the same \code{tsp}, otherwise it is 
  a matrix or vector.
}
\references{Giovanni Petris (2010), An R Package for Dynamic Linear
  Models. Journal of Statistical Software, 36(12), 1-16.
  \url{http://www.jstatsoft.org/v36/i12/}.\cr
  Petris, Petrone, and Campagnoli, Dynamic Linear Models with
  R, Springer (2009).\cr
  West and Harrison, Bayesian forecasting and
  dynamic models (2nd ed.), Springer (1997).
} 
\author{Giovanni Petris \email{GPetris@uark.edu}}

\seealso{See also \code{\link{dlmFilter}}}
\examples{
nileMod <- dlmModPoly(1, dV = 15099.8, dW = 1468.4)
nileFilt <- dlmFilter(Nile, nileMod)
nileSmooth <- dlmSmooth(nileFilt) # estimated "true" level
plot(cbind(Nile, nileSmooth$s[-1]), plot.type = "s",
     col = c("black", "red"), ylab = "Level",
     main = "Nile river", lwd = c(2, 2)) 
for (i in 1:10) # 10 simulated "true" levels 
    lines(dlmBSample(nileFilt[-1]), lty=2) 
}
\keyword{misc}% at least one, from doc/KEYWORDS

####$$$$ dlm\man/dlmFilter.Rd
\name{dlmFilter}
\alias{dlmFilter}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{DLM filtering}
\description{
  The functions applies Kalman filter to compute filtered
  values of the state vectors, together with their
  variance/covariance matrices. By default the function returns an object 
  of class \code{"dlmFiltered"}. Methods for \code{residuals} and \code{tsdiag} 
  for objects of class \code{"dlmFiltered"} exist.
}
\usage{
dlmFilter(y, mod, debug = FALSE, simplify = FALSE)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{y}{the data. \code{y} can be a vector, a matrix, a univariate or
    multivariate time series.}
  \item{mod}{an object of class \code{dlm}, or a list with components
    \code{m0}, \code{C0}, 
    \code{FF}, \code{V}, \code{GG}, \code{W}, and optionally \code{JFF},
    \code{JV}, \code{JGG}, \code{JW}, and \code{X}, defining the model
    and the parameters of the prior distribution.}
  \item{debug}{if \code{FALSE}, faster C code will be used, otherwise
    all the computations will be performed in R.}
  \item{simplify}{should the data be included in the output?}
}
\details{%
    The calculations are based on the singular value decomposition (SVD)
    of the relevant matrices. Variance matrices are returned in terms of
    their SVD.

    Missing values are allowed in \code{y}.
}
\value{%
  A list with the components described below. If \code{simplify} is 
  \code{FALSE}, the returned list has class \code{"dlmFiltered"}. 
  \item{y}{The input data, coerced to a matrix. This is present only if 
  \code{simplify} is \code{FALSE}.}
  \item{mod}{The argument \code{mod} (possibly simplified).}
  \item{m}{Time series (or matrix) of filtered values of the state vectors.
    The series starts one time unit before the first observation.}
  \item{U.C}{See below.}
  \item{D.C}{Together with \code{U.C}, it gives the SVD
    of the variances of the estimation errors.
    The variance of \eqn{m[t,]-theta[t,]}{m_t-\theta_t} is given by
    \code{U.C[[t]] \%*\% diag(D.C[t,]^2) \%*\% t(U.C[[t]])}.}
  \item{a}{Time series (or matrix) of predicted values of the state vectors
    given the observations up and including the previous time unit.}
  \item{U.R}{See below.}
  \item{D.R}{Together with \code{U.R}, it gives the SVD
    of the variances of the prediction errors.
    The variance of \eqn{a[t,]-theta[t,]}{a_t-\theta_t} is given by
    \code{U.R[[t]] \%*\% diag(D.R[t,]^2) \%*\% t(U.R[[t]])}.}
  \item{f}{Time series (or matrix) of one-step-ahead forecast of the
    observations.}
}
\section{Warning}{
  The observation variance \code{V} in \code{mod} must be nonsingular.
}
\references{Zhang, Y. and Li, X.R., Fixed-interval smoothing algorithm
  based on singular value decomposition, \emph{Proceedings of the 1996
    IEEE International Conference on Control Applications}.\cr
  Giovanni Petris (2010), An R Package for Dynamic Linear
  Models. Journal of Statistical Software, 36(12), 1-16.
  \url{http://www.jstatsoft.org/v36/i12/}.\cr
  Petris, Petrone, and Campagnoli, Dynamic Linear Models with R,
  Springer (2009).   
}
\author{Giovanni Petris \email{GPetris@uark.edu}}

\seealso{See \code{\link{dlm}} for a description of dlm objects,
  \code{\link{dlmSvd2var}} to obtain a variance matrix from its SVD,
  \code{\link{dlmMLE}} for maximum likelihood estimation, 
  \code{\link{dlmSmooth}} for Kalman smoothing, and
  \code{\link{dlmBSample}} for drawing from the posterior distribution
  of the state vectors.}

\examples{
nileBuild <- function(par) {
  dlmModPoly(1, dV = exp(par[1]), dW = exp(par[2]))
}
nileMLE <- dlmMLE(Nile, rep(0,2), nileBuild); nileMLE$conv
nileMod <- nileBuild(nileMLE$par)
V(nileMod)
W(nileMod)
nileFilt <- dlmFilter(Nile, nileMod)
nileSmooth <- dlmSmooth(nileFilt)
plot(cbind(Nile, nileFilt$m[-1], nileSmooth$s[-1]), plot.type='s',
     col=c("black","red","blue"), ylab="Level", main="Nile river", lwd=c(1,2,2))
}

\keyword{ts}
\keyword{misc}
####$$$$ dlm\man/dlmForecast.Rd
\name{dlmForecast}
\alias{dlmForecast}
\title{Prediction and simulation of future observations}
\description{
  The function evaluates the expected value and variance of future
  observations and system states. It can also generate a sample from the
  distribution of future observations and system states.
}
\usage{
  dlmForecast(mod, nAhead = 1, method = c("plain", "svd"), sampleNew = FALSE)
}
\arguments{
  \item{mod}{an object of class \code{"dlm"}, or a list with components
    \code{m0}, \code{C0},
    \code{FF}, \code{V}, \code{GG}, and \code{W}, defining the model
    and the parameters of the prior distribution. \code{mod} can also be
    an object of class \code{"dlmFiltered"}, such as the output from
    \code{dlmFilter}.}
  \item{nAhead}{number of steps ahead for which a forecast is
    requested.}
  \item{method}{\code{method="svd"} uses singular value decomposition
    for the calculations. Currently, only \code{method="plain"}
    is implemented.}
  \item{sampleNew}{if \code{sampleNew=n} for an integer \code{n}, them a
    sample of size \code{n} from the forecast distribution of states and
    observables will be returned.}
}
\value{
  A list with components
  \tabular{ll}{
    \code{a}\tab matrix of expected values of future states\cr
    \code{R}\tab list of variances of future states\cr
    \code{f}\tab matrix of expected values of future observations\cr
    \code{Q}\tab list of variances of future observations\cr
    \code{newStates}\tab list of matrices containing the simulated
    future values\cr
      \tab of the states. Each component of the list corresponds\cr
      \tab to one simulation.\cr
    \code{newObs}\tab same as \code{newStates}, but for the observations.
  }
The last two components are not present if \code{sampleNew=FALSE}.
}
\note{
  The function is currently entirely written in \R and is not
  particularly fast. Currently, only constant models are allowed. 
}
\examples{
## Comparing theoretical prediction intervals with sample quantiles
set.seed(353)
n <- 20; m <- 1; p <- 5
mod <- dlmModPoly() + dlmModSeas(4, dV=0)
W(mod) <- rwishart(2*p,p) * 1e-1
m0(mod) <- rnorm(p, sd=5)
C0(mod) <- diag(p) * 1e-1
new <- 100
fore <- dlmForecast(mod, nAhead=n, sampleNew=new)
ciTheory <- (outer(sapply(fore$Q, FUN=function(x) sqrt(diag(x))), qnorm(c(0.1,0.9))) +
             as.vector(t(fore$f)))
ciSample <- t(apply(array(unlist(fore$newObs), dim=c(n,m,new))[,1,], 1,
                    FUN=function(x) quantile(x, c(0.1,0.9))))
plot.ts(cbind(ciTheory,fore$f[,1]),plot.type="s", col=c("red","red","green"),ylab="y")
for (j in 1:2) lines(ciSample[,j], col="blue")
legend(2,-40,legend=c("forecast mean", "theoretical bounds", "Monte Carlo bounds"),
       col=c("green","red","blue"), lty=1, bty="n")
}
\author{Giovanni Petris \email{GPetris@uark.edu}}
\keyword{misc}
####$$$$ dlm\man/dlmGibbsDIG.Rd
\name{dlmGibbsDIG}
\alias{dlmGibbsDIG}
\title{Gibbs sampling for d-inverse-gamma model}
\description{
  The function implements a Gibbs sampler for a univariate DLM
  having one or more unknown variances in its specification.
}
\usage{
dlmGibbsDIG(y, mod, a.y, b.y, a.theta, b.theta, shape.y, rate.y,
            shape.theta, rate.theta, n.sample = 1,
            thin = 0, ind, save.states = TRUE,
            progressBar = interactive())
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{y}{data vector or univariate time series}
  \item{mod}{a dlm for univariate observations}
  \item{a.y}{prior mean of observation precision}
  \item{b.y}{prior variance of observation precision}
  \item{a.theta}{prior mean of system precisions (recycled, if needed)}
  \item{b.theta}{prior variance of system precisions (recycled, if needed)}
  \item{shape.y}{shape parameter of the prior of observation precision}
  \item{rate.y}{rate parameter of the prior of observation precision}
  \item{shape.theta}{shape parameter of the prior of system precisions (recycled, if needed)}
  \item{rate.theta}{rate parameter of the prior of system precisions (recycled, if needed)}
  \item{n.sample}{requested number of Gibbs iterations}
  \item{thin}{discard \code{thin} iterations for every saved iteration}
  \item{ind}{indicator of the system variances that need to be estimated}
  \item{save.states}{should the simulated states be included in the output?}
  \item{progressBar}{should a text progress bar be displayed during execution?}
}
\details{
  The \emph{d-inverse-gamma} model is a constant univariate DLM with unknown
  observation variance, diagonal system variance with unknown diagonal
  entries.  Some of these entries may be known, in which case they are
  typically zero.  Independent inverse gamma priors are assumed for the
  unknown variances.  These can be specified be mean and variance or,
  alternatively, by shape and rate.  Recycling is applied for the prior
  parameters of unknown system variances.  The argument \code{ind} can
  be used to specify the index of the unknown system variances, in case
  some of the diagonal elements of \code{W} are known.  The unobservable
  states are generated in the Gibbs sampler and are returned if
  \code{save.states = TRUE}.  For more details on the model and usage
  examples, see the package vignette. 
}
\value{
  The function returns a list of simulated values.
  \item{dV}{simulated values of the observation variance.}
  \item{dW}{simulated values of the unknown diagonal elements of the
    system variance.}
  \item{theta}{simulated values of the state vectors.}
}
\references{Giovanni Petris (2010), An R Package for Dynamic Linear
  Models. Journal of Statistical Software, 36(12), 1-16.
  \url{http://www.jstatsoft.org/v36/i12/}.\cr
  Petris, Petrone, and Campagnoli, Dynamic Linear Models with
  R, Springer (2009).
}

\author{Giovanni Petris \email{GPetris@uark.edu}}

\examples{
## See the package vignette for an example
}

\keyword{misc}

####$$$$ dlm\man/dlmLL.Rd
\name{dlmLL}
\alias{dlmLL}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{Log likelihood evaluation for a state space model}
\description{
	Function that computes the log likelihood of a state space model. 
}
\usage{
dlmLL(y, mod, debug=FALSE)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{y}{a vector, matrix, or time series of data.}
  \item{mod}{an object of class \code{"dlm"}, or a list with components
    \code{m0}, \code{C0}, 
    \code{FF}, \code{V}, \code{GG}, \code{W} defining the model
    and the parameters of the prior distribution.} 
  \item{debug}{if \code{debug=TRUE}, the function uses R code, otherwise
    it uses faster C code.}
}
\details{
  The calculations are based on singular value decomposition.
  Missing values are allowed in \code{y}.
}
\value{
  The function returns the negative of the loglikelihood.
}
\section{Warning}{
  The observation variance \code{V} in \code{mod} must be nonsingular.
}
\references{Durbin and Koopman, Time series analysis by state space
  methods, Oxford University Press, 2001.}
\author{Giovanni Petris \email{GPetris@uark.edu}}


\seealso{\code{\link{dlmMLE}}, \code{\link{dlmFilter}} for the definition of 
  the equations of the model.}
\examples{
##---- See the examples for dlmMLE ----
}
\keyword{misc}% at least one, from doc/KEYWORDS

####$$$$ dlm\man/dlmMLE.Rd
\name{dlmMLE}
\alias{dlmMLE}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{Parameter estimation by maximum likelihood}
\description{
  The function returns the MLE of unknown parameters in the specification of 
  a state space model. 
}
\usage{
dlmMLE(y, parm, build, method = "L-BFGS-B", ..., debug = FALSE) 
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{y}{a vector, matrix, or time series of data.}
  \item{parm}{vector of initial values - for the optimization routine -
    of the unknown parameters.} 
  \item{build}{a function that takes a vector of the same length as
    \code{parm} and returns an object of class dlm, or a list that may
    be interpreted as such.}
  \item{method}{passed to \code{optim}.}
  \item{...}{additional arguments passed to \code{optim} and
    \code{build}.}
  \item{debug}{if \code{debug=TRUE}, the likelihood calculations are done
    entirely in R, otherwise C functions are used.}
}
\details{
  The evaluation of the loglikelihood is done by \code{dlmLL}. 
  For the optimization, \code{optim} is called. It is possible for the
  model to depend on additional parameters, other than those in
  \code{parm}, passed to \code{build} via the \code{...} argument.
}
\value{
  The function \code{dlmMLE} returns the value returned by \code{optim}.
}
\references{Giovanni Petris (2010), An R Package for Dynamic Linear
  Models. Journal of Statistical Software, 36(12), 1-16.
  \url{http://www.jstatsoft.org/v36/i12/}.\cr
  Petris, Petrone, and Campagnoli, Dynamic Linear Models with
  R, Springer (2009).
}
\section{Warning}{
  The \code{build} argument must return a dlm with nonsingular
  observation variance \code{V}.
}
\author{Giovanni Petris \email{GPetris@uark.edu}}

\seealso{
  \code{\link{dlmLL}}, \code{\link{dlm}}.
}
  
\examples{
data(NelPlo)
### multivariate local level -- seemingly unrelated time series
buildSu <- function(x) {
  Vsd <- exp(x[1:2])
  Vcorr <- tanh(x[3])
  V <- Vsd \%o\% Vsd
  V[1,2] <- V[2,1] <- V[1,2] * Vcorr
  Wsd <- exp(x[4:5])
  Wcorr <- tanh(x[6])
  W <- Wsd \%o\% Wsd
  W[1,2] <- W[2,1] <- W[1,2] * Wcorr
  return(list(
              m0 = rep(0,2),
              C0 = 1e7 * diag(2),
              FF = diag(2),
              GG = diag(2),
              V = V,
              W = W))
}

suMLE <- dlmMLE(NelPlo, rep(0,6), buildSu); suMLE
buildSu(suMLE$par)[c("V","W")]
StructTS(NelPlo[,1], type="level") ## compare with W[1,1] and V[1,1]
StructTS(NelPlo[,2], type="level") ## compare with W[2,2] and V[2,2]

## multivariate local level model with homogeneity restriction
buildHo <- function(x) {
  Vsd <- exp(x[1:2])
  Vcorr <- tanh(x[3])
  V <- Vsd \%o\% Vsd
  V[1,2] <- V[2,1] <- V[1,2] * Vcorr
  return(list(
              m0 = rep(0,2),
              C0 = 1e7 * diag(2),
              FF = diag(2),
              GG = diag(2),
              V = V,
              W = x[4]^2 * V))
}

hoMLE <- dlmMLE(NelPlo, rep(0,4), buildHo); hoMLE
buildHo(hoMLE$par)[c("V","W")]
}
\keyword{misc}% at least one, from doc/KEYWORDS

####$$$$ dlm\man/dlmModARMA.Rd
\name{dlmModARMA}
\alias{dlmModARMA}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{Create a DLM representation of an ARMA process}
\description{
  The function creates an object of class dlm representing a specified
  univariate or multivariate ARMA process
}
\usage{
dlmModARMA(ar = NULL, ma = NULL, sigma2 = 1, dV, m0, C0)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{ar}{a vector or a list of matrices (in the multivariate case)
    containing the autoregressive coefficients.}
  \item{ma}{a vector or a list of matrices (in the multivariate case)
    containing the moving average coefficients.}
  \item{sigma2}{the variance (or variance matrix) of the innovations.}
  \item{dV}{the variance, or the diagonal elements of the variance
    matrix in the multivariate case, of the observation noise. \code{V}
    is assumed to be diagonal and it defaults to zero.}
  \item{m0}{\eqn{m_0}{m0}, the expected value of the pre-sample state vector.}
  \item{C0}{\eqn{C_0}{C0}, the variance matrix of the pre-sample state vector.}
}
\details{
  The returned DLM only gives one of the many possible representations
  of an ARMA process. 
%  What is the name of this representation???
}
\value{
  The function returns an object of class dlm representing the ARMA
  model specified by \code{ar}, \code{ma}, and \code{sigma2}.
}
\references{Giovanni Petris (2010), An R Package for Dynamic Linear
  Models. Journal of Statistical Software, 36(12), 1-16.
  \url{http://www.jstatsoft.org/v36/i12/}.\cr
  Petris, Petrone, and Campagnoli, Dynamic Linear Models with
  R, Springer (2009).\cr
  Durbin and Koopman, Time series analysis by state space 
  methods, Oxford University Press, 2001.
}

\author{Giovanni Petris \email{GPetris@uark.edu}}

\seealso{\code{\link{dlmModPoly}}, \code{\link{dlmModSeas}},
  \code{\link{dlmModReg}}}
\examples{
## ARMA(2,3)
dlmModARMA(ar = c(.5,.1), ma = c(.4,2,.3), sigma2=1)
## Bivariate ARMA(2,1)
dlmModARMA(ar = list(matrix(1:4,2,2), matrix(101:104,2,2)),
           ma = list(matrix(-4:-1,2,2)), sigma2 = diag(2))
}
\keyword{misc}% at least one, from doc/KEYWORDS

####$$$$ dlm\man/dlmModPoly.Rd
\name{dlmModPoly}
\alias{dlmModPoly}
\title{Create an n-th order polynomial DLM}
\description{
  The function creates an \eqn{n}{n-}th order polynomial DLM.
}
\usage{
dlmModPoly(order = 2, dV = 1, dW = c(rep(0, order - 1), 1),
           m0 = rep(0, order), C0 = 1e+07 * diag(nrow = order)) 
}
\arguments{
  \item{order}{order of the polynomial model. The default
    corresponds to a stochastic linear trend.}
  \item{dV}{variance of the observation noise.}
  \item{dW}{diagonal elements of the variance matrix of the system noise.}
  \item{m0}{\eqn{m_0}{m0}, the expected value of the pre-sample state vector.}
  \item{C0}{\eqn{C_0}{C0}, the variance matrix of the pre-sample state vector.}
}
  
\value{
  An object of class dlm representing the required n-th order
  polynomial model.
}
\references{Giovanni Petris (2010), An R Package for Dynamic Linear
  Models. Journal of Statistical Software, 36(12), 1-16.
  \url{http://www.jstatsoft.org/v36/i12/}.\cr
  Petris, Petrone, and Campagnoli, Dynamic Linear Models with
  R, Springer (2009).\cr
  West and Harrison, Bayesian forecasting and dynamic models
  (2nd ed.), Springer, 1997.}
\author{Giovanni Petris \email{GPetris@uark.edu}}

\seealso{\code{\link{dlmModARMA}}, \code{\link{dlmModReg}},
  \code{\link{dlmModSeas}}}
\examples{
## the default
dlmModPoly()
## random walk plus noise
dlmModPoly(1, dV = .3, dW = .01)
}
\keyword{misc}% at least one, from doc/KEYWORDS
####$$$$ dlm\man/dlmModReg.Rd
\name{dlmModReg}
\alias{dlmModReg}
\title{Create a DLM representation of a regression model}
\description{
  The function creates a dlm representation of a linear regression
  model. 
}
\usage{
dlmModReg(X, addInt = TRUE, dV = 1, dW = rep(0, NCOL(X) + addInt),
          m0 = rep(0, length(dW)),
          C0 = 1e+07 * diag(nrow = length(dW)))
}
\arguments{
  \item{X}{the design matrix}
  \item{addInt}{logical: should an intercept be added?}
  \item{dV}{variance of the observation noise.}
  \item{dW}{diagonal elements of the variance matrix of the system noise.}
  \item{m0}{\eqn{m_0}{m0}, the expected value of the pre-sample state vector.}
  \item{C0}{\eqn{C_0}{C0}, the variance matrix of the pre-sample state vector.}
}
\details{
  By setting \code{dW} equal to a nonzero vector one obtains a DLM
  representation of a dynamic regression model. The default value zero
  of \code{dW} corresponds to standard linear regression. Only
  univariate regression is currently covered. 
}
\value{
  An object of class dlm representing the specified regression model.
}
\references{Giovanni Petris (2010), An R Package for Dynamic Linear
  Models. Journal of Statistical Software, 36(12), 1-16.
  \url{http://www.jstatsoft.org/v36/i12/}.\cr
  Petris, Petrone, and Campagnoli, Dynamic Linear Models with
  R, Springer (2009).\cr
  West and Harrison, Bayesian forecasting and dynamic models
  (2nd ed.), Springer, 1997.}

\author{Giovanni Petris \email{GPetris@uark.edu}}

\seealso{\code{\link{dlmModARMA}}, \code{\link{dlmModPoly}},
  \code{\link{dlmModSeas}}}
\examples{
x <- matrix(runif(6,4,10), nc = 2); x
dlmModReg(x)
dlmModReg(x, addInt = FALSE)
}
\keyword{misc}% at least one, from doc/KEYWORDS

####$$$$ dlm\man/dlmModSeas.Rd
\name{dlmModSeas}
\alias{dlmModSeas}
\title{Create a DLM for seasonal factors}
\description{
  The function creates a DLM representation of seasonal component. 
}
\usage{
dlmModSeas(frequency, dV = 1, dW = c(1, rep(0, frequency - 2)),
           m0 = rep(0, frequency - 1),
           C0 = 1e+07 * diag(nrow = frequency - 1)) 
}
\arguments{
  \item{frequency}{how many seasons?}
  \item{dV}{variance of the observation noise.}
  \item{dW}{diagonal elements of the variance matrix of the system noise.}
  \item{m0}{\eqn{m_0}{m0}, the expected value of the pre-sample state vector.}
  \item{C0}{\eqn{C_0}{C0}, the variance matrix of the pre-sample state vector.}
}
\value{
  An object of class dlm representing a seasonal factor for a process
  with \code{frequency} seasons.
}
\references{Giovanni Petris (2010), An R Package for Dynamic Linear
  Models. Journal of Statistical Software, 36(12), 1-16.
  \url{http://www.jstatsoft.org/v36/i12/}.\cr
  Petris, Petrone, and Campagnoli, Dynamic Linear Models with
  R, Springer (2009).\cr
  Harvey, Forecasting, structural time series models and the
  Kalman filter, Cambridge University Press, 1989.}

\author{Giovanni Petris \email{GPetris@uark.edu}}

\seealso{\code{\link{dlmModARMA}}, \code{\link{dlmModPoly}},
  \code{\link{dlmModReg}}, and \code{\link{dlmModTrig}} for the Fourier
  representation of a seasonal component.}
\examples{
## seasonal component for quarterly data
dlmModSeas(4, dV = 3.2)
}
\keyword{misc}% at least one, from doc/KEYWORDS

####$$$$ dlm\man/dlmModTrig.Rd
\name{dlmModTrig}
\alias{dlmModTrig}
\title{Create Fourier representation of a periodic DLM component}
\description{
  The function creates a dlm representing a specified periodic
  component. 
}
\usage{
dlmModTrig(s, q, om, tau, dV = 1, dW = 0, m0, C0)
}
\arguments{
  \item{s}{the period, if integer.}
  \item{q}{number of harmonics in the DLM.}
  \item{om}{the frequency.}
  \item{tau}{the period, if not an integer.}
  \item{dV}{variance of the observation noise.}
  \item{dW}{a single number expressing the variance of the system noise.}
  \item{m0}{\eqn{m_0}{m0}, the expected value of the pre-sample state vector.}
  \item{C0}{\eqn{C_0}{C0}, the variance matrix of the pre-sample state vector.}
}
\details{
  The periodic component is specified by one and only one of \code{s},
  \code{om}, and \code{tau}. When \code{s} is given, the function
  assumes that the period is an integer, while a period specified by
  \code{tau} is assumed to be noninteger. Instead of \code{tau},
  the frequency \code{om} can be specified. The argument \code{q}
  specifies the number of harmonics to include in the model. When
  \code{tau} or \code{omega} is given, then \code{q} is required as
  well, since in this case the implied Fourier representation has
  infinitely many harmonics. On the other hand, if \code{s} is given,
  \code{q} defaults to all the harmonics in the Fourier representation,
  that is \code{floor(s/2)}.

  The system variance of the resulting dlm is \code{dW} times the identity
  matrix of the appropriate dimension. 
}
\value{
  An object of class dlm, representing a periodic component.
}
\references{Giovanni Petris (2010), An R Package for Dynamic Linear
  Models. Journal of Statistical Software, 36(12), 1-16.
  \url{http://www.jstatsoft.org/v36/i12/}.\cr
  Petris, Petrone, and Campagnoli, Dynamic Linear Models with
  R, Springer (2009).\cr
  West and Harrison, Bayesian forecasting and
  dynamic models (2nd ed.), Springer (1997).
}

\author{Giovanni Petris \email{GPetris@uark.edu}}

\seealso{\code{\link{dlmModSeas}}, \code{\link{dlmModARMA}},
  \code{\link{dlmModPoly}}, \code{\link{dlmModReg}}} 
\examples{
dlmModTrig(s = 3)
dlmModTrig(tau = 3, q = 1) # same thing
dlmModTrig(s = 4) # for quarterly data
dlmModTrig(s = 4, q = 1)
dlmModTrig(tau = 4, q = 2) # a bad idea!
m1 <- dlmModTrig(tau = 6.3, q = 2); m1
m2 <- dlmModTrig(om = 2 * pi / 6.3, q = 2)
all.equal(unlist(m1), unlist(m2))
}
\keyword{misc}% at least one, from doc/KEYWORDS

####$$$$ dlm\man/dlmRandom.Rd
\name{dlmRandom}
\alias{dlmRandom}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{Random DLM}
\description{
  Generate a random (constant or time-varying) object of class
  \code{"dlm"}, along with states and observations from it.
}
\usage{
dlmRandom(m, p, nobs = 0, JFF, JV, JGG, JW)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{m}{dimension of the observation vector.}
  \item{p}{dimension of the state vector.}
  \item{nobs}{number of states and observations to simulate from the model.}
  \item{JFF}{should the model have a time-varying \code{FF} component?}
  \item{JV}{should the model have a time-varying \code{V} component?}
  \item{JGG}{should the model have a time-varying \code{GG} component?}
  \item{JW}{should the model have a time-varying \code{W} component?}
}
\details{
  The function generates randomly the system and observation matrices and
  the variances of a DLM having the specified state and observation
  dimension. The system matrix \code{GG} is guaranteed to have
  eigenvalues strictly less than one, which implies that a constant DLM is
  asymptotically stationary. The default behavior is to generate a
  constant DLM. If \code{JFF} is \code{TRUE} then a model for
  \code{nobs} observations in which all
  the elements of \code{FF} are time-varying is generated. Similarly
  with \code{JV}, \code{JGG}, and \code{JW}.
}
\value{
  The function returns a list with the following components.
  \item{mod}{An object of class \code{"dlm"}.}
  \item{theta}{Matrix of simulated state vectors from the model.}
  \item{y}{Matrix of simulated observations from the model.}
  If \code{nobs} is zero, only the \code{mod} component is returned.
}
\references{Anderson and Moore, Optimal filtering, Prentice-Hall (1979)}
\author{Giovanni Petris \email{GPetris@uark.edu}}
\seealso{\code{\link{dlm}}}
\examples{
dlmRandom(1, 3, 5)
}
\keyword{misc}% at least one, from doc/KEYWORDS
\keyword{datagen}% __ONLY ONE__ keyword per line
####$$$$ dlm\man/dlmSmooth.Rd
\name{dlmSmooth}
\alias{dlmSmooth}
\alias{dlmSmooth.dlmFiltered}
\alias{dlmSmooth.default}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{DLM smoothing}
\description{
  The function apply Kalman smoother to compute 
  smoothed values of the state vectors, together with their
  variance/covariance matrices. 
}
\usage{
dlmSmooth(y, \dots)
\method{dlmSmooth}{default}(y, mod, \dots)
\method{dlmSmooth}{dlmFiltered}(y, \dots, debug = FALSE)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{y}{an object used to select a method.}
  \item{\dots}{futher arguments passed to or from other methods.}
  \item{mod}{an object of class \code{"dlm"}.}
  \item{debug}{if \code{debug=FALSE}, faster C code will be used, otherwise
    all the computations will be performed in R.}
}
\details{%
  The default method returns means and variances of the smoothing
  distribution for a data vector (or matrix) \code{y} and a model
  \code{mod}.

  \code{dlmSmooth.dlmFiltered} produces the same output based on a
  \code{dlmFiltered} object, typically one produced by a call to
  \code{dlmFilter}. 

  The calculations are based on the singular value decomposition (SVD)
  of the relevant matrices. Variance matrices are returned in terms of
  their SVD.
}
\value{%
  A list with components
  \item{s}{Time series (or matrix) of smoothed values of the state
    vectors. The series starts one time unit before the first observation.} 
  \item{U.S}{See below.}
  \item{D.S}{Together with \code{U.S}, it gives the SVD of the variances
    of the smoothing errors.}
}
\section{Warning}{
  The observation variance \code{V} in \code{mod} must be nonsingular.
}
\references{Zhang, Y. and Li, X.R., Fixed-interval smoothing algorithm
  based on singular value decomposition, \emph{Proceedings of the 1996
    IEEE International Conference on Control Applications}.\cr
  Giovanni Petris (2010), An R Package for Dynamic Linear
  Models. Journal of Statistical Software, 36(12), 1-16.
  \url{http://www.jstatsoft.org/v36/i12/}.\cr
  Petris, Petrone, and Campagnoli, Dynamic Linear Models with
  R, Springer (2009).
}

\author{Giovanni Petris \email{GPetris@uark.edu}}

\seealso{See \code{\link{dlm}} for a description of dlm objects,
  \code{\link{dlmSvd2var}} to obtain a variance matrix from its SVD,
  \code{\link{dlmFilter}} for Kalman filtering, 
  \code{\link{dlmMLE}} for maximum likelihood estimation, and
  \code{\link{dlmBSample}} for drawing from the posterior distribution
  of the state vectors.} 

\examples{%
s <- dlmSmooth(Nile, dlmModPoly(1, dV = 15100, dW = 1470))
plot(Nile, type ='o')
lines(dropFirst(s$s), col = "red")

## Multivariate
set.seed(2)
tmp <- dlmRandom(3, 5, 20)
obs <- tmp$y
m <- tmp$mod
rm(tmp)

f <- dlmFilter(obs, m)
s <- dlmSmooth(f)
all.equal(s, dlmSmooth(obs, m))
}

\keyword{ts}
\keyword{smooth}
\keyword{misc}
####$$$$ dlm\man/dlmSum.Rd
\name{dlmSum}
\alias{dlmSum}
\alias{\%+\%}
\title{Outer sum of Dynamic Linear Models}
\description{
  \code{dlmSum} creates a unique DLM out of two or more
  independent DLMs. \code{\%+\%} is an alias for \code{dlmSum}.
}
\usage{
dlmSum(...)
x \%+\% y
}

\arguments{
  \item{\dots}{any number of objects of class \code{dlm}, or a list of
    such objects.}
  \item{x, y}{objects of class \code{dlm}.}
}
\value{
  An object of class \code{dlm}, representing the outer sum of the
  arguments.
}
\references{Giovanni Petris (2010), An R Package for Dynamic Linear
  Models. Journal of Statistical Software, 36(12), 1-16.
  \url{http://www.jstatsoft.org/v36/i12/}.\cr
  Petris, Petrone, and Campagnoli, Dynamic Linear Models with
  R, Springer (2009).
}
\author{Giovanni Petris \email{GPetris@uark.edu}}

\examples{
m1 <- dlmModPoly(2)
m2 <- dlmModPoly(1)
dlmSum(m1, m2)
m1 \%+\% m2 # same thing
}

\keyword{ts}
\keyword{misc}
####$$$$ dlm\man/dlmSvd2var.Rd
\name{dlmSvd2var}
\alias{dlmSvd2var}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{Compute a nonnegative definite matrix from its
  Singular Value Decomposition} 
\description{
  The function computes a nonnegative definite matrix from its Singular
  Value Decomposition. 
}
\usage{
dlmSvd2var(u, d)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{u}{a square matrix, or a list of square matrices for a
    vectorized usage.}
  \item{d}{a vector, or a matrix for a vectorized usage.}
}
\details{
  The SVD of a nonnegative definite \eqn{n} by \eqn{n} square matrix
  \eqn{x} can be written as \eqn{u d^2 u'}, where \eqn{u} is an \eqn{n}
  by \eqn{n} orthogonal matrix and \eqn{d} is a diagonal matrix. For a
  single matrix, the function returns just \eqn{u d^2 u'}. Note that the
  argument \code{d} is a vector containing the diagonal elements of
  \eqn{d}. For a vectorized usage, \code{u} is a list of square
  matrices, and \code{d} is a matrix. The returned value in this case is
  a list of matrices, with the element \eqn{i} being \code{u[[i]] \%*\%
    diag(d[i,]^2) \%*\% t(u[[i]])}. 
}
\value{
  The function returns a nonnegative definite matrix, reconstructed from
  its SVD, or a list of such matrices (see details above).
}
\references{Horn and Johnson, Matrix analysis, Cambridge University
  Press (1985)}
\author{Giovanni Petris \email{GPetris@uark.edu}}

\examples{
x <- matrix(rnorm(16),4,4)
x <- crossprod(x)
tmp <- La.svd(x)
all.equal(dlmSvd2var(tmp$u, sqrt(tmp$d)), x)
## Vectorized usage
x <- dlmFilter(Nile, dlmModPoly(1, dV=15099, dW=1469))
x$se <- sqrt(unlist(dlmSvd2var(x$U.C, x$D.C)))
## Level with 50\% probability interval
plot(Nile, lty=2)
lines(dropFirst(x$m), col="blue")
lines(dropFirst(x$m - .67*x$se), lty=3, col="blue")
lines(dropFirst(x$m + .67*x$se), lty=3, col="blue")
}
\keyword{array}% at least one, from doc/KEYWORDS
\keyword{misc}% __ONLY ONE__ keyword per line
####$$$$ dlm\man/dropFirst.Rd
\name{dropFirst}
\alias{dropFirst}
\title{Drop the first element of a vector or matrix}
\description{
  A utility function, \code{dropFirst} drops the first element of a
  vector or matrix, retaining the correct time series attributes, in
  case the argument is a time series object. 
}
\usage{
dropFirst(x)
}
\arguments{
  \item{x}{a vector or matrix.}
}
\value{
  The function returns \code{x[-1]} or \code{x[-1,]}, if the argument is
  a matrix. For an argument of class \code{ts} the class is preserved,
  together with the correct \code{tsp} attribute.
}
\author{Giovanni Petris \email{GPetris@uark.edu}}

\examples{
(pres <- dropFirst(presidents))
start(presidents)
start(pres)
}


\keyword{misc}
\keyword{ts}
####$$$$ dlm\man/FF.Rd
\name{FF}
\alias{FF}
\alias{FF<-}
\alias{V}
\alias{V<-}
\alias{GG}
\alias{GG<-}
\alias{W}
\alias{W<-}
\alias{m0}
\alias{m0<-}
\alias{C0}
\alias{C0<-}
\alias{FF.dlm}
\alias{FF<-.dlm}
\alias{V.dlm}
\alias{V<-.dlm}
\alias{GG.dlm}
\alias{GG<-.dlm}
\alias{W.dlm}
\alias{W<-.dlm}
\alias{m0.dlm}
\alias{m0<-.dlm}
\alias{C0.dlm}
\alias{C0<-.dlm}
\alias{JFF}
\alias{JFF<-}
\alias{JV}
\alias{JV<-}
\alias{JGG}
\alias{JGG<-}
\alias{JW}
\alias{JW<-}
\alias{X}
\alias{X<-}
\alias{JFF.dlm}
\alias{JFF<-.dlm}
\alias{JV.dlm}
\alias{JV<-.dlm}
\alias{JGG.dlm}
\alias{JGG<-.dlm}
\alias{JW.dlm}
\alias{JW<-.dlm}
\alias{X.dlm}
\alias{X<-.dlm}


\title{Components of a dlm object}
\description{
  Functions to get or set specific components of an object of class \code{dlm}
}
\usage{
\method{FF}{dlm}(x)
\method{FF}{dlm}(x) <- value
\method{V}{dlm}(x)
\method{V}{dlm}(x) <- value
\method{GG}{dlm}(x)
\method{GG}{dlm}(x) <- value
\method{W}{dlm}(x)
\method{W}{dlm}(x) <- value
\method{m0}{dlm}(x)
\method{m0}{dlm}(x) <- value
\method{C0}{dlm}(x)
\method{C0}{dlm}(x) <- value
\method{JFF}{dlm}(x)
\method{JFF}{dlm}(x) <- value
\method{JV}{dlm}(x)
\method{JV}{dlm}(x) <- value
\method{JGG}{dlm}(x)
\method{JGG}{dlm}(x) <- value
\method{JW}{dlm}(x)
\method{JW}{dlm}(x) <- value
\method{X}{dlm}(x)
\method{X}{dlm}(x) <- value
}

%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{x}{an object of class \code{dlm}.}
  \item{value}{a numeric matrix (or vector for \code{m0}).} 
}
\details{
  Missing or infinite values are not allowed in \code{value}. The dimension of
  \code{value} must match the dimension of the current value of the
  specific component in \code{x}
}
\value{
  For the assignment forms, the updated \code{dlm} object.

  For the other forms, the specific component of \code{x}.
}
\author{Giovanni Petris \email{GPetris@uark.edu}}

\seealso{\code{\link{dlm}}}
\examples{
set.seed(222)
mod <- dlmRandom(5, 6)
all.equal( FF(mod), mod$FF )
all.equal( V(mod), mod$V )
all.equal( GG(mod), mod$GG )
all.equal( W(mod), mod$W )
all.equal( m0(mod), mod$m0 )
all.equal( C0(mod), mod$C0)
m0(mod)
m0(mod) <- rnorm(6)
C0(mod)
C0(mod) <- rwishart(10, 6)
### A time-varying model
mod <- dlmModReg(matrix(rnorm(10), 5, 2))
JFF(mod)
X(mod)
}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
\keyword{ts}

####$$$$ dlm\man/mcmc.Rd
\name{mcmc}
\alias{mcmcMean}
\alias{mcmcMeans}
\alias{mcmcSD}
\alias{ergMean}

\title{Utility functions for MCMC output analysis}
\description{
  Returns the mean, the standard deviation of the mean, and a sequence
  of partial means of the input vector or matrix. 
}
\usage{
mcmcMean(x, sd = TRUE)
mcmcMeans(x, sd = TRUE)
mcmcSD(x)
ergMean(x, m = 1)
}

\arguments{
  \item{x}{vector or matrix containing the output of a Markov chain
    Monte Carlo simulation.}
  \item{sd}{logical: should an estimate of the Monte Carlo standard
    deviation be reported?} 
  \item{m}{ergodic means are computed for \code{i} in \code{m:NROW(x)}}
}

\details{
  The argument \code{x} is typically the output from a simulation. If a
  matrix, rows are considered consecutive simulations of a target
  vector. In this case means, standard deviations, and ergodic means
  are returned for each column. The standard deviation of the mean is
  estimated using Sokal's method (see the reference). \code{mcmcMeans}
  is an alias for \code{mcmcMean}.
}

\references{P. Green (2001). A Primer on Markov Chain Monte Carlo. In
  \emph{Complex Stochastic Systems}, (Barndorff-Nielsen, Cox and
  Kl\"uppelberg, eds.). Chapman and Hall/CRC. }
\author{Giovanni Petris \email{GPetris@uark.edu}}

\examples{
x <- matrix(rexp(1000), nc=4)
dimnames(x) <- list(NULL, LETTERS[1:NCOL(x)])
mcmcSD(x)
mcmcMean(x)
em <- ergMean(x, m = 51)
plot(ts(em, start=51), xlab="Iteration", main="Ergodic means")
}

\keyword{misc}

####$$$$ dlm\man/NelPlo.Rd
\name{NelPlo}
\docType{data}
\alias{NelPlo}
\title{Nelson-Plosser macroeconomic time series}
\description{
  A subset of Nelson-Plosser data.
}
\usage{data(NelPlo)}
\format{
  The format is:
 mts [1:43, 1:2] -4.39  3.12  1.08 -1.50  3.91 ...
 - attr(*, "tsp")= num [1:3] 1946 1988    1
 - attr(*, "class")= chr [1:2] "mts" "ts"
 - attr(*, "dimnames")=List of 2
  ..$ : NULL
  ..$ : chr [1:2] "ip" "stock.prices"
}
\details{
  The series are \code{100*diff(log())} of 
  industrial production and stock prices (S&P500) from 1946 to 1988.
}
\source{
  The complete data set is available in package \code{tseries}.
}

\examples{
data(NelPlo)
plot(NelPlo)
}
\keyword{datasets}

####$$$$ dlm\man/residuals.dlmFiltered.Rd
\name{residuals.dlmFiltered}
\alias{residuals.dlmFiltered}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{One-step forecast errors}
\description{
  The function computes one-step forecast errors for a filtered dynamic
  linear model.
}
\usage{
\method{residuals}{dlmFiltered}(object, ..., type = c("standardized", "raw"), sd = TRUE)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{object}{an object of class \code{"dlmFiltered"}, such as the
    output from \code{dlmFilter}}
  \item{\dots}{unused additional arguments.}
  \item{type}{should standardized or raw forecast errors be produced?}
  \item{sd}{when \code{sd = TRUE}, standard deviations are returned as well.}
}
\value{
  A vector or matrix (in the multivariate case) of one-step forecast
  errors, standardized if \code{type = "standardized"}. Time series
  attributes of the original observation vector (matrix) are retained by
  the one-step forecast errors.

  If \code{sd = TRUE} then the returned value is a list with the
  one-step forecast errors in component \code{res} and the corresponding
  standard deviations in component \code{sd}. 
}
\note{The \code{object} argument must include a component \code{y}
  containing the data. This component will not be present if
  \code{object} was obtained by calling \code{dlmFilter} with
  \code{simplify = TRUE}.}
\references{Giovanni Petris (2010), An R Package for Dynamic Linear
  Models. Journal of Statistical Software, 36(12), 1-16.
  \url{http://www.jstatsoft.org/v36/i12/}.\cr
  Petris, Petrone, and Campagnoli, Dynamic Linear Models with
  R, Springer (2009).\cr
  West and Harrison, Bayesian forecasting and
  dynamic models (2nd ed.), Springer (1997).
}

\author{Giovanni Petris \email{GPetris@uark.edu}}

\seealso{\code{\link{dlmFilter}}}
\examples{
## diagnostic plots 
nileMod <- dlmModPoly(1, dV = 15100, dW = 1468)
nileFilt <- dlmFilter(Nile, nileMod)
res <- residuals(nileFilt, sd=FALSE)
qqnorm(res)
tsdiag(nileFilt)
}
\keyword{misc}% at least one, from doc/KEYWORDS

####$$$$ dlm\man/rwishart.Rd
\name{rwishart}
\alias{rwishart}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{Random Wishart matrix}
\description{
Generate a draw from a Wishart distribution.
}
\usage{
rwishart(df, p = nrow(SqrtSigma), Sigma, SqrtSigma = diag(p))
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{df}{degrees of freedom. It has to be integer.}
  \item{p}{dimension of the matrix to simulate.}
  \item{Sigma}{the matrix parameter Sigma of the Wishart distribution.}
  \item{SqrtSigma}{a \emph{square root} of the matrix parameter Sigma of the 
  Wishart distribution. Sigma must be equal to \code{crossprod(SqrtSigma)}.}
}
\details{
  The Wishart is a distribution on the set of nonnegative definite
  symmetric matrices. Its density is
  \deqn{p(W) = \frac{c |W|^{(n-p-1)/2}}{|\Sigma|^{n/2}}
    \exp\left\{-\frac{1}{2}\mathrm{tr}(\Sigma^{-1}W)\right\}}{%
    p(W) = c|W|^((n-p-1)/2) / |Sigma|^(n/2) exp(-tr(Sigma^(-1)W)/2)}
  where \eqn{n} is the degrees of freedom parameter \code{df} and
  \eqn{c} is a normalizing constant.
  The mean of the Wishart distribution is \eqn{n\Sigma}{n Sigma} and the
  variance of an entry is
  \deqn{\mathrm{Var}(W_{ij}) = n (\Sigma_{ij}^2 +
    \Sigma_{ii}\Sigma_{jj})}{%
    Var(W[i,j]) = n (Sigma[i,j]^2 + Sigma[i,i] Sigma[j,j])}
  The matrix parameter, which should be a positive definite symmetric
  matrix, can be specified via either the argument Sigma or
  SqrtSigma. If Sigma is specified, then SqrtSigma is ignored. No checks
  are made for symmetry and positive definiteness of Sigma.
}
\value{
  The function returns one draw from the Wishart distribution with 
  \code{df} degrees of freedom and matrix parameter \code{Sigma} or
  \code{crossprod(SqrtSigma)}	
}
\references{Press (1982). Applied multivariate analysis.}
\author{Giovanni Petris \email{GPetris@uark.edu}}
\note{From a suggestion by B.Venables, posted on S-news}
\section{Warning}{The function only works for an integer number 
of degrees of freedom.}
 
\examples{
rwishart(25, p = 3)
a <- matrix(rnorm(9), 3)
rwishart(30, SqrtSigma = a)
b <- crossprod(a)
rwishart(30, Sigma = b)
}

\keyword{distribution}% at least one, from doc/KEYWORDS

####$$$$ dlm\man/USecon.Rd
\name{USecon}
\docType{data}
\alias{USecon}
\title{US macroeconomic time series}
\description{
  US macroeconomic data.
}
\usage{data(USecon)}
\format{
  The format is:
 mts [1:40, 1:2]  0.1364  0.0778 -0.3117 -0.5478 -1.2636 ...
 - attr(*, "dimnames")=List of 2
  ..$ : NULL
  ..$ : chr [1:2] "M1" "GNP"
 - attr(*, "tsp")= num [1:3] 1978 1988    4
 - attr(*, "class")= chr [1:2] "mts" "ts"
}
\details{
  The series are \code{100*diff(log())} of seasonally adjusted real 
  U.S. money 'M1' and GNP from 1978 to 1987.
}
\source{
  The complete data set is available in package \code{tseries}.
}

\examples{
data(USecon)
plot(USecon)
}
\keyword{datasets}

####$$$$ dlm\R/arms.R
### To find the boundary of a bounded convex set
"convex.bounds" <-
function (x, dir, indFunc, ..., tol = 1e-07) 
{
    ## x: a point within the set
    ## dir: a vector giving the direction along which bounds are sought
    ## indFunc: the indicator function of a bounded convex set
    ## ... : additional arguments passed to indFunc
    if (all(dir == 0)) 
        stop("invalid direction in convex.bounds()")
    if (indFunc(x, ...) < 0.5) 
        stop("x not in the support of indFunc")
    f.onedim <- function(u) indFunc(x + u * dir, ...)
    e <- -2
    while (f.onedim(e) > 0.5) e <- e * 2
    lower <- e
    e <- 2
    while (f.onedim(e) > 0.5) e <- e * 2
    upper <- e
    ans <- numeric(2)
    ## search for `lower' boundary along dir
    bracket.low <- lower
    bracket.high <- 0
    repeat {
        cand <- 0.5 * (bracket.low + bracket.high)
        if (f.onedim(cand) > 0.5) 
            bracket.high <- cand
        else bracket.low <- cand
        if (bracket.high - bracket.low < tol) {
            ans[1] <- bracket.high
            break
        }
    }
    ## search for `upper' boundary along dir
    bracket.low <- 0
    bracket.high <- upper
    repeat {
        cand <- 0.5 * (bracket.low + bracket.high)
        if (f.onedim(cand) > 0.5) 
            bracket.low <- cand
        else bracket.high <- cand
        if (bracket.high - bracket.low < tol) {
            ans[2] <- bracket.low
            break
        }
    }
    return(ans)
}

### Wrapper to arms.c
"arms" <-
function (y.start, myldens, indFunc, n.sample, ...) 
{
    ## y.start: starting point
    ## myldens: univariate or multivariate logdensity from which a sample
    ##          needs to be generated
    ## indFunc: the indicator function of the support of myldens
    ##          (assumed to be convex and bounded)
    ## n.sample: desired sample size
    ## ...     : additional arguments passed to myldens and indFunc
    ## sanity checks first
#     if (mode(myldens) != "function") 
#         stop("myldens not a function")
#     if (mode(indFunc) != "function") 
#         stop("indFunc not a function")
#     if (n.sample < 0) 
#         stop("n.sample must be nonnegative")
#     if (n.sample < 1) 
#         return(numeric(0))
#     if (!is.numeric(y.start)) 
#         stop("non numeric argument y.start")
    dim <- length(y.start)
#     if (dim == 0) 
#         stop("starting point has length zero")
#     if (!(indFunc(y.start, ...) > 0)) 
#         stop("starting point not in the support")
    if (dim == 1) {
        bounds <- y.start + convex.bounds(y.start, dir = 1, indFunc = indFunc, 
            ...)
        if ( diff(bounds) < 1e-7 )
            y.sample <- rep(y.start, n.sample)
        else {
            f <- function(x) myldens(x, ...)
            y.sample <- .Call("arms", bounds, f, y.start, as.integer(n.sample), 
                              new.env(), PACKAGE="dlm")
        }
    }
    else {
        y.sample <- rbind(y.start, matrix(0, n.sample, dim))
        for (k in 1:n.sample) {
            ## pick a direction at random 
            dir <- rnorm(dim)
            ## look for boundaries of support in the selected direction
            bounds <- convex.bounds(y.sample[k, ], dir, indFunc = indFunc, 
                ...)
            if ( diff(bounds) < 1e-7 )
                y.sample[k + 1, ] <- y.sample[k, ]
            else {
                ## define the univariate density to be passed to arms.c
                f <- function(x) myldens(y.sample[k, ] + x * dir, 
                                         ...)
                ## call arms.c
                y.sample[k + 1, ] <- y.sample[k, ] + dir * .Call("arms", 
                    bounds, f, 0, as.integer(1), new.env(), PACKAGE="dlm")
            }
        }
        y.sample <- y.sample[-1, ]
    }
    return(y.sample)
}

####$$$$ dlm\R/DLM.R

###### Function to create block diagonal matrices (from R-help, I suppose)
bdiag <- function(...)
{
    if (nargs() == 1)
        x <- as.list(...)
    else
        x <- list(...)
    n <- length(x)
    if(n==0) return(NULL)
    x <- lapply(x, function(y) if(length(y)) as.matrix(y) else
                stop("Zero-length component in x"))
    d <- array(unlist(lapply(x, dim)), c(2, n))
    rr <- d[1,]
    cc <- d[2,]
    rsum <- sum(rr)
    csum <- sum(cc)
    out <- array(0, c(rsum, csum))
    ind <- array(0, c(4, n))
    rcum <- cumsum(rr)
    ccum <- cumsum(cc)
    ind[1,-1] <- rcum[-n]
    ind[2,] <- rcum
    ind[3,-1] <- ccum[-n]
    ind[4,] <- ccum
    imat <- array(1:(rsum * csum), c(rsum, csum))
    iuse <- apply(ind, 2, function(y, imat) imat[(y[1]+1):y[2],
                                                 (y[3]+1):y[4]], imat=imat)
    iuse <- as.vector(unlist(iuse))
    out[iuse] <- unlist(x)
    return(out)
}

###### From R^p to the AR parameters of a stationary AR(p) (univariate)
###### For the multivariate analog, see Ansley and Kohn, 1986,
###### J. Statist. Comput. Simul. 24.
ARtransPars <- function(raw) {
    p <- length(raw)
    return(.Call("ARtranspar", p, as.double(raw), PACKAGE="dlm"))
}

###### Constructor for dlm objects
dlm <- function(...) {
    if (nargs() == 1)
        x <- as.list(...)
    else
        x <- list(...)
    ## required components
    nm <- c("m0", "C0", "FF", "V", "GG", "W")
    nmInd <- match(nm, names(x))
    if (any(is.na(nmInd)))
        stop(paste("Component(s)", paste(nm[is.na(nmInd)], collapse=", "),
                   "is (are) missing"))
    x[nmInd[-1]] <- lapply(x[nmInd[-1]], as.matrix)
    if (!is.numeric(x$FF))
        stop("Component FF must be numeric")
    m <- nrow(x$FF)
    p <- ncol(x$FF)
    if (!is.numeric(x$V))
        stop("Component V must be numeric")
    if (!( nrow(x$V) == m && ncol(x$V) == m))
        stop("Incompatible dimensions of matrices")
    if (!is.numeric(x$GG))
        stop("Component GG must be numeric")
    if (!( nrow(x$GG) == p && ncol(x$GG) == p))
        stop("Incompatible dimensions of matrices")
    if (!is.numeric(x$W))
        stop("Component W must be numeric")
    if (!( nrow(x$W) == p && ncol(x$W) == p))
        stop("Incompatible dimensions of matrices")
    if (!is.numeric(x$C0))
        stop("Component C0 must be numeric")
    if (!( nrow(x$C0) == p && ncol(x$C0) == p))
        stop("Incompatible dimensions of matrices")
    if (!( is.numeric(x$m0) && NCOL(x$m0) == 1 && NROW(x$m0) == p ))
        stop(paste("Component m0 must be a numeric vector of length",
                   "\n equal to ncol of component FF, or a matrix with one column and",
                   "\n number of rows equal to ncol of component FF"))
    if (!(all.equal(x$C0, t(x$C0)) && all(eigen(x$C0)$values >= 0)))
        stop("C0 is not a valid variance matrix")
    if (any( c(is.na(x$m0), is.na(x$C0))))
        stop("Missing values are not allowed in components m0 and C0")
    ## extra components for time-varying dlm
    nm1 <- c("JFF", "JV", "JGG", "JW")
    nm1Ind <- match(nm1, names(x))
    if (all(is.na(nm1Ind))) {
        if (!(all.equal(x$V, t(x$V)) && all(eigen(x$V)$values >= 0)))
            stop("V is not a valid variance matrix")
        if (!(all.equal(x$W, t(x$W)) && all(eigen(x$W)$values >= 0)))
            stop("W is not a valid variance matrix")
        mod <- x[nmInd]
        class(mod) <- "dlm"
        return(mod)
    }
    x[nm1Ind[!is.na(nm1Ind)]] <-
        lapply(x[nm1Ind[!is.na(nm1Ind)]], function(x) if (!is.null(x)) as.matrix(x))
    if (!is.null(x$JFF)) {
        if (!(is.numeric(x$JFF) &&
              nrow(x$JFF) == m && ncol(x$JFF) == p))
            stop("Invalid component JFF")
        JFF <- round(x$JFF)
        if (all(JFF == 0)) JFF <- NULL
    } else
    JFF <- NULL
    if (!is.null(x$JV)) {
        if (!(is.numeric(x$JV) &&
              nrow(x$JV) == m && ncol(x$JV) == m))
            stop("Invalid component JV")
        JV <- round(x$JV)
        if (all(JV == 0)) JV <- NULL
    } else
    JV <- NULL
    if (!is.null(x$JGG)) {
        if (!(is.numeric(x$JGG) &&
              nrow(x$JGG) == p && ncol(x$JGG) == p))
            stop("Invalid component JGG")
        JGG <- round(x$JGG)
        if (all(JGG == 0)) JGG <- NULL
    } else
    JGG <- NULL
    if (!is.null(x$JW)) {
        if (!(is.numeric(x$JW) &&
              nrow(x$JW) == p && ncol(x$JW) == p))
            stop("Invalid component JW")
        JW <- round(x$JW)
        if (all(JW == 0)) JW <- NULL
    } else
    JW <- NULL
    mx <- max(c(JFF, JV, JGG, JW))
    if ( mx <= 0 ) {
        mod <- x[nmInd]
        class(mod) <- "dlm"
        return(mod)
    }
    if ( is.null(x$X) )
        stop("Component X must be provided for time-varying models")
    x$X <- as.matrix(x$X)
    if (!(is.numeric(x$X) && ncol(x$X) >= mx))
        stop("Invalid component X")
    mod <- c(x[nmInd], list(JFF=JFF, JV=JV, JGG=JGG, JW=JW, X=x$X))
    class(mod) <- "dlm"
    return(mod)
}

is.dlm <- function(obj) inherits(obj, "dlm")

as.dlm <- function(obj)
    if (is.dlm(obj)) obj else dlm(obj)

is.dlmFiltered <- function(obj) inherits(obj, "dlmFiltered")


###### Extractors and replacement functions
FF <- function(x) UseMethod("FF")
"FF<-" <- function(x, value) UseMethod("FF<-")
GG <- function(x) UseMethod("GG")
"GG<-" <- function(x, value) UseMethod("GG<-")
V <- function(x) UseMethod("V")
"V<-" <- function(x, value) UseMethod("V<-")
W <- function(x) UseMethod("W")
"W<-" <- function(x, value) UseMethod("W<-")
C0 <- function(x) UseMethod("C0")
"C0<-" <- function(x, value) UseMethod("C0<-")
m0 <- function(x) UseMethod("m0")
"m0<-" <- function(x, value) UseMethod("m0<-")

FF.dlm <- function(x)
{
    if (!is.dlm(x))
        stop(paste(deparse(substitute(x)), "is not a dlm object"))
    if (!is.null(x$JFF))
        warning(paste("Time varying", sQuote("F")))
    return(x$FF)
}

"FF<-.dlm" <- function(x, value)
{
    value <- as.matrix(value)
    if (!is.dlm(x))
        stop(paste(deparse(substitute(x)), "is not a dlm object"))
    if (any(!is.finite(value)))
        stop(paste("finite values needed in", sQuote("F")))
    if (!(is.numeric(value) && is.matrix(value)))
        stop(paste(deparse(substitute(value)), "is not a valid observation matrix"))
    if ( any(dim(x$FF) != dim(value)) )
        stop(paste("wrong dimension of", deparse(substitute(value))))
    if (!is.null(x$JFF))
        warning(paste("time varying", sQuote("F"), "in", sQuote("x")))
    x$FF <- value
    return(x)
}

GG.dlm <- function(x)
{
    if (!is.dlm(x))
        stop(paste(deparse(substitute(x)), "is not a dlm object"))
    if (!is.null(x$JGG))
        warning(paste("Time varying", sQuote("G")))
    return(x$GG)
}

"GG<-.dlm" <- function(x, value)
{
    value <- as.matrix(value)
    if (!is.dlm(x))
        stop(paste(deparse(substitute(x)), "is not a dlm object"))
    if (any(!is.finite(value)))
        stop(paste("finite values needed in", sQuote("G")))
    if (!(is.numeric(value) && is.matrix(value)))
        stop(paste(deparse(substitute(value)), "is not a valid evolution matrix"))
    if ( any(dim(x$GG) != dim(value)) )
        stop(paste("wrong dimension of", deparse(substitute(value))))
    if (!is.null(x$JGG))
        warning(paste("Time varying", sQuote("G"), "in", sQuote("x")))
    x$GG <- value
    return(x)
}

V.dlm <- function(x)
{
    if (!is.dlm(x))
        stop(paste(deparse(substitute(x)), "is not a dlm object"))
    if (!is.null(x$JV))
        warning(paste("Time varying", sQuote("V")))
    return(x$V)
}

"V<-.dlm" <- function(x, value)
{
    value <- as.matrix(value)
    if (!is.dlm(x))
        stop(paste(deparse(substitute(x)), "is not a dlm object"))
    if (any(!is.finite(value)))
        stop(paste("finite values needed in", sQuote("V")))
    if (!(is.numeric(value) && is.matrix(value) && all.equal(value, t(value))
          && all(eigen(value)$values > -.Machine$double.neg.eps)))
        stop(paste(deparse(substitute(value)), "is not a valid variance matrix"))
    if ( any(dim(x$V) != dim(value)) )
        stop(paste("wrong dimension of", deparse(substitute(value))))
    if (!is.null(x$JV))
        warning(paste("Time varying", sQuote("V"), "in", sQuote("x")))
    x$V <- value
    return(x)
}

W.dlm <- function(x)
{
    if (!is.dlm(x))
        stop(paste(deparse(substitute(x)), "is not a dlm object"))
    if (!is.null(x$JW))
        warning(paste("Time varying", sQuote("W")))
    return(x$W)
}

"W<-.dlm" <- function(x, value)
{
    value <- as.matrix(value)
    if (!is.dlm(x))
        stop(paste(deparse(substitute(x)), "is not a dlm object"))
    if (any(!is.finite(value)))
        stop(paste("finite values needed in", sQuote("W")))
    if (!(is.numeric(value) && is.matrix(value) && all.equal(value, t(value))
          && all(eigen(value)$values > -.Machine$double.neg.eps)))
        stop(paste(deparse(substitute(value)), "is not a valid variance matrix"))
    if ( any(dim(x$W) != dim(value)) )
        stop(paste("wrong dimension of", deparse(substitute(value))))
    if (!is.null(x$JW))
        warning(paste("Time varying", sQuote("W"), "in", sQuote("x")))
    x$W <- value
    return(x)
}

C0.dlm <- function(x)
{
    if (!is.dlm(x))
        stop(paste(deparse(substitute(x)), "is not a dlm object"))
    return(x$C0)
}

"C0<-.dlm" <- function(x, value)
{
    value <- as.matrix(value)
    if (!is.dlm(x))
        stop(paste(deparse(substitute(x)), "is not a dlm object"))
    if (any(!is.finite(value)))
        stop(paste("finite values needed in", sQuote("C0")))
    if (!(is.numeric(value) && is.matrix(value) && all.equal(value, t(value))
          && all(eigen(value)$values > 0)))
        stop(paste(deparse(substitute(value)), "is not a valid variance matrix"))
    if ( any(dim(x$C0) != dim(value)) )
        stop(paste("wrong dimension of", deparse(substitute(value))))
    x$C0 <- value
    return(x)
}

m0.dlm <- function(x) {
    if (!is.dlm(x))
        stop(paste(deparse(substitute(x)), "is not a dlm object"))
    return(x$m0)
}

"m0<-.dlm" <- function(x, value)
{
    if (!is.dlm(x))
        stop(paste(deparse(substitute(x)), "is not a dlm object"))
    if (any(!is.finite(value)))
        stop(paste("finite values needed in", sQuote("m0")))
    if (!is.numeric(value))
        stop(paste(deparse(substitute(value)), "is not numeric"))
    if (!(length(value) == length(x$m0) && NCOL(value) == 1))
        stop(paste("wrong length/dimension of", deparse(substitute(value))))
    x$m0 <- value
    return(x)
}

### Stuff for time-varying models
JFF <- function(x) UseMethod("JFF")
"JFF<-" <- function(x, value) UseMethod("JFF<-")
JGG <- function(x) UseMethod("JGG")
"JGG<-" <- function(x, value) UseMethod("JGG<-")
JV <- function(x) UseMethod("JV")
"JV<-" <- function(x, value) UseMethod("JV<-")
JW <- function(x) UseMethod("JW")
"JW<-" <- function(x, value) UseMethod("JW<-")
X <- function(x) UseMethod("X")
"X<-" <- function(x, value) UseMethod("X<-")

JFF.dlm <- function(x) {
    return(x$JFF)
}

"JFF<-.dlm" <- function(x, value)
{
    if (!is.dlm(x))
        stop(paste(deparse(substitute(x)), "is not a dlm object"))
    value <- as.matrix(value)
    dm <- dim(value)
    value <- as.integer(value)
    dim(value) <- dm
    if (any(is.na(value)))
        stop(paste("missing values not allowed in", sQuote("JFF")))
    if ( any(dim(x$FF) != dim(value)) )
        stop(paste("wrong dimension of", deparse(substitute(value))))
    x$JFF <- value
    return(x)
}

JGG.dlm <- function(x) {
    return(x$JGG)
}

"JGG<-.dlm" <- function(x, value)
{
    if (!is.dlm(x))
        stop(paste(deparse(substitute(x)), "is not a dlm object"))
    value <- as.matrix(value)
    dm <- dim(value)
    value <- as.integer(value)
    dim(value) <- dm
    if (any(is.na(value)))
        stop(paste("missing values not allowed in", sQuote("JGG")))
    if ( any(dim(x$GG) != dim(value)) )
        stop(paste("wrong dimension of", deparse(substitute(value))))
    x$JGG <- value
    return(x)
}

JV.dlm <- function(x) {
    return(x$JV)
}

"JV<-.dlm" <- function(x, value)
{
    if (!is.dlm(x))
        stop(paste(deparse(substitute(x)), "is not a dlm object"))
    value <- as.matrix(value)
    dm <- dim(value)
    value <- as.integer(value)
    dim(value) <- dm
    if (any(is.na(value)))
        stop(paste("missing values not allowed in", sQuote("JV")))
    if ( any(dim(x$V) != dim(value)) )
        stop(paste("wrong dimension of", deparse(substitute(value))))
    x$JV <- value
    return(x)
}

JW.dlm <- function(x) {
    return(x$JW)
}

"JW<-.dlm" <- function(x, value)
{
    if (!is.dlm(x))
        stop(paste(deparse(substitute(x)), "is not a dlm object"))
    value <- as.matrix(value)
    dm <- dim(value)
    value <- as.integer(value)
    dim(value) <- dm
    if (any(is.na(value)))
        stop(paste("missing values not allowed in", sQuote("JW")))
    if ( any(dim(x$W) != dim(value)) )
        stop(paste("wrong dimension of", deparse(substitute(value))))
    x$JW <- value
    return(x)
}

X.dlm <- function(x) {
    return(x$X)
}

"X<-.dlm" <- function(x, value)
{
    value <- as.matrix(value)
    dm <- dim(value)
    value <- as.numeric(value)
    dim(value) <- dm
    if (any(!is.finite(value)))
        stop(paste("finite values needed in", sQuote("X")))
    x$X <- value
    return(x)
}


###### Regression
dlmModReg <- function(X, addInt=TRUE, dV=1, dW=rep(0,NCOL(X)+addInt),
                      m0=rep(0,length(dW)), C0=1e7*diag(nrow=length(dW)))
{
    ## sanity checks
    p <- NCOL(X) + addInt
    if (!( length(dV)==1 && length(dW)==p &&
          length(m0)==p && nrow(C0)==p && ncol(C0)==p))
        stop("Inconsistent dimensions of arguments")
    X <- as.matrix(X)
    JFF <- matrix(1:ncol(X),nrow=1)
    if (addInt)
        JFF <- cbind(0,JFF)
    mod <- list(
                m0 = m0,
                C0 = C0,
                FF = matrix(1,1,p),
                V = as.matrix(dV),
                GG = diag(nrow=p),
                W = diag(x=dW, nrow=p),
                JFF = JFF,
                JV = NULL,
                JGG = NULL,
                JW = NULL,
                X = X)
    class(mod) <- "dlm"
    return(mod)
}

###### Polynomial trend
dlmModPoly <- function(order=2, dV=1,
                       dW=c(rep(0,order-1),1),
                       m0=rep(0,order), C0=1e7*diag(nrow=order))
{
    C0 <- as.matrix(C0)
    ## sanity checks
    if (!( length(dV)==1 && length(dW)==order &&
          length(m0)==order && nrow(C0)==order && ncol(C0)==order))
        stop("Inconsistent dimensions of arguments")
    GG <- diag(order)
    GG[row(GG) == col(GG)-1] <- 1
    mod <- list(
                m0 = m0,
                C0 = C0,
                FF = matrix(c(1,rep(0,order-1)),nrow=1),
                V = as.matrix(dV),
                GG = GG,
                W = diag(dW,nrow=length(dW)),
                JFF = NULL,
                JV = NULL,
                JGG = NULL,
                JW = NULL)
    class(mod) <- "dlm"
    return(mod)
}

###### Seasonal factors
dlmModSeas <- function(frequency, dV=1, dW=c(1,rep(0,frequency-2)),
                       m0=rep(0,frequency-1),
                       C0=1e7*diag(nrow=frequency-1))
{
    frequency <- as.integer(frequency)
    p <- frequency - 1
    if (!( length(dV) == 1 && length(dW) == p && length(m0) == p &&
          nrow(C0) == p && ncol(C0) == p ))
        stop("Inconsistent dimensions of arguments")
    GG <- matrix(0,p,p)
    GG[row(GG) == col(GG)+1] <- 1
    GG[1,] <- -1
    mod <- list(
                m0 = m0,
                C0 = C0,
                FF = matrix(c(1,rep(0,p-1)),nrow=1),
                V = as.matrix(dV),
                GG = GG,
                W = diag(dW,nrow=length(dW)),
                JFF = NULL,
                JV = NULL,
                JGG = NULL,
                JW = NULL)
    class(mod) <- "dlm"
    return(mod)
}

###### Fourier representation
dlmModTrig <- function(s, q, om, tau, dV=1, dW=0, m0, C0)
{
    if ( hasArg(s) ) {
        if ( hasArg(om) )
            stop("Cannot specify both 's' and 'om'")
        if ( hasArg(tau) )
            stop("Cannot specify both 's' and 'tau'")
        s <- as.integer(s)
        sHalf <- s %/% 2
        if ( hasArg(q) ) {
            q <- as.integer(q)
            if ( q > sHalf )
                stop(paste("Can use",sHalf,"components at most (",q,"were asked for )"))
            if ( q <= 0 ) stop("'q' must be positive")
        } else {
            q <- sHalf }
        om <- 2 * base::pi / s
        evenAll <- (q == sHalf) && !(s %% 2)
        if ( sHalf == 1 && evenAll ) {
            FF <- matrix(1,1,1)
            GG <- matrix(-1,1,1)
        } else {
            H1 <- diag(x=cos(om), nrow=2)
            H1[1,2] <- sin(om)
            H1[2,1] <- - H1[1,2]
            if ( q > 1 ) {
                h <- vector("list",q)
                h[[1]] <- H1
                i <- 2
                while ( i < q ) {
                    h[[i]] <- h[[i-1]] %*% H1
                    i <- i + 1
                }
                h[[q]] <- if ( evenAll ) matrix(-1,1,1) else h[[q-1]] %*% H1
                GG <- bdiag(h)
            } else {
                GG <- H1 }
        }
    } else {
        if ( !hasArg(om) )
            if ( !hasArg(tau) )
                stop("One of 's', 'om' or 'tau' must be specified")
            else om <- 2 * base::pi / tau
        if ( !hasArg(q) )
            stop("When 'om' or 'tau' is specified, 'q' must be supplied as well")
        q <- as.integer(q)
        if ( q <= 0 ) stop("'q' must be positive")
        evenAll <- FALSE
        H1 <- diag(x=cos(om), nrow=2)
        H1[1,2] <- sin(om)
        H1[2,1] <- - H1[1,2]
        if ( q > 1 ) {
            h <- vector("list",q)
            h[[1]] <- H1
            for ( i in 2:q )
                h[[i]] <- h[[i-1]] %*% H1
            GG <- bdiag(h)
        } else {
            GG <- H1 }
    }
    if ( hasArg(m0) ) {
        if ( length(m0) != nrow(GG) ) stop("Wrong length of 'm0'")
    } else {
        m0 <- rep(0,nrow(GG)) }
    if ( hasArg(C0) ) {
        if ( (nrow(C0) != nrow(GG)) || (ncol(C0) != nrow(GG)) )
            stop("Wrong dimension of 'C0'")
    } else {
        C0 <- diag(x=1e7, nrow=nrow(GG)) }
    mod <- list(
                m0 = m0,
                C0 = C0,
                FF = matrix(if (evenAll) c(rep(c(1,0),q-1),1)
                else c(1,0),1,nrow(GG)),
                V = matrix(dV,1,1),
                GG = GG,
                W = diag(x=dW,nrow=nrow(GG)),
                JFF = NULL,
                JV = NULL,
                JGG = NULL,
                JW = NULL)
    class(mod) <- "dlm"
    return(mod)
}

###### ARMA
dlmModARMA <- function(ar=NULL, ma=NULL, sigma2=1, dV, m0, C0)
{
    if (is.matrix(sigma2) && (m <- nrow(sigma2)) > 1)
    { ## multivariate
        if (ncol(sigma2) != m)
            stop("sigma2 must be a square matrix")
        r <- max(p <- length(ar), (q <- length(ma)) + 1)
        k <- m * r
        if (hasArg("dV")) {
            if ( length(dV) != m )
                stop("Incompatible dimensions of arguments")
        }
        else
            dV <- rep(0,m)
        if (hasArg("m0")) {
            if ( length(m0) != k )
                stop("Incompatible dimensions of arguments")
        }
        else
            m0 <- rep(0,k)
        if (hasArg("C0")) {
            if ( !( nrow(C0) == k && ncol(C0) == k ))
                stop("Incompatible dimensions of arguments")
        }
        else
            C0 <- 1e7*diag(nrow=k)
        FF <- matrix(0,m,k)
        FF[row(FF) == col(FF)] <- 1
        GG <- matrix(0,k,k)
        for (i in seq(length.out=p))  GG[ (1 + (i-1) * m):(i * m), 1:m ] <- ar[[i]]
        GG[row(GG) == col(GG) - m] <- 1
        R <- matrix(0,k,m)
        R[row(R) == col(R)] <- 1
        for (i in seq(length.out=q)) R[ (1 + i * m):((i+1) * m), ] <- ma[[i]]
        mod <- list(
                    m0 = m0,
                    C0 = C0,
                    FF = FF,
                    V = diag(dV,nrow=m),
                    GG = GG,
                    W = R %*% sigma2 %*% t(R),
                    JFF = NULL,
                    JV = NULL,
                    JGG = NULL,
                    JW = NULL)
    }
    else
    { ## univariate
        r <- max(p <- length(ar), (q <- length(ma)) + 1)
        if (hasArg("dV")) {
            if ( length(dV) != 1 )
                stop("Incompatible dimensions of arguments")
        }
        else
            dV <- 0
        if (hasArg("m0")) {
            if ( length(m0) != r )
                stop("Incompatible dimensions of arguments")
        }
        else
            m0 <- rep(0,r)
        if (hasArg("C0")) {
            if ( !( nrow(C0) == r && ncol(C0) == r ))
                stop("Incompatible dimensions of arguments")
        }
        else
            C0 <- 1e7*diag(nrow=r)
        GG <- matrix(0,r,r)
        if ( p > 0 ) GG[ 1:p, 1 ] <- ar
        GG[row(GG) == col(GG) - 1] <- 1
        R <- rep(0,r)
        R[1] <- 1
        if ( q > 0 ) R[ 1 + 1:q ] <- ma
        mod <- list(
                    m0 = m0,
                    C0 = C0,
                    FF = matrix(c(1,rep(0,r-1)),nrow=1),
                    V = matrix(dV),
                    GG = GG,
                    W = sigma2 * crossprod(matrix(R,nrow=1)),
                    JFF = NULL,
                    JV = NULL,
                    JGG = NULL,
                    JW = NULL)
    }
    class(mod) <- "dlm"
    return(mod)
}


###### Addition for "dlm" objects
"+.dlm" <- function(mod1, mod2)
{
    if ( (m <- nrow(mod1$FF)) != nrow(mod2$FF) )
        stop("Incompatible models")
    if ( (x1 <- !is.null(mod1$X)) | (x2 <- !is.null(mod2$X)) ) {
        if ( x1 && x2 && ( nrow(mod1$X) != nrow(mod2$X) ) )
            stop("Number of rows of mod1$X and mod2$X must match")
        plus <- function(u,v) ifelse( u==0, 0, u+v )
        p1 <- ncol(mod1$FF)
        p2 <- ncol(mod2$FF)
        r <- if ( x1 ) ncol(mod1$X) else 0
        if ( (one <- !is.null(mod1$JFF)) | (two <- !is.null(mod2$JFF)) ) {
            JFF1 <- if ( one ) mod1$JFF else matrix(0,m,p1)
            JFF2 <- if ( two ) plus(mod2$JFF,r) else matrix(0,m,p2)
            JFF <- cbind(JFF1, JFF2)
        } else
        JFF <- NULL
        if ( (one <- !is.null(mod1$JGG)) | (two <- !is.null(mod2$JGG)) ) {
            JGG1 <- if ( one ) mod1$JGG else matrix(0,p1,p1)
            JGG2 <- if ( two ) plus(mod2$JGG,r) else matrix(0,p2,p2)
            JGG <- bdiag(list(JGG1, JGG2))
        } else
        JGG <- NULL
        if ( (one <- !is.null(mod1$JW)) | (two <- !is.null(mod2$JW)) ) {
            JW1 <- if ( one ) mod1$JW else matrix(0,p1,p1)
            JW2 <- if ( two ) plus(mod2$JW,r) else matrix(0,p2,p2)
            JW <- bdiag(list(JW1, JW2))
        } else
        JW <- NULL
        if ( (one <- !is.null(mod1$JV)) | (two <- !is.null(mod2$JV)) ) {
            if ( one && two )
                stop("mod1$V and mod2$V cannot be both time-varying")
            if ( one ) {
                if ( any(mod2$V != 0) ) {
                    mod2$V[] <- 0
                    warning("the value of mod2$V has been discarded")
                }
                JV <- mod1$JV
            }
            if ( two ) {
                if ( any(mod1$V != 0) ) {
                    mod1$V[] <- 0
                    warning("the value of mod1$V has been discarded")
                }
                JV <- plus(mod2$JV,r)
            }
        } else
        JV <- NULL
        mod <- list(
                    m0 = c(mod1$m0, mod2$m0),
                    C0 = bdiag(list(mod1$C0, mod2$C0)),
                    FF = cbind(mod1$FF, mod2$FF),
                    V = mod1$V + mod2$V,
                    GG = bdiag(list(mod1$GG, mod2$GG)),
                    W = bdiag(list(mod1$W, mod2$W)),
                    JFF = JFF,
                    JV = JV,
                    JGG = JGG,
                    JW = JW,
                    X = switch( x1 + 2 * x2,
                    mod1$X,
                    mod2$X,
                    cbind( mod1$X, mod2$X) ))
    } else
    mod <- list(
                m0 = c(mod1$m0, mod2$m0),
                C0 = bdiag(list(mod1$C0, mod2$C0)),
                FF = cbind(mod1$FF, mod2$FF),
                V = mod1$V + mod2$V,
                GG = bdiag(list(mod1$GG, mod2$GG)),
                W = bdiag(list(mod1$W, mod2$W)),
                JFF = NULL,
                JV = NULL,
                JGG = NULL,
                JW = NULL)
    class(mod) <- "dlm"
    return(mod)
}


###### Outer sum of DLMs
"dlmSum" <- function(...)
{
    if ( (narg <- nargs()) == 1  ) {
        if ( is.dlm(...) )
            return(...)
        else
            stop("Argument must be a \"dlm\" object")
    }
    else
    {
        args <- list(...)
        if ( !all(sapply(args, is.dlm)) )
            stop("Arguments must be \"dlm\" objects")
        if ( narg > 2 )
            return( dlmSum(args[[1]], do.call("dlmSum", args[-1])))
        ## now we are in the case narg == 2
        if ((x1 <- !is.null(args[[1]]$X)) | (x2 <- !is.null(args[[2]]$X)))
            stop("Sum of dlm's is only implemented for constant models")
        else
            mod <- list(m0 = c(args[[1]]$m0, args[[2]]$m0),
                        C0 = bdiag(list(args[[1]]$C0, args[[2]]$C0)),
                        FF = bdiag(list(args[[1]]$FF, args[[2]]$FF)),
                        V = bdiag(list(args[[1]]$V, args[[2]]$V)),
                        GG = bdiag(list(args[[1]]$GG, args[[2]]$GG)),
                        W = bdiag(list(args[[1]]$W, args[[2]]$W)),
                        JFF = NULL, JV = NULL, JGG = NULL, JW = NULL)
        class(mod) <- "dlm"
        return(mod)
    }
}

"%+%" <- function(x, y)
    dlmSum(x, y)


###### Print method for "dlm" objects
print.dlm <- function(x, ...) {
    nmRef <- c("FF","V","GG","W","JFF","JV","JGG","JW","X","m0","C0")
    nm <- names(x)
    what <- !sapply(x, is.null)
    ind <- match(nmRef,nm)
    ind <- ind[!is.na(ind)]
    good <- nm[ind][what[ind]]
    if ( !is.na(match("X",good)) && nrow(x$X) > 2 ) {
        x$X <- rbind(formatC(x$X[1:2,,drop=FALSE],digits=4,format="fg"),
                       c("...",rep("",ncol(x$X)-1)))
    }
    print(x[match(good,nm)], quote=FALSE)
    invisible(x)
}

###### Negative loglikelihood
dlmLL <- function(y, mod, debug=FALSE)
{
    ## calculations based on singular value decomposition
    ## Note: V must be nonsingular
    ## The C code relies on the order of the elements in 'mod'
    ## mod = list(m0, C0, FF, V, GG, W)
     if (!debug) {
        storage.mode(y) <- "double"
        matchnames <- match(c("m0", "C0", "FF", "V", "GG", "W"), names(mod))
        for (i in matchnames)
            storage.mode(mod[[i]]) <- "double"
        ## define flags for time-varying components
        if (is.null(mod$JFF))
            tvFF <- FALSE
        else {
            tvFF <- TRUE
            nz <- mod$JFF != 0
            mod$JFF <- cbind(row(mod$JFF)[nz], col(mod$JFF)[nz], mod$JFF[nz]) - 1
            storage.mode(mod$JFF) <- "integer"
        }
        if (is.null(mod$JV))
            tvV <- FALSE
        else {
            tvV <- TRUE
            nz <- mod$JV != 0
            mod$JV <- cbind(row(mod$JV)[nz], col(mod$JV)[nz], mod$JV[nz]) - 1
            storage.mode(mod$JV) <- "integer"
        }
        if (is.null(mod$JGG))
            tvGG <- FALSE
        else {
            tvGG <- TRUE
            nz <- mod$JGG != 0
            mod$JGG <- cbind(row(mod$JGG)[nz], col(mod$JGG)[nz], mod$JGG[nz]) - 1
            storage.mode(mod$JGG) <- "integer"
        }
        if (is.null(mod$JW))
            tvW <- FALSE
        else {
            tvW <- TRUE
            nz <- mod$JW != 0
            mod$JW <- cbind(row(mod$JW)[nz], col(mod$JW)[nz], mod$JW[nz]) - 1
            storage.mode(mod$JW) <- "integer"
        }
        if (any(c(tvFF,tvV,tvGG,tvW))) {
            mod <- mod[match(c("m0", "C0", "FF", "V", "GG", "W",
                               "JFF", "JV", "JGG", "JW", "X"), names(mod))]
            return(.Call("dlmLL", y, mod, tvFF, tvV, tvGG, tvW, PACKAGE="dlm"))
        } else {
            mod <- mod[match(c("m0", "C0", "FF", "V", "GG", "W"), names(mod))]
            return(.Call("dlmLL0", y, mod, PACKAGE="dlm"))
        }
    }
    else {
        eps <- .Machine$double.eps^.3
        y <- as.matrix(y)
        n <- nrow(y)
        ll <- 0 # negative loglikelihood
        ## define flags for time-varying components
        if (is.null(mod$JFF))
            tvFF <- FALSE
        else {
            tvFF <- TRUE
            nz <- mod$JFF != 0
            mod$JFF <- cbind(row(mod$JFF)[nz], col(mod$JFF)[nz], mod$JFF[nz])
        }
        if (is.null(mod$JV))
            tvV <- FALSE
        else {
            tvV <- TRUE
            nz <- mod$JV != 0
            mod$JV <- cbind(row(mod$JV)[nz], col(mod$JV)[nz], mod$JV[nz])
        }
        if (is.null(mod$JGG))
            tvGG <- FALSE
        else {
            tvGG <- TRUE
            nz <- mod$JGG != 0
            mod$JGG <- cbind(row(mod$JGG)[nz], col(mod$JGG)[nz], mod$JGG[nz])
        }
        if (is.null(mod$JW))
            tvW <- FALSE
        else {
            tvW <- TRUE
            nz <- mod$JW != 0
            mod$JW <- cbind(row(mod$JW)[nz], col(mod$JW)[nz], mod$JW[nz])
        }
        tvFV <- tvFF || tvV
        ## preliminary calculations, if possible (non time-varying case)
        if ( !tvV ) {
            tmp <- La.svd(mod$V,nu=0)
            Dv <- sqrt(tmp$d)
            if (any(Dv < eps)) {
              Dv <- pmax(Dv, eps)
              warning("a numerically singular 'V' has been slightly perturbed to make it nonsingular")
            }
            Dv.inv <- 1/Dv
            sqrtVinv <- Dv.inv * tmp$vt # t() %*% () = V^{-1}
            sqrtV <- Dv * tmp$vt # t()%*%() = V
            if ( !tvFF )
                tF.Vinv <- t(mod$FF) %*% crossprod(sqrtVinv)
        }
        if ( !tvW ) {
            svdW <- La.svd(mod$W,nu=0)
            sqrtW <- sqrt(svdW$d) * svdW$vt # t()%*%() = W
        }
        tmp <- La.svd(mod$C0,nu=0)
        Ux <- t(tmp$vt); Dx <- sqrt(tmp$d)
        for (i in seq(length = n)) {
            ## set time-varying matrices
            if ( tvFF )
                mod$FF[mod$JFF[,-3,drop=FALSE]] <- mod$X[i,mod$JFF[,3]]
            if ( tvV ) {
                mod$V[mod$JV[,-3,drop=FALSE]] <- mod$X[i,mod$JV[,3]]
                tmp <- La.svd(mod$V,nu=0)
                Dv <- sqrt(tmp$d)
                Dv.inv <- 1/Dv; Dv.inv[abs(Dv.inv)==Inf] <- 0
                sqrtVinv <- Dv.inv * tmp$vt
                sqrtV <- sqrt(tmp$d) * tmp$vt # t()%*%() = V
            }
            if ( tvGG )
                mod$GG[mod$JGG[,-3,drop=FALSE]] <- mod$X[i,mod$JGG[,3]]
            if ( tvW ) {
                mod$W[mod$JW[,-3,drop=FALSE]] <- mod$X[i,mod$JW[,3]]
                svdW <- La.svd(mod$W,nu=0)
                sqrtW <- sqrt(svdW$d) * svdW$vt # t()%*%() = W
            }
            if ( tvFV )
                tF.Vinv <- t(mod$FF) %*% crossprod(sqrtVinv)

            if (!any(whereNA <- is.na(y[i, ]))) { ## No missing values

                ## prior
                a <- mod$GG %*% mod$m0
                tmp <- La.svd(rbind( Dx*t(mod$GG%*%Ux), sqrtW ), nu=0)
                Ux.prior <- t(tmp$vt)
                Dx.prior <- tmp$d
                ## one-step forecast
                f <- mod$FF %*% a
                tmp <- La.svd(rbind( Dx.prior*t(mod$FF%*%Ux.prior), sqrtV ), nu=0)
                Uy <- t(tmp$vt)
                Dy <- tmp$d
                ## posterior
                D.inv <- 1/Dx.prior
                D.inv[abs(D.inv)==Inf] <- 0
                tmp <- La.svd(rbind(sqrtVinv%*%mod$FF%*%Ux.prior,
                                    diag(x=D.inv,nrow=length(D.inv))), nu=0)
                Ux <- Ux.prior %*% t(tmp$vt)
                Dx <- 1/tmp$d
                Dx[abs(Dx)==Inf] <- 0
                e <- as.matrix(y[i,]-f)
                mod$m0 <- a + crossprod(Dx*t(Ux)) %*%
                    tF.Vinv %*% e
                ## update scaled negative loglikelihood
                ll <- ll + 2*sum(log(Dy)) + crossprod(crossprod(Uy,e)/Dy)

            } else {
                if (all(whereNA)) { ## All components missing

                    ## prior & posterior
                    mod$m0 <- mod$GG %*% mod$m0
                    tmp <- La.svd(rbind( Dx*t(mod$GG%*%Ux), sqrtW ), nu=0)
                    Ux <- t(tmp$vt)
                    Dx <- tmp$d

                } else { ## Some components missing

                    good <- !whereNA
                    tmp <- La.svd(mod$V[good, good], nu=0)
                    Dv <- sqrt(tmp$d)
                    Dv.inv <- 1/Dv; Dv.inv[abs(Dv.inv)==Inf] <- 0
                    sqrtVinvTMP <- Dv.inv * tmp$vt
                    tF.VinvTMP <- t(mod$FF[good,,drop=FALSE]) %*% crossprod(sqrtVinvTMP)
                    sqrtVTMP <- Dv * tmp$vt
                    ## prior
                    a <- mod$GG %*% mod$m0
                    tmp <- La.svd(rbind( Dx*t(mod$GG%*%Ux), sqrtW ), nu=0)
                    Ux.prior <- t(tmp$vt)
                    Dx.prior <- tmp$d
                    ## one-step forecast
                    f <- mod$FF[good,,drop=FALSE] %*% a
                    tmp <- La.svd(rbind( Dx.prior*t(mod$FF[good,,drop=FALSE]%*%Ux.prior), sqrtVTMP ), nu=0)
                    Uy <- t(tmp$vt)
                    Dy <- tmp$d
                    ## posterior
                    D.inv <- 1/Dx.prior
                    D.inv[abs(D.inv)==Inf] <- 0
                    tmp <- La.svd(rbind(sqrtVinvTMP%*%mod$FF[good,,drop=FALSE]%*%Ux.prior,
                                        diag(x=D.inv,nrow=length(D.inv))), nu=0)
                    Ux <- Ux.prior %*% t(tmp$vt)
                    Dx <- 1/tmp$d
                    Dx[abs(Dx)==Inf] <- 0
                    e <- as.matrix(y[i,good]-f)
                    mod$m0 <- a + crossprod(Dx*t(Ux)) %*%
                        tF.VinvTMP %*% e
                    ## update scaled negative loglikelihood
                    ll <- ll + 2*sum(log(Dy)) + crossprod(crossprod(Uy,e)/Dy)
                }
            }
        }
    }
    return(drop(ll)*0.5) # negative loglikelihood
}


"dlmMLE" <- function(y, parm, build, method = "L-BFGS-B",
                     ..., debug = FALSE)
{
    logLik <- function(parm, ...)
    {
        mod <- build(parm, ...)
        return(dlmLL(y=y, mod=mod, debug=debug))
    }
    out <- optim(parm, logLik, method=method, ...)
    return(out)
}


dlmFilter <- function(y, mod, debug = FALSE, simplify = FALSE)
{
    ## Note: V must be nonsingular. It will be forced to be so,
    ## with a warning, otherwise (time-invariant case only).
    eps <- .Machine$double.eps^.3
    mod1 <- mod
    yAttr <- attributes(y)
    ytsp <- tsp(y)
    y <- as.matrix(y)
    timeNames <- dimnames(y)[[1]]
    stateNames <- names(mod$m0)
    if (!debug) {
        storage.mode(y) <- "double"
        matchnames <- match(c("m0", "C0", "FF", "V", "GG", "W"), names(mod))
        for (i in matchnames)
            storage.mode(mod[[i]]) <- "double"
        if ("X" %in% names(mod))
          storage.mode(mod$X) <- "double"
        ## define flags for time-varying components
        if (is.null(mod$JFF))
            tvFF <- FALSE
        else {
            tvFF <- TRUE
            nz <- mod$JFF != 0
            mod$JFF <- cbind(row(mod$JFF)[nz], col(mod$JFF)[nz], mod$JFF[nz]) - 1
            storage.mode(mod$JFF) <- "integer"
        }
        if (is.null(mod$JV))
            tvV <- FALSE
        else {
            tvV <- TRUE
            nz <- mod$JV != 0
            mod$JV <- cbind(row(mod$JV)[nz], col(mod$JV)[nz], mod$JV[nz]) - 1
            storage.mode(mod$JV) <- "integer"
        }
        if (is.null(mod$JGG))
            tvGG <- FALSE
        else {
            tvGG <- TRUE
            nz <- mod$JGG != 0
            mod$JGG <- cbind(row(mod$JGG)[nz], col(mod$JGG)[nz], mod$JGG[nz]) - 1
            storage.mode(mod$JGG) <- "integer"
        }
        if (is.null(mod$JW))
            tvW <- FALSE
        else {
            tvW <- TRUE
            nz <- mod$JW != 0
            mod$JW <- cbind(row(mod$JW)[nz], col(mod$JW)[nz], mod$JW[nz]) - 1
            storage.mode(mod$JW) <- "integer"
        }
        if (any(c(tvFF,tvV,tvGG,tvW))) {
            mod <- mod[match(c("m0", "C0", "FF", "V", "GG", "W",
                               "JFF", "JV", "JGG", "JW", "X"), names(mod))]
            ans <- .Call("dlmFilter", y, mod, tvFF, tvV, tvGG, tvW, PACKAGE = "dlm")
        } else {
            mod <- mod[match(c("m0", "C0", "FF", "V", "GG", "W"), names(mod))]
            ans <- .Call("dlmFilter0", y, mod, PACKAGE = "dlm")
        }
        names(ans) <- c("m", "U.C", "D.C", "a", "U.R", "D.R", "f")
    }
    else {
        ## define flags for time-varying components
        if (is.null(mod$JFF))
            tvFF <- FALSE
        else {
            tvFF <- TRUE
            nz <- mod$JFF != 0
            mod$JFF <- cbind(row(mod$JFF)[nz], col(mod$JFF)[nz], mod$JFF[nz])
        }
        if (is.null(mod$JV))
            tvV <- FALSE
        else {
            tvV <- TRUE
            nz <- mod$JV != 0
            mod$JV <- cbind(row(mod$JV)[nz], col(mod$JV)[nz], mod$JV[nz])
        }
        if (is.null(mod$JGG))
            tvGG <- FALSE
        else {
            tvGG <- TRUE
            nz <- mod$JGG != 0
            mod$JGG <- cbind(row(mod$JGG)[nz], col(mod$JGG)[nz], mod$JGG[nz])
        }
        if (is.null(mod$JW))
            tvW <- FALSE
        else {
            tvW <- TRUE
            nz <- mod$JW != 0
            mod$JW <- cbind(row(mod$JW)[nz], col(mod$JW)[nz], mod$JW[nz])
        }
        tvFV <- tvFF || tvV
        m <- rbind(mod$m0,matrix(0,nrow=nrow(y),ncol=length(mod$m0))) # filtered values
        a <- matrix(0,nrow=nrow(y),ncol=length(mod$m0))
        f <- matrix(0,nrow=nrow(y),ncol=ncol(y))
        U.C <- vector(1+nrow(y),mode="list")
        D.C <- matrix(0,1+nrow(y),length(mod$m0))
        U.R <- vector(nrow(y),mode="list")
        D.R <- matrix(0,nrow(y),length(mod$m0))
        ## preliminary calculations, if possible (non time-varying case)
        if ( !tvV ) {
            tmp <- La.svd(mod$V,nu=0)
            Uv <- t(tmp$vt); Dv <- sqrt(tmp$d)
            if (any(Dv < eps)) {
              Dv <- pmax(Dv, eps)
              warning("a numerically singular 'V' has been slightly perturbed to make it nonsingular")
            }
            Dv.inv <- 1/Dv
            sqrtVinv <- Dv.inv * tmp$vt # t() %*% () = V^{-1}
            if ( !tvFF )
                tF.Vinv <- t(mod$FF) %*% crossprod(sqrtVinv)
        }
        if ( !tvW ) {
            svdW <- La.svd(mod$W,nu=0)
            sqrtW <- sqrt(svdW$d) * svdW$vt # t()%*%() = W
        }
        tmp <- La.svd(mod$C0,nu=0)
        U.C[[1]] <- t(tmp$vt)
        D.C[1,] <- sqrt(tmp$d)
        for (i in seq(length=nrow(y))) {
            ## set time-varying matrices
            if ( tvFF )
                mod$FF[mod$JFF[,-3,drop=FALSE]] <- mod$X[i,mod$JFF[,3]]
            if ( tvV ) {
                mod$V[mod$JV[,-3,drop=FALSE]] <- mod$X[i,mod$JV[,3]]
                tmp <- La.svd(mod$V,nu=0)
                Uv <- t(tmp$vt); Dv <- sqrt(tmp$d)
                Dv.inv <- 1/Dv; Dv.inv[abs(Dv.inv)==Inf] <- 0
                sqrtVinv <- Dv.inv * tmp$vt
            }
            if ( tvGG )
                mod$GG[mod$JGG[,-3,drop=FALSE]] <- mod$X[i,mod$JGG[,3]]
            if ( tvW ) {
                mod$W[mod$JW[,-3,drop=FALSE]] <- mod$X[i,mod$JW[,3]]
                svdW <- La.svd(mod$W,nu=0)
                sqrtW <- sqrt(svdW$d) * svdW$vt # t()%*%() = W
            }
            if ( tvFV )
                tF.Vinv <- t(mod$FF) %*% crossprod(sqrtVinv)

            if (!any(whereNA <- is.na(y[i, ]))) { ## No missing values

                ## prior
                a[i,] <- mod$GG %*% m[i,]
                tmp <- La.svd(rbind( D.C[i,]*t(mod$GG%*%U.C[[i]]), sqrtW ), nu=0)
                U.R[[i]] <- t(tmp$vt)
                D.R[i,] <- tmp$d
                ## one-step forecast
                f[i,] <- mod$FF %*% a[i,]
                ## posterior
                D.Rinv <- 1/D.R[i,]
                D.Rinv[abs(D.Rinv)==Inf] <- 0
                tmp <- La.svd(rbind(sqrtVinv %*% mod$FF %*% U.R[[i]],
                                    diag(x=D.Rinv,nrow=length(D.Rinv))), nu=0)
                U.C[[i+1]] <- U.R[[i]] %*% t(tmp$vt)
                foo <- 1/tmp$d; foo[abs(foo)==Inf] <- 0
                D.C[i+1,] <- foo
                m[i+1,] <- a[i,] + crossprod(D.C[i+1,]*t(U.C[[i+1]])) %*%
                    tF.Vinv %*% as.matrix(y[i,]-f[i,])

            } else {
                if (all(whereNA)) { ## All components missing

                    ## prior & posterior
                    m[i+1,] <- a[i,] <- mod$GG %*% m[i,]
                    tmp <- La.svd(rbind( D.C[i,]*t(mod$GG%*%U.C[[i]]), sqrtW ), nu=0)
                    U.C[[i+1]] <- U.R[[i]] <- t(tmp$vt)
                    D.C[i+1,] <- D.R[i,] <- tmp$d
                    ## one-step forecast
                    f[i,] <- mod$FF %*% a[i,]

                } else { ## Some components missing

                    good <- !whereNA
                    tmp <- La.svd(mod$V[good, good], nu=0)
                    Dv <- sqrt(tmp$d)
                    Dv.inv <- 1/Dv; Dv.inv[abs(Dv.inv)==Inf] <- 0
                    sqrtVinvTMP <- Dv.inv * tmp$vt
                    tF.VinvTMP <- t(mod$FF[good,,drop=FALSE]) %*% crossprod(sqrtVinvTMP)
                    ## prior
                    a[i,] <- mod$GG %*% m[i,]
                    tmp <- La.svd(rbind( D.C[i,]*t(mod$GG%*%U.C[[i]]), sqrtW ), nu=0)
                    U.R[[i]] <- t(tmp$vt)
                    D.R[i,] <- tmp$d
                    ## one-step forecast
                    f[i,] <- mod$FF %*% a[i,]
                    ## posterior
                    D.Rinv <- 1/D.R[i,]
                    D.Rinv[abs(D.Rinv)==Inf] <- 0
                    tmp <- La.svd(rbind(sqrtVinvTMP %*% mod$FF[good,,drop=FALSE] %*% U.R[[i]],
                                        diag(x=D.Rinv,nrow=length(D.Rinv))), nu=0)
                    U.C[[i+1]] <- U.R[[i]] %*% t(tmp$vt)
                    foo <- 1/tmp$d; foo[abs(foo)==Inf] <- 0
                    D.C[i+1,] <- foo
                    m[i+1,] <- a[i,] + crossprod(D.C[i+1,]*t(U.C[[i+1]])) %*%
                        tF.VinvTMP %*% as.matrix(y[i,good]-f[i,good])
                }
            }
        }

        ans <- list(m=m,U.C=U.C,D.C=D.C,a=a,U.R=U.R,D.R=D.R,f=f)
    }

    ans$m <- drop(ans$m); ans$a <- drop(ans$a); ans$f <- drop(ans$f)
    attributes(ans$f) <- yAttr
    if (!is.null(ytsp)) {
        tsp(ans$a) <- ytsp
        tsp(ans$m) <- c(ytsp[1] - 1/ytsp[3], ytsp[2:3])
        class(ans$a) <- class(ans$m) <- if (length(mod$m0) > 1) c("mts","ts") else "ts"
    }
    if (!(is.null(timeNames) && is.null(stateNames)))
        if (is.matrix(ans$a))
        {
            dimnames(ans$a) <- list(timeNames, stateNames)
            dimnames(ans$m) <- list(if(is.null(timeNames)) NULL else c("",timeNames),
                                    stateNames)
        }
        else
            if (!is.null(timeNames))
            {
                names(ans$a) <- timeNames
                names(ans$m) <- c("", timeNames)
            }
    if (simplify)
        ans <- c(mod=list(mod1), ans)
    else
    {
        attributes(y) <- yAttr
        ans <- c(y=list(y), mod=list(mod1), ans)
    }
    class(ans) <- "dlmFiltered"
    return(ans)
}

dlmSmooth <- function(y, ...)
    UseMethod("dlmSmooth", y)

dlmSmooth.default <- function(y, mod, ...)
{
    dlmSmooth(dlmFilter(y, mod, ...), ...)
}

dlmSmooth.dlmFiltered <- function(y, ..., debug = FALSE)
{
    big <- 1 / sqrt(.Machine$double.eps)
    mod <- c(y[match(c("m", "U.C", "D.C", "a", "U.R", "D.R"),names(y))],
             y$mod[match(c("GG", "W", "JGG", "JW", "X"), names(y$mod))])
    mAttr <- attributes(mod$m)
    mod$m <- as.matrix(mod$m)
    mod$a <- as.matrix(mod$a)
    if (!debug) {
        ## define flags for time-varying components
        if (is.null(mod$JGG))
            tvGG <- FALSE
        else {
            tvGG <- TRUE
            nz <- mod$JGG != 0
            mod$JGG <- cbind(row(mod$JGG)[nz], col(mod$JGG)[nz], mod$JGG[nz]) - 1
            storage.mode(mod$JGG) <- "integer"
        }
        if (is.null(mod$JW))
            tvW <- FALSE
        else {
            tvW <- TRUE
            nz <- mod$JW != 0
            mod$JW <- cbind(row(mod$JW)[nz], col(mod$JW)[nz], mod$JW[nz]) - 1
            storage.mode(mod$JW) <- "integer"
        }
        if (tvGG || tvW) {
            ans <- .Call("dlmSmooth", mod, tvGG, tvW, big, PACKAGE="dlm")
            names(ans) <- c("s", "U.S", "D.S")
        }
        else {
            ans <- .Call("dlmSmooth0", mod, big, PACKAGE="dlm")
            names(ans) <- c("s", "U.S", "D.S")
        }
        } else {
        if (is.null(mod$JGG))
            tvGG <- FALSE
        else {
            tvGG <- TRUE
            nz <- mod$JGG != 0
            mod$JGG <- cbind(row(mod$JGG)[nz], col(mod$JGG)[nz], mod$JGG[nz])
        }
        if (is.null(mod$JW))
            tvW <- FALSE
        else {
            tvW <- TRUE
            nz <- mod$JW != 0
            mod$JW <- cbind(row(mod$JW)[nz], col(mod$JW)[nz], mod$JW[nz])
        }
        n <- length(mod$U.R) # number of obs
        p <- NCOL(mod$m) # dimension of state vector
        s <- rbind(matrix(0,n,p), mod$m[n+1,])
        U.S <- vector("list", length=n+1)
        U.S[[n+1]] <- mod$U.C[[n+1]]
        D.S <- rbind(matrix(0,n,p), mod$D.C[n+1,])
        ## preliminary calculations, if possible (time-invariant case)
        if ( !tvW ) {
            tmp <- La.svd(mod$W,nu=0)
            Dw <- sqrt(tmp$d)
            Dw.inv <- pmin(1/Dw, big)
            sqrtWinv <- Dw.inv * tmp$vt # t()%*%() = W^(-1)
        }
        if (n > 0)
            for (i in n:1)
            {
                ## set relevant time-varying matrices
                if ( tvGG )
                    mod$GG[mod$JGG[,-3,drop=FALSE]] <- mod$X[i,mod$JGG[,3]]
                if ( tvW ) {
                    mod$W[mod$JW[,-3,drop=FALSE]] <- mod$X[i,mod$JW[,3]]
                    tmp <- La.svd(mod$W,nu=0)
                    Dw <- sqrt(tmp$d)
                    Dw.inv <- pmin(1/Dw, big)
                    sqrtWinv <- Dw.inv * tmp$vt # t()%*%() = W^(-1)
                }
                Dinv <- 1/mod$D.R[i,]; Dinv[abs(Dinv)==Inf] <- 0
                H <- crossprod(mod$D.C[i,]*t(mod$U.C[[i]])) %*%
                    t(mod$GG) %*% crossprod(Dinv*t(mod$U.R[[i]]))
                Dinv <- 1/mod$D.C[i,]
                Dinv[abs(Dinv)==Inf] <- 0
                tmp <- La.svd(rbind( sqrtWinv%*%mod$GG, Dinv*t(mod$U.C[[i]])), nu=0)
                Dinv <- 1/tmp$d
                Dinv[abs(Dinv)==Inf] <- 0
                tmp <- La.svd(rbind(Dinv*tmp$vt, D.S[i+1,]*t(H%*%U.S[[i+1]])))
                U.S[[i]] <- t(tmp$vt)
                D.S[i,] <- tmp$d
                s[i,] <- mod$m[i,] + H %*% (s[i+1,]-mod$a[i,])
            }
        ans <- list(s=s, U.S=U.S, D.S=D.S)
    }
    attributes(ans$s) <- mAttr
                                        #     if (!is.null(tsp(mod$m))) {
#         tsp(ans$s) <- tsp(mod$m)
#         class(ans$s) <- if (NCOL(ans$s) > 1) c("mts","ts") else "ts"
#     }
#     dimnames(ans$s) <- dimnames(mod$m)
    return(ans)
}


dlmBSample <- function(modFilt)
{
    eps <- .Machine$double.eps^.4
    mod <- c(modFilt[match(c("m", "U.C", "D.C", "a", "U.R", "D.R"),names(modFilt))],
             modFilt$mod[match(c("GG", "W", "JGG", "JW", "X"), names(modFilt$mod))])
    n <- length(mod$U.R) # number of obs
    p <- NCOL(mod$m) # dimension of state vector
    mtsp <- tsp(mod$m)
    if (p==1) {
        dim(mod$m) <- c(n+1, 1)
        dim(mod$a) <- c(n, 1)
    }
    if (is.null(mod$JGG))
        tvGG <- FALSE
    else {
        tvGG <- TRUE
        nz <- mod$JGG != 0
        mod$JGG <- cbind(row(mod$JGG)[nz], col(mod$JGG)[nz], mod$JGG[nz])
    }
    if (is.null(mod$JW))
        tvW <- FALSE
    else {
        tvW <- TRUE
        nz <- mod$JW != 0
        mod$JW <- cbind(row(mod$JW)[nz], col(mod$JW)[nz], mod$JW[nz])
    }
    tvGW <- tvGG || tvW
    theta <- matrix(0,n+1,p)
    ## preliminary calculations, if possible (time-invariant case)
    if ( !tvW ) {
        tmp <- La.svd(mod$W,nu=0)
        Dw <- sqrt(tmp$d)
        Dw <- pmax(Dw, eps)
        Dw.inv <- 1/Dw
        sqrtWinv <- Dw.inv * tmp$vt # t()%*%() = W^(-1)
        if ( !tvGG ) tG.Winv <- t(mod$GG) %*% crossprod(sqrtWinv)
    }
    ## generate last theta
    theta[n+1,] <- mod$m[n+1,] + mod$U.C[[n+1]] %*% matrix(mod$D.C[n+1,]*rnorm(p))
    ## generate all the other theta's
    for (i in (n:1))
    {
        if ( tvGG )
            mod$GG[mod$JGG[,-3,drop=FALSE]] <- mod$X[i,mod$JGG[,3]]
        if ( tvW ) {
            mod$W[mod$JW[,-3,drop=FALSE]] <- mod$X[i,mod$JW[,3]]
            tmp <- La.svd(mod$W,nu=0)
            Dw <- sqrt(tmp$d)
            Dw <- pmax(Dw, eps)
            Dw.inv <- 1/Dw
            sqrtWinv <- Dw.inv * tmp$vt # t()%*%() = W^(-1)
        }
        if ( tvGW )
            tG.Winv <- t(mod$GG) %*% crossprod(sqrtWinv)
        D.inv <- 1/mod$D.C[i,]; D.inv[abs(D.inv)==Inf] <- 0
        tmp <- La.svd(rbind(sqrtWinv %*% mod$GG %*% mod$U.C[[i]],
                            diag(x=D.inv,nrow=length(D.inv))), nu=0)
        U.H <- mod$U.C[[i]] %*% t(tmp$vt)
        D.H <- 1/tmp$d; D.H[abs(D.H)==Inf] <- 0
        h <- mod$m[i,] + crossprod(D.H*t(U.H)) %*%
            tG.Winv %*% (t(theta[i+1,,drop=F])-mod$a[i,])
        theta[i,] <- h + U.H %*% matrix(D.H*rnorm(p))
    }
    if (!is.null(mtsp))
    {
        theta <- drop(theta)
        tsp(theta) <- mtsp
        class(theta) <- if (p > 1) c("mts","ts") else "ts"
    }
    return(theta=theta)
}


rwishart <- function(df, p = nrow(SqrtSigma), Sigma,
                     SqrtSigma = diag(p))
{
    ## generate a Wishart-distributed matrix - from S-news, due to B. Venables
    ## note: Sigma = crossprod(SqrtSigma), and df must be integer
    if (!missing(Sigma))
    {
        ## compute SqrtSigma
        tmp <- svd(Sigma)
        SqrtSigma <- sqrt(tmp$d) * t(tmp$u)
    }
    if((Ident <- missing(SqrtSigma)) && missing(p))
        stop("either p, Sigma or SqrtSigma must be specified")
    Z <- matrix(0, p, p)
    diag(Z) <- sqrt(rchisq(p, df:(df-p+1)))
    if(p > 1)
    {
        pseq <- 1:(p-1)
        Z[rep(p*pseq, pseq) + unlist(lapply(pseq, seq))] <- rnorm(p*(p-1)/2)
    }
    if(Ident)
        crossprod(Z)
    else
        crossprod(Z %*% SqrtSigma)
}


dlmSvd2var <- function(u, d)
{
    if (is.matrix(u)) {
        if ( nrow(u) != length(d) || ncol(u) != (n <- length(d)) )
            stop("inconsistent dimensions")
        return(tcrossprod(rep(d, each = n) * u))
    }
    if (is.list(u)) {
        if ( length(u) != NROW(d) )
            stop("length of 'u' must be equal to the number of rows of 'd'")
        n <- NCOL(d)
        return(lapply(seq(along = u), function(i)
                      tcrossprod(rep(d[i,], each = n) * u[[i]])))

    }
    stop("wrong argument 'u'")
}

dlmForecast <- function(mod, nAhead=1, method=c("plain","svd"), sampleNew=FALSE) {
    method <- match.arg(method)

    if (is.dlmFiltered(mod)) {
        modFuture <- mod$mod
        lastObsIndex <- NROW(mod$m)
        modFuture$C0 <- with(mod, dlmSvd2var(U.C[[lastObsIndex]], D.C[lastObsIndex,]))
        if (is.ts(mod$m))
            modFuture$m0 <- window(mod$m, start=end(mod$m))
        else {
            modFuture$m0 <- window(mod$m, start=lastObsIndex)
            tsp(modFuture$m0) <- NULL
        }
        mod <- modFuture
    }

    if (! (is.null(mod$JFF) && is.null(mod$JV) && is.null(mod$JGG) && is.null(mod$JW)))
        stop("dlmForecast only works with constant models")

    ytsp <- tsp(mod$m0)
    p <- length(mod$m0)
    m <- nrow(mod$FF)
    a <- rbind(mod$m0, matrix(0,nAhead,p))
    R <- vector("list",nAhead+1)
    R[[1]] <- mod$C0
    f <- matrix(0,nAhead,m)
    Q <- vector("list", nAhead)
    for (it in 1:nAhead) {
        a[it+1,] <- mod$GG %*% a[it,]
        R[[it+1]] <- mod$GG %*% R[[it]] %*% t(mod$GG) + mod$W
        f[it,] <- mod$FF %*% a[it+1,]
        Q[[it]] <- mod$FF %*% R[[it+1]] %*% t(mod$FF) + mod$V
    }
    a <- a[-1,,drop=FALSE]
    R <- R[-1]
    if ( sampleNew ) {
        newStates <- vector("list", sampleNew)
        newObs <- vector("list", sampleNew)
        newS <- matrix(0, nAhead, p)
        newO <- matrix(0, nAhead, m)
        tmp <- La.svd(mod$V,nu=0)
        Ut.V <- tmp$vt; D.V <- sqrt(tmp$d)
        tmp <- La.svd(mod$W,nu=0)
        Ut.W <- tmp$vt; D.W <- sqrt(tmp$d)
        for (i in 1:sampleNew) {
            tmp <- La.svd(R[[1]],nu=0)
            newS[1,] <- crossprod(tmp$vt, rnorm(p, sd=sqrt(tmp$d))) + a[1,]
            newO[1,] <- crossprod(Ut.V, rnorm(m, sd=D.V)) + mod$FF %*% newS[1,]
            if ( nAhead > 1 )
                for (it in 2:nAhead) {
                    newS[it,] <- crossprod(Ut.W, rnorm(p, sd=D.W)) + mod$GG %*% newS[it-1,]
                    newO[it,] <- crossprod(Ut.V, rnorm(m, sd=D.V)) + mod$FF %*% newS[it,]
                }
            newStates[[i]] <- newS
            newObs[[i]] <- newO
        }
        if (!is.null(ytsp)) {
            a <- ts(a, start = ytsp[2] + 1/ytsp[3], frequency = ytsp[3])
            f <- ts(f, start = ytsp[2] + 1/ytsp[3], frequency = ytsp[3])
            newStates <- lapply(newStates, function(x)
                                ts(x, start = ytsp[2] + 1/ytsp[3], frequency = ytsp[3]))
            newObs <- lapply(newObs, function(x)
                             ts(x, start = ytsp[2] + 1/ytsp[3], frequency = ytsp[3]))
        }
        ans <- list(a=a, R=R, f=f, Q=Q, newStates=newStates, newObs=newObs)
    } else {
        if (!is.null(ytsp)) {
            a <- ts(a, start = ytsp[2] + 1/ytsp[3], frequency = ytsp[3])
            f <- ts(f, start = ytsp[2] + 1/ytsp[3], frequency = ytsp[3])
        }
        ans <- list(a=a, R=R, f=f, Q=Q)
    }


    return(ans)
}

###### One-step forecast errors
residuals.dlmFiltered <- function(object, ...,
                                  type=c("standardized", "raw"), sd=TRUE) {
    if (is.null(object$y))
        stop("\'object\' argument has no \'y\' component")
    type <- match.arg(type)
    if (is.null(object$mod$JFF)) tvFF <- FALSE else tvFF <- TRUE
    if (is.null(object$mod$JV)) tvV <- FALSE else tvV <- TRUE
    FF <- object$mod$FF
    if (!( tvFF || tvV )) { ## constant model
        f <- object$a %*% t(FF)
        res <- drop(object$y - f) # one-step forecasting errors
        if (sd || (type == "standardized")) {
            V <- object$mod$V
            SD <- drop(t(sqrt(sapply(seq(along=object$U.R),
                                     function(i)
                                     diag(crossprod(object$D.R[i,] *
                                                    t(FF%*%object$U.R[[i]])) + V)))))
        }
    } else
    if ( !tvFF ) { ## only V time-varying
        f <- object$a %*% t(FF)
        res <- drop(object$y - f) # one-step forecasting errors
        if (sd || (type == "standardized")) {
            nz <- object$mod$JV != 0
            JV <- cbind(row(object$mod$JV)[nz], col(object$mod$JV)[nz],
                        object$mod$JV[nz])
            V <- object$mod$V
            getSD <- function(i) {
                V[JV[,-3,drop=FALSE]] <- object$mod$X[i,JV[,3]]
                diag(crossprod(object$D.R[i,] * t(FF%*%object$U.R[[i]])) + V)
            }
            SD <- drop(t(sqrt(sapply(seq(along=object$U.R), getSD))))
        }
    } else
    if ( !tvV ) { ## only FF time-varying
        if (!(sd || (type == "standardized"))) {
            nz <- object$mod$JFF != 0
            JFF <- cbind(row(object$mod$JFF)[nz], col(object$mod$JFF)[nz],
                         object$mod$JFF[nz])
            getFore <- function(i) {
                FF[JFF[,-3,drop=FALSE]] <- object$mod$X[i,JFF[,3]]
                FF %*% object$a[i,]
            }
            f <- drop(t(sapply(seq(along=object$U.R), getFore)))
            res <- drop(object$y - f) # one-step forecasting errors
        } else {
            nz <- object$mod$JFF != 0
            JFF <- cbind(row(object$mod$JFF)[nz], col(object$mod$JFF)[nz],
                         object$mod$JFF[nz])
            V <- object$mod$V
            getBoth <- function(i) {
                FF[JFF[,-3,drop=FALSE]] <- object$mod$X[i,JFF[,3]]
                c(FF %*% object$a[i,],
                  diag(crossprod(object$D.R[i,] * t(FF%*%object$U.R[[i]])) + V))
            }
            tmp <- t(sapply(seq(along=object$U.R), getBoth))
            m <- ncol(tmp) / 2
            res <- drop(object$y - tmp[,1:m])
            SD <- drop(sqrt(tmp[,-(1:m)]))
        }
    } else { ## both FF and V time-varying
        if (!(sd || (type == "standardized"))) {
            nz <- object$mod$JFF != 0
            JFF <- cbind(row(object$mod$JFF)[nz], col(object$mod$JFF)[nz],
                         object$mod$JFF[nz])
            getFore <- function(i) {
                FF[JFF[,-3,drop=FALSE]] <- object$mod$X[i,JFF[,3]]
                FF %*% object$a[i,]
            }
            f <- drop(t(sapply(seq(along=object$U.R), getFore)))
            res <- drop(object$y - f) # one-step forecasting errors
        } else {
            nz <- object$mod$JFF != 0
            JFF <- cbind(row(object$mod$JFF)[nz], col(object$mod$JFF)[nz],
                         object$mod$JFF[nz])
            nz <- object$mod$JV != 0
            JV <- cbind(row(object$mod$JV)[nz], col(object$mod$JV)[nz],
                        object$mod$JV[nz])
            V <- object$mod$V
            getBoth <- function(i) {
                FF[JFF[,-3,drop=FALSE]] <- object$mod$X[i,JFF[,3]]
                V[JV[,-3,drop=FALSE]] <- object$mod$X[i,JV[,3]]
                c(FF %*% object$a[i,],
                  diag(crossprod(object$D.R[i,] * t(FF%*%object$U.R[[i]])) + V))
            }
            tmp <- t(sapply(seq(along=object$U.R), getBoth))
            m <- ncol(tmp) / 2
            res <- drop(object$y - tmp[,1:m])
            SD <- drop(sqrt(tmp[,-(1:m)]))
        }
    }

    if ( type == "standardized" )
        res <- res / SD
    if (sd) {
        if (is.ts(res)) attributes(SD) <- attributes(res) # makes a time series of SD
        return(list(res=res, sd=SD))
    } else
    return(res)
}

###### Diagnostic plots
tsdiag.dlmFiltered <- function (object, gof.lag = 10, ...) {
    stdres <- residuals(object, sd=FALSE)
    if ((ns <- NCOL(stdres)) == 1) {
        oldpar <- par(mfrow = c(3, 1))
        on.exit(par(oldpar))
        plot(stdres, type = "h", main = "Standardized Residuals", ylab = "")
        abline(h = 0)
        acf(stdres, plot = TRUE, main = "ACF of Residuals",
            na.action = na.pass)
        nlag <- gof.lag
        pval <- numeric(nlag)
        for (i in 1:nlag) pval[i] <- Box.test(stdres, i, type = "Ljung-Box")$p.value
        plot(1:nlag, pval, xlab = "lag", ylab = "p value",
             ylim = c(0, 1), main = "p values for Ljung-Box statistic")
        abline(h = 0.05, lty = 2, col = "blue")
    } else {
        ask <- dev.interactive()
        oldpar <- par(mfrow = c(3, 1), oma=c(0, 0, 2, 0), "ask")
        on.exit(par(oldpar))
        hasNames <- !is.null(nm <- attr(stdres,"dimnames")[[2]])
        for (j in 1:ns) {
            plot(stdres[,j], type = "h", main = "Standardized Residuals", ylab = "")
            abline(h = 0)
            if (ask) par(ask=FALSE)
            acf(stdres[,j], plot = TRUE, main = "ACF of Residuals",
                na.action = na.pass)
            nlag <- gof.lag
            pval <- numeric(nlag)
            for (i in 1:nlag) pval[i] <- Box.test(stdres[,j], i, type = "Ljung-Box")$p.value
            plot(1:nlag, pval, xlab = "lag", ylab = "p value",
                 ylim = c(0, 1), main = "p values for Ljung-Box statistic")
            abline(h = 0.05, lty = 2, col = "blue")
            mtext(if (hasNames) nm[j] else paste("Series",j), line=1, outer=TRUE)
            if (ask) par(ask=TRUE)
        }
    }
}

###### Generating a random DLM
dlmRandom <- function(m, p, nobs = 0, JFF, JV, JGG, JW)
{
    ### Assume for now that each of FF, V, GG, W is either fixed or
    ### time-varying in every entry
    FF <- matrix(rnorm(m*p),m,p)
    V <- rwishart(2*m, m)
    GGtrial <- matrix(rnorm(p*p),p,p)
    e <- eigen(GGtrial)
    if ((ab <- max(abs(e$values))) > 1) {
        r <- runif(1)
        GG <- with(e, Re(vectors %*% (r * values / ab * solve(vectors))))
    }
    else
        GG <- GGtrial
    W <- rwishart(2*p, p)
    m0 <- rep(0,p)
    C0 <- diag(nrow = p) * 100
    if (nobs > 0) {
        count <- 0
        if (hasArg(JGG) && JGG == TRUE) {
            tvGG <- TRUE
            JGG <- structure(1:(p*p), dim=dim(GG))
            count <- p * p
        }
        else {
            tvGG <- FALSE
            JGG <- NULL
        }
        if (hasArg(JW) && JW == TRUE) {
            tvW <- TRUE
            JW <- structure(count + 1:(p*p), dim=dim(W))
            count <- count + p * p
        }
        else {
            tvW <- FALSE
            JW <- NULL
            tmp <- La.svd(W,nu=0)
            Ut.W <- tmp$vt; D.W <- sqrt(tmp$d)
        }
        if (hasArg(JFF) && JFF == TRUE) {
            tvFF <- TRUE
            JFF <- structure(count + 1:(m*p), dim=dim(FF))
            count <- count + m * p
        }
        else {
            tvFF <- FALSE
            JFF <- NULL
        }
        if (hasArg(JV) && JV == TRUE) {
            tvV <- TRUE
            JV <- structure(count + 1:(m*m), dim=dim(V))
        }
        else {
            tvV <- FALSE
            JV <- NULL
            tmp <- La.svd(V,nu=0)
            Ut.V <- tmp$vt; D.V <- sqrt(tmp$d)
        }
        if (any(c(tvFF, tvV, tvGG, tvW))) {
            newStates <- matrix(0, nrow = nobs + 1, ncol = p)
            newObs <- matrix(0, nrow = nobs, ncol = m)
            X <- matrix(0, nrow = nobs,
                        ncol = m * p * tvFF + m * m * tvV +
                        p * p * tvGG + p * p * tvW)
            tmp <- La.svd(C0,nu=0)
            newStates[1,] <- crossprod(tmp$vt, rnorm(p, sd=sqrt(tmp$d)))
            for (it in 1:nobs) {
                count <- 0
                if (tvGG) {
                    GGtrial <- matrix(rnorm(p*p),p,p)
                    e <- eigen(GGtrial)
                    if ((ab <- max(abs(e$values))) > 1) {
                        r <- runif(1)
                        GG <- with(e, Re(vectors %*% (r * values / ab * solve(vectors))))
                    }
                    else
                        GG <- GGtrial
                    X[it, 1:(p*p)] <- GG
                    count <- p * p
                }
                if (tvW) {
                    W <- rwishart(2*p, p)
                    X[it, count + 1:(p*p)] <- W
                    count <- count + p * p
                    tmp <- La.svd(W,nu=0)
                    Ut.W <- tmp$vt; D.W <- sqrt(tmp$d)
                }
                if (tvFF) {
                    FF <- matrix(rnorm(m*p),m,p)
                    X[it, count + 1:(m*p)] <- FF
                    count <- count + m * p
                }
                if (tvV) {
                    V <- rwishart(2*m, m)
                    X[it, count + 1:(m*m)] <- V
                    tmp <- La.svd(V,nu=0)
                    Ut.V <- tmp$vt; D.V <- sqrt(tmp$d)
                }
                newStates[it + 1,] <- crossprod(Ut.W, rnorm(p, sd=D.W)) + GG %*% newStates[it,]
                newObs[it,] <- crossprod(Ut.V, rnorm(m, sd=D.V)) + FF %*% newStates[it+1,]
            }
            mod <- dlm(list(m0=m0, C0=C0, FF=FF, V=V, GG=GG, W=W, JFF=JFF, JV=JV,
                            JGG=JGG, JW=JW, X=X))
            ans <- list(mod = mod, theta = newStates[-1,,drop=FALSE], y = newObs)
        }
        else {
            mod <- dlm(list(m0=m0, C0=C0, FF=FF, V=V, GG=GG, W=W))
            tmp <- dlmForecast(mod, nAhead = nobs, sampleNew = 1)
            ans <- list(mod = mod, theta = tmp$newStates[[1]], y = tmp$newObs[[1]])
        }
    }
    else
        ans <- dlm(list(m0=m0, C0=C0, FF=FF, V=V, GG=GG, W=W))
    return(ans)
}

###### Utility functions for MCMC output analysis
mcmcSD <- function(x) {
    ## Monte Carlo standard deviation using Sokal's method
    msg <- "Numeric vector or matrix argument needed"
    if (!is.numeric(x))
        stop(msg)
    univariate <- function(x) {
        l <- floor(30*log10(length(x)))
        ac <- drop(acf(x, lag.max=l, plot=FALSE)$acf)
        tau <- cumsum(c(1, 2 * ac[-1]))
        k <- 0
        while ( (k < 3 * tau[k+1]) &&  (k < l)) k <- k+1
        tau <- tau[k+1]
        if (tau < 0)
            {
                tau <- 1
                warning("estimated s.d. may not be reliable")
            }
        return(sqrt(var(x) * tau / length(x)))
    }
    if (is.null(dim(x)))
        ans <- univariate(x)
    else
        if (is.matrix(x))
            ans <- apply(x, 2, univariate)
        else
            stop(msg)
    return(ans)
}

mcmcMean <- function(x, sd = TRUE)
{
    ## Ergodic means of mcmc output
    ## Estimated standard deviations of means using Sokal's method
    msg <- "Numeric vector or matrix argument needed"
    if (!is.numeric(x))
        stop(msg)
    if (v <- is.null(dim(x))) # univariate input
    {
        mn <- mean(x)
        nm <- deparse(substitute(x))
    }
    else
        if (is.matrix(x)) # multivariate input
        {
            mn <- colMeans(x)
            nm <- colnames(x)
            if ( is.null(nm) )
                nm <- paste(deparse(substitute(x)), 1:NCOL(x), sep='.')
        }
        else
            stop(msg)
    if (sd) {
        univariateSD <- function(x) {
            l <- floor(30*log10(length(x)))
            ac <- acf(x, lag.max=l, plot=FALSE)$acf
            tau <- cumsum(c(1, 2 * ac[-1]))
            k <- 0
            while ( (k < 3 * tau[k+1]) &&  (k < l)) k <- k+1
            tau <- tau[k+1]
            return(sqrt(var(x) * tau / length(x)))
        }
        if ( v )
            sd <- univariateSD(x)
        else
            sd <- apply(x, 2, univariateSD)
        ans <- rbind(mn, sd)
        dimnames(ans) <- list(c("mean", "sd"), nm)
        class(ans) <- "mcmcMean"
        return(ans)
    } else {
        if ( !v ) names(mn) <- nm
        return(mn)
    }
}

mcmcMeans <- mcmcMean

print.mcmcMean <- function(x, digits = getOption("digits"), ...)
{
    ans <- format(x, digits = 3)
    ans[1, ] <- sapply(ans[1, ], function(x) paste("", x))
    ans[2, ] <- sapply(ans[2, ], function(x) paste("(", x, ")", sep = ""))
    dn <- dimnames(ans)
    dn[[1]] <- rep("", 2)
    if (is.null(dn[[2]]))
        dn[[2]] <- paste('V', 1:dim(ans)[2], sep='.')
    dn[[2]] <- paste(substring("      ", 1, (nchar(ans[2, ]) -
        nchar(dn[[2]]))%/%2), dn[[2]])
    dn[[2]] <- paste(dn[[2]], substring("      ", 1, (nchar(ans[2,
        ]) - nchar(dn[[2]]))%/%2))
    dimnames(ans) <- dn
    print(ans, quote = FALSE)
    return(x)
}

ergMean <- function(x, m = 1)
{
    ### ergodic means
    if (hasArg(m)) m <- max(1, round(m))
    n <- NROW(x)
    if ( m > n )
        stop("Need m <= n")
    if ( is.null(dm <- dim(x)) || dm[2] == 1 )
    {
        ## univariate
        if ( m == 1 )
            ans <- cumsum(x) / 1:n
        else
            if ( m == n )
                ans <- mean(x)
            else
                ans <- cumsum(c(sum(x[1:m]), x[(m+1):n])) / m:n
    } else {
        if ( length(dm) == 2 )
        {
            ## matrix "x" - multivariate
            nm <- colnames(x)
            if ( is.null(nm) )
                nm <- paste(deparse(substitute(x)), 1:NCOL(x), sep='.')
            if ( m == 1 )
                ans <- apply(x, 2, cumsum) / 1:n
            else
                if ( m == n )
                    ans <- matrix(colMeans(x), nrow = 1)
                else
                    ans <- apply(rbind(colSums(x[1:m,]), x[(m+1):n,]), 2, cumsum) / m:n
            colnames(ans) <- nm
        }
        else
            stop("\'x\' must be a vector or a matrix")
    }
    return(ans)
}


###### drop first element of a ts or mts retaining the class
dropFirst <- function(x)
{
    st <- start(x) + c(0, 1)
    freq <- frequency(x)
    newStart <- c(st[1], st[2] %% freq) + c(st[2] %/% freq, 0)
    y <- window(x, start = newStart)
    if (is.null(tsp(x)))
        attr(y, "tsp") <- NULL
    return(y)
}

######
###### Gibbs sampler for "d-inverse-gamma" model
######
dlmGibbsDIG <- function(y, mod, a.y, b.y, a.theta, b.theta, shape.y, rate.y,
                        shape.theta, rate.theta, n.sample = 1,
                        thin = 0, ind, save.states = TRUE,
                        progressBar = interactive())
##################################################################################
##################################################################################
### Gibbs sampler for the 'd-inverse-gamma' model                              ###
### Constant DLMs and univariate observations only                             ###
###                                                                            ###
### y       : data (vector or univariate time series).                         ###
### mod     : a dlm model for the data, with a diagonal 'W' component.         ###
### a.y     : prior mean of the observation precision.                         ###
### b.y     : prior variance of the observation precision.                     ###
### a.theta : vector of prior mean(s) of the system precision(s);              ###
###           recycled if needed.                                              ###
### b.theta : vector of prior variance(s) of the system precision(s);          ###
###           recycled if needed.                                              ###
### shape.y, rate.y : shape and rate parameters of the prior gamma             ###
###           distribution of the observation precision. Can be specified      ###
###           in alternative to 'a' and 'b'.                                   ###
### shape.theta, rate.theta : vectors of shape and rate parameters of the      ###
###           prior distributions of the system precision(s). Can be           ###
###           specified in alternative to 'alpha' and 'beta'.                  ###
### n.sample : number of simulated values in the output.                       ###
### thin    : number of sweeps to discard between each pair of returned        ###
###           draws.                                                           ###
### ind     : vector of indices. If specified, the sampler will only draw      ###
###           the diagonal elements of 'W' having the specified indices.       ###
###           Useful when some of the system variances are zero.               ###
### save.states : if TRUE, the generated states will be returned together      ###
###           with the generated parameter values.                             ###
### progressBar : if TRUE, a text progress bar will be displayed               ###
###           during execution                                                 ###
###                                                                            ###
### Value:                                                                     ###
### A list with components 'dV', 'dW', 'theta' (only if 'save.states' is       ###
### TRUE). 'dV' contains the generated observation variances, 'dW' the         ###
### generated system variances, 'theta' the generated states.                  ###
##################################################################################
##################################################################################
{
    msg1 <- "Either \"a.y\" and \"b.y\" or \"shape.y\" and \"rate.y\" must be specified"
    msg2 <- "Unexpected length of \"shape.y\" and/or \"rate.y\""
    msg3 <- "Unexpected length of \"a.y\" and/or \"b.y\""
    msg4 <- paste("Either \"a.theta\" and \"b.theta\" or \"shape.theta\"",
                  "and \"rate.theta\" must be specified")
    msg5 <- "Unexpected length of \"shape.theta\" and/or \"rate.theta\""
    msg6 <- "Unexpected length of \"a.theta\" and/or \"b.theta\""
    msg7 <- "\"thin\" must be a nonnegative integer"
    msg8 <- "multivariate observations are not allowed"
    msg9 <- "inadmissible value of \"ind\""
    if ( NCOL(y) > 1 )
        stop(msg8)
    r <- ncol(mod$FF)
    if ( hasArg(ind) ) {
        ind <- unique(as.integer(ind))
        s <- 1:r
        if ( !all(ind %in% s) )
            stop(msg9)
        perm <- s[c(ind, s[ !(s %in% ind)])]
        FF(mod) <- mod$FF[, perm, drop = FALSE]
        GG(mod) <- mod$GG[perm, perm, drop = FALSE]
        W(mod) <- mod$W[perm, perm, drop = FALSE]
        p <- length(ind)
    }
    else {
        perm <- ind <- 1 : r
        p <- r
    }
    nobs <- NROW(y)
    if ( is.numeric(thin) && (thin <- as.integer(thin)) >= 0 )
    {
        every <- thin + 1
        mcmc <- n.sample * every
    }
    else
        stop(msg7)
    ## check hyperpriors for precision of 'y'
    if ( !hasArg(a.y) )
        if ( !hasArg(shape.y) ) stop(msg1)
        else
            if ( !hasArg(rate.y) ) stop(msg1)
            else
            {
                ## check length of shape.y and rate.y
                if (!all(c(length(shape.y), length(rate.y)) == 1))
                    warning(msg2)
            }
    else
        if ( !hasArg(b.y) ) stop(msg1)
        else
        {
            if (!all(c(length(a.y), length(b.y)) == 1))
                warning(msg3)
            shape.y <- a.y^2 / b.y
            rate.y <- a.y / b.y
        }
    ## check hyperpriors for precision(s) of 'theta'
    if ( !hasArg(a.theta) )
        if ( !hasArg(shape.theta) ) stop(msg4)
        else
            if ( !hasArg(rate.theta) ) stop(msg4)
            else
            {
                ## check length of shape.theta and rate.theta
                if (!all(c(length(shape.theta), length(rate.theta)) %in% c(1,p)))
                    warning(msg5)
            }
    else
        if ( !hasArg(b.theta) ) stop(msg4)
        else
        {
            if (!all(c(length(a.theta), length(b.theta)) %in% c(1,p)))
                warning(msg6)
            shape.theta <- a.theta^2 / b.theta
            rate.theta <- a.theta / b.theta
        }
    shape.y <- shape.y + 0.5 * nobs
    shape.theta <- shape.theta + 0.5 * nobs
    shape.theta <- rep(shape.theta, length.out = p)
    rate.theta <- rep(rate.theta, length.out = p)
    theta <- matrix(0, nobs + 1, r)
    if ( save.states )
        gibbsTheta <- array(0, dim = c(nobs + 1, r, n.sample))
    gibbsV <- vector("numeric", n.sample)
    gibbsW <- matrix(0, nrow = n.sample, ncol = p)
    it.save <- 0
    if (progressBar) pb <- txtProgressBar(0, mcmc, style = 3)
    for (it in 1:mcmc)
    {
        if (progressBar) setTxtProgressBar(pb, it)
        ## generate states - FFBS
        modFilt <- dlmFilter(y, mod, simplify=TRUE)
        theta[] <- dlmBSample(modFilt)
        ## generate V
        y.center <- y - tcrossprod(theta[-1,,drop=FALSE], mod$FF)
        SSy <- drop(crossprod(y.center))
        mod$V[] <- 1 / rgamma(1, shape = shape.y,
                              rate = rate.y + 0.5 * SSy)
        ## generate W
        theta.center <- theta[-1,,drop=FALSE] -
            tcrossprod(theta[-(nobs + 1),,drop=FALSE], mod$GG)
        SStheta <- drop(sapply( 1 : p, function(i) crossprod(theta.center[,i])))
        SStheta <- colSums((theta[-1,1:p,drop=FALSE] -
                            tcrossprod(theta[-(nobs + 1),,drop=FALSE],mod$GG)[,1:p])^2)
        diag(mod$W)[1:p] <-
            1 / rgamma(p, shape = shape.theta, rate = rate.theta + 0.5 * SStheta)
        ## save
        if ( !(it %% every) )
        {
            it.save <- it.save + 1
            if ( save.states )
                gibbsTheta[,,it.save] <- theta
            gibbsV[it.save] <- diag(mod$V)
            gibbsW[it.save,] <- diag(mod$W)[1:p]
        }
    }
    colnames(gibbsW) <- paste("W", ind, sep = '.')
    if (progressBar) close(pb)
    if ( save.states )
        return(list(dV = gibbsV, dW = gibbsW,
                    theta = gibbsTheta[, order(perm), , drop = FALSE]))
    else
        return(list(dV = gibbsV, dW = gibbsW))
}

####$$$$ dlm\R/zzz.R

.onUnload <- function(libpath) {
    library.dynam.unload("dlm", libpath)
}
####$$$$ dlm\src/arms-R.c
/* adaptive rejection metropolis sampling                                 */
/* original C code by Wally Gilks <Wally.Gilks@mrc-bsu.cam.ac.uk>         */
/* R port by Giovanni Petris <GPetris@uark.edu>                           */

/* *********************************************************************** */

#include           <R.h>
#include           <Rmath.h>  /* for RNG interface */
#include           <Rdefines.h>
#include           <stdio.h>
#include           <math.h>
#include           <stdlib.h>

/* *********************************************************************** */

typedef struct point {    /* a point in the x,y plane */
  double x,y;             /* x and y coordinates */
  double ey;              /* exp(y-ymax+YCEIL) */
  double cum;             /* integral up to x of rejection envelope */
  int f;                  /* is y an evaluated point of log-density */
  struct point *pl,*pr;   /* envelope points to left and right of x */
} POINT;

/* *********************************************************************** */

typedef struct envelope {  /* attributes of the entire rejection envelope */
  int cpoint;              /* number of POINTs in current envelope */
  int npoint;              /* max number of POINTs allowed in envelope */
  int *neval;              /* number of function evaluations performed */
  double ymax;             /* the maximum y-value in the current envelope */
  POINT *p;                /* start of storage of envelope POINTs */
  double *convex;          /* adjustment for convexity */
} ENVELOPE;

/* *********************************************************************** */

typedef struct metropolis { /* for metropolis step */
  int on;            /* whether metropolis is to be used */
  double xprev;      /* previous Markov chain iterate */
  double yprev;      /* current log density at xprev */
} METROPOLIS;

/* *********************************************************************** */

#define XEPS  0.00001            /* critical relative x-value difference */
#define YEPS  0.1                /* critical y-value difference */
#define EYEPS 0.001              /* critical relative exp(y) difference */
#define YCEIL 50.                /* maximum y avoiding overflow in exp(y) */

/* *********************************************************************** */

/* declarations for functions defined in this file */

SEXP arms(SEXP bounds, SEXP myldens, SEXP yprev, SEXP size, SEXP rho);

int initial (double *xinit, int ninit, double xl, double xr, int npoint,
	     SEXP myldens, ENVELOPE *env, double *convex, int *neval,
             METROPOLIS *metrop, SEXP rho);

void sample(ENVELOPE *env, POINT *p);

void invert(double prob, ENVELOPE *env, POINT *p);

int test(ENVELOPE *env, POINT *p, SEXP myldens, METROPOLIS *metrop, SEXP rho);

int update(ENVELOPE *env, POINT *p, SEXP myldens, METROPOLIS *metrop, SEXP rho);


void cumulate(ENVELOPE *env);

int meet (POINT *q, ENVELOPE *env, METROPOLIS *metrop);

double area(POINT *q);

double expshift(double y, double y0);

double logshift(double y, double y0);

double perfunc(SEXP myldens, ENVELOPE *env, double x, SEXP rho);

void display(FILE *f, ENVELOPE *env);

double u_random();

/* *********************************************************************** */
# define NINIT 4
SEXP arms (SEXP bounds, SEXP myldens, SEXP yprev, SEXP size, SEXP rho) {

/* to perform derivative-free adaptive rejection sampling with metropolis step */

/* bounds      : boundaries of the support of the density */
/* myldens     : R function to evaluate log density */
/* yprev       : previous value from markov chain */
/* size        : number of sampled values to be obtained */
/* rho         : R environment in which the logdensity is evaluated */

    double xl, xr, xinit[NINIT], convex=1.0;
    int i, npoint=100, nsamp, neval, err;
    SEXP ysamp;         /* sampled values */
    ENVELOPE *env;      /* rejection envelope */
    POINT pwork;        /* a working point, not yet incorporated in envelope */
    int msamp=0;        /* the number of x-values currently sampled */
    METROPOLIS *metrop; /* to hold bits for metropolis step */

    nsamp = INTEGER(size)[0];
    xl = REAL(bounds)[0];
    xr = REAL(bounds)[1];
    for (i=0; i<NINIT; i++)
        xinit[i] = xl + (i + 1.0) * (xr - xl)/(NINIT + 1.0);
    PROTECT( ysamp = NEW_NUMERIC(nsamp) );
        

    /* set up space required for envelope */
    /* env = (ENVELOPE *)malloc(sizeof(ENVELOPE)); */
    env = (ENVELOPE *)Calloc(1, ENVELOPE);
    if(env == NULL){
        /* insufficient space */
        error("insufficient space");
    }

    /* start setting up metropolis struct */
    /* metrop = (METROPOLIS *)malloc(sizeof(METROPOLIS)); */
    metrop = (METROPOLIS *)Calloc(1, METROPOLIS);
    if(metrop == NULL){
        /* insufficient space */
         error("insufficient space");
    }
    metrop->on = 1; 

    /* set up initial envelope */
    err = initial(xinit,NINIT,xl,xr,npoint,myldens,env,&convex,
                  &neval,metrop,rho);
    if(err) 
        error("Can set err...");

    /* finish setting up metropolis struct (can only do this after */
    /* setting up env) */
    if(metrop->on){
        if((REAL(yprev)[0] < xl) || (REAL(yprev)[0] > xr)){
            /* previous markov chain iterate out of range */
            error("previous markov chain iterate out of range");
        }
        metrop->xprev = REAL(yprev)[0];
        metrop->yprev = perfunc(myldens,env,REAL(yprev)[0],rho);
    }

    /* now do adaptive rejection */
    do {
        /* sample a new point */
        sample (env,&pwork);

        /* perform rejection (and perhaps metropolis) tests */
        i = test(env,&pwork,myldens,metrop,rho);
        if(i == 1){
            /* point accepted */
            REAL(ysamp)[msamp++] = pwork.x;
        } else if (i != 0) {
            /* envelope error - violation without metropolis */
            error("envelope error - violation without metropolis");
        }  
    } while (msamp < nsamp);

    /* nsamp points now sampled */

    /* free space */
    Free(env->p);
    Free(env);
    Free(metrop);

    UNPROTECT(1);
    return ysamp;
}

/* *********************************************************************** */

int initial (double *xinit, int ninit, double xl, double xr, int npoint,
	     SEXP myldens, ENVELOPE *env, double *convex, int *neval,
             METROPOLIS *metrop, SEXP rho)

/* to set up initial envelope */

/* xinit        : initial x-values */
/* ninit        : number of initial x-values */
/* xl,xr        : lower and upper x-bounds */
/* npoint       : maximum number of POINTs allowed in envelope */
/* myldens      : R function to evaluate log density */
/* *env         : rejection envelope attributes */
/* *convex      : adjustment for convexity */
/* *neval       : current number of function evaluations */
/* *metrop      : for metropolis step */
/* rho          : R environment in which the logdensity is evaluated */

{
  int i,j,k,mpoint;
  POINT *q;

  if(ninit<3){
    /* too few initial points */
    return 1001;
  }

  mpoint = 2*ninit + 1;
  if(npoint < mpoint){
    /* too many initial points */
    return 1002;
  }

  if((xinit[0] <= xl) || (xinit[ninit-1] >= xr)){
    /* initial points do not satisfy bounds */
    return 1003;
  }

  for(i=1; i<ninit; i++){
    if(xinit[i] <= xinit[i-1]){
      /* data not ordered */
      return 1004;
    }
  }

  if(*convex < 0.0){
    /* negative convexity parameter */
    return 1008;
  }

  /* copy convexity address to env */
  env->convex = convex;

  /* copy address for current number of function evaluations */
  env->neval = neval;
  /* initialise current number of function evaluations */
  *(env->neval) = 0;

  /* set up space for envelope POINTs */
  env->npoint = npoint;
  /* env->p = (POINT *)malloc(npoint*sizeof(POINT)); */
  env->p = (POINT *)Calloc(npoint, POINT);
  if(env->p == NULL){
    /* insufficient space */
    return 1006;
  }

  /* set up envelope POINTs */
  q = env->p;
  /* left bound */
  q->x = xl;
  q->f = 0;
  q->pl = NULL;
  q->pr = q+1;
  for(j=1, k=0; j<mpoint-1; j++){
    q++;
    if(j%2){
      /* point on log density */
      q->x = xinit[k++];
      q->y = perfunc(myldens,env,q->x,rho);
      q->f = 1;
    } else {
      /* intersection point */
      q->f = 0;
    }
    q->pl = q-1;
    q->pr = q+1;
  }
  /* right bound */
  q++;
  q->x = xr;
  q->f = 0;
  q->pl = q-1;
  q->pr = NULL;

  /* calculate intersection points */
  q = env->p;
  for (j=0; j<mpoint; j=j+2, q=q+2){
    if(meet(q,env,metrop)){
      /* envelope violation without metropolis */
      return 2000;
    }
  }

  /* exponentiate and integrate envelope */
  cumulate(env);

  /* note number of POINTs currently in envelope */
  env->cpoint = mpoint;

  return 0;
}

/* *********************************************************************** */

void sample(ENVELOPE *env, POINT *p)

/* To sample from piecewise exponential envelope */
/* *env    : envelope attributes */
/* *p      : a working POINT to hold the sampled value */

{
  double prob;

  /* sample a uniform */
  prob = u_random();
  /* get x-value correponding to a cumulative probability prob */
  invert(prob,env,p);

  return;
}

/* *********************************************************************** */

void invert(double prob, ENVELOPE *env, POINT *p)

/* to obtain a point corresponding to a qiven cumulative probability */
/* prob    : cumulative probability under envelope */
/* *env    : envelope attributes */
/* *p      : a working POINT to hold the sampled value */

{
  double u,xl,xr,yl,yr,eyl,eyr,prop,z;
  POINT *q;

  /* find rightmost point in envelope */
  q = env->p;
  while(q->pr != NULL)q = q->pr;

  /* find exponential piece containing point implied by prob */
  u = prob * q->cum;
  while(q->pl->cum > u)q = q->pl;

  /* piece found: set left and right POINTs of p, etc. */
  p->pl = q->pl;
  p->pr = q;
  p->f = 0;
  p->cum = u;

  /* calculate proportion of way through integral within this piece */
  prop = (u - q->pl->cum) / (q->cum - q->pl->cum);

  /* get the required x-value */
  if (q->pl->x == q->x){
    /* interval is of zero length */
    p->x = q->x;
    p->y = q->y;
    p->ey = q->ey;
  } else {
    xl = q->pl->x;
    xr = q->x;
    yl = q->pl->y;
    yr = q->y;
    eyl = q->pl->ey;
    eyr = q->ey;
    if(fabs(yr - yl) < YEPS){
      /* linear approximation was used in integration in function cumulate */
      if(fabs(eyr - eyl) > EYEPS*fabs(eyr + eyl)){
	p->x = xl + ((xr - xl)/(eyr - eyl))
	       * (-eyl + sqrt((1. - prop)*eyl*eyl + prop*eyr*eyr));
      } else {
	p->x = xl + (xr - xl)*prop;
      }
      p->ey = ((p->x - xl)/(xr - xl)) * (eyr - eyl) + eyl;
      p->y = logshift(p->ey, env->ymax);
    } else {
      /* piece was integrated exactly in function cumulate */
      p->x = xl + ((xr - xl)/(yr - yl))
	      * (-yl + logshift(((1.-prop)*eyl + prop*eyr), env->ymax));
      p->y = ((p->x - xl)/(xr - xl)) * (yr - yl) + yl;
      p->ey = expshift(p->y, env->ymax);
    }
  }

  /* guard against imprecision yielding point outside interval */
  if ((p->x < xl) || (p->x > xr)) error("exit 1");

  return;
}

/* *********************************************************************** */

int test(ENVELOPE *env, POINT *p, SEXP myldens, METROPOLIS *metrop, SEXP rho)

/* to perform rejection, squeezing, and metropolis tests */

/* *env          : envelope attributes */
/* *p            : point to be tested */
/* myldens       : R function to evaluate log-density */
/* *metrop       : data required for metropolis step */
/* rho           : R environment in which the logdensity is evaluated */

{
  double u,y,ysqueez,ynew,yold,znew,zold,w;
  POINT *ql,*qr;
  
  /* for rejection test */
  u = u_random() * p->ey;
  y = logshift(u,env->ymax);

  if(!(metrop->on) && (p->pl->pl != NULL) && (p->pr->pr != NULL)){
    /* perform squeezing test */
    if(p->pl->f){
      ql = p->pl;
    } else {
      ql = p->pl->pl;
    }
    if(p->pr->f){
      qr = p->pr;
    } else {
      qr = p->pr->pr;
    }
    ysqueez = (qr->y * (p->x - ql->x) + ql->y * (qr->x - p->x))
               /(qr->x - ql->x);
    if(y <= ysqueez){
      /* accept point at squeezing step */
      return 1;
    }
  }

  /* evaluate log density at point to be tested */
  ynew = perfunc(myldens,env,p->x,rho);
  
  /* perform rejection test */
  if(!(metrop->on) || ((metrop->on) && (y >= ynew))){
    /* update envelope */
    p->y = ynew;
    p->ey = expshift(p->y,env->ymax);
    p->f = 1;
    if(update(env,p,myldens,metrop,rho)){
      /* envelope violation without metropolis */
      return -1;
    }
    /* perform rejection test */
    if(y >= ynew){
      /* reject point at rejection step */
      return 0;
    } else {
      /* accept point at rejection step */
      return 1;
    }
  }

  /* continue with metropolis step */
  yold = metrop->yprev;
  /* find envelope piece containing metrop->xprev */
  ql = env->p;
  while(ql->pl != NULL)ql = ql->pl;
  while(ql->pr->x < metrop->xprev)ql = ql->pr;
  qr = ql->pr;
  /* calculate height of envelope at metrop->xprev */
  w = (metrop->xprev - ql->x)/(qr->x - ql->x);
  zold = ql->y + w*(qr->y - ql->y);
  znew = p->y;
  if(yold < zold)zold = yold;
  if(ynew < znew)znew = ynew;
  w = ynew-znew-yold+zold;
  if(w > 0.0)w = 0.0;

  if(w > -YCEIL){
    w = exp(w);
  } else {
    w = 0.0;
  }
  u = u_random();
  if(u > w){
    /* metropolis says dont move, so replace current point with previous */
    /* markov chain iterate */
    p->x = metrop->xprev;
    p->y = metrop->yprev;
    p->ey = expshift(p->y,env->ymax);
    p->f = 1;
    p->pl = ql;
    p->pr = qr;
  } else {
    /* trial point accepted by metropolis, so update previous markov */
    /* chain iterate */
    metrop->xprev = p->x;
    metrop->yprev = ynew;
  }
  return 1;
}

/* *********************************************************************** */

int update(ENVELOPE *env, POINT *p, SEXP myldens, METROPOLIS *metrop, SEXP rho)

/* to update envelope to incorporate new point on log density*/
/* *env          : envelope attributes */
/* *p            : point to be incorporated */
/* myldens       : R function to evaluate log density */
/* *metrop       : for metropolis step */
/* rho           : R environment in which the logdensity is evaluated */

{
  POINT *m,*ql,*qr,*q;

  if(!(p->f) || (env->cpoint > env->npoint - 2)){
    /* y-value has not been evaluated or no room for further points */
    /* ignore this point */
    return 0;
  }

  /* copy working POINT p to a new POINT q */
  q = env->p + env->cpoint++;
  q->x = p->x;
  q->y = p->y;
  q->f = 1;

  /* allocate an unused POINT for a new intersection */
  m = env->p + env->cpoint++;
  m->f = 0;
  if((p->pl->f) && !(p->pr->f)){
    /* left end of piece is on log density; right end is not */
    /* set up new intersection in interval between p->pl and p */
    m->pl = p->pl;
    m->pr = q;
    q->pl = m;
    q->pr = p->pr;
    m->pl->pr = m;
    q->pr->pl = q;
  } else if (!(p->pl->f) && (p->pr->f)){
    /* left end of interval is not on log density; right end is */
    /* set up new intersection in interval between p and p->pr */
    m->pr = p->pr;
    m->pl = q;
    q->pr = m;
    q->pl = p->pl;
    m->pr->pl = m;
    q->pl->pr = q;
  } else {
    /* this should be impossible */
      error("exit 10");
  }

  /* now adjust position of q within interval if too close to an endpoint */
  if(q->pl->pl != NULL){
    ql = q->pl->pl;
  } else {
    ql = q->pl;
  }
  if(q->pr->pr != NULL){
    qr = q->pr->pr;
  } else {
    qr = q->pr;
  }
  if (q->x < (1. - XEPS) * ql->x + XEPS * qr->x){
    /* q too close to left end of interval */
    q->x = (1. - XEPS) * ql->x + XEPS * qr->x;
    q->y = perfunc(myldens,env,q->x,rho);
  } else if (q->x > XEPS * ql->x + (1. - XEPS) * qr->x){
    /* q too close to right end of interval */
    q->x = XEPS * ql->x + (1. - XEPS) * qr->x;
    q->y = perfunc(myldens,env,q->x,rho);
  }

  /* revise intersection points */
  if(meet(q->pl,env,metrop)){
    /* envelope violation without metropolis */
    return 1;
  }
  if(meet(q->pr,env,metrop)){
    /* envelope violation without metropolis */
    return 1;
  }
  if(q->pl->pl != NULL){
    if(meet(q->pl->pl->pl,env,metrop)){
      /* envelope violation without metropolis */
      return 1;
    }
  }
  if(q->pr->pr != NULL){
    if(meet(q->pr->pr->pr,env,metrop)){
      /* envelope violation without metropolis */
      return 1;
    }
  }

  /* exponentiate and integrate new envelope */
  cumulate(env);

  return 0;
}

/* *********************************************************************** */

void cumulate(ENVELOPE *env)

/* to exponentiate and integrate envelope */
/* *env     : envelope attributes */

{
  POINT *q,*qlmost;

  qlmost = env->p;
  /* find left end of envelope */
  while(qlmost->pl != NULL)qlmost = qlmost->pl;

  /* find maximum y-value: search envelope */
  env->ymax = qlmost->y;
  for(q = qlmost->pr; q != NULL; q = q->pr){
    if(q->y > env->ymax)env->ymax = q->y;
  }

  /* exponentiate envelope */
  for(q = qlmost; q != NULL; q = q->pr){
    q->ey = expshift(q->y,env->ymax);
  }

  /* integrate exponentiated envelope */
  qlmost->cum = 0.;
  for(q = qlmost->pr; q != NULL; q = q->pr){
    q->cum = q->pl->cum + area(q);
  }

  return;
}

/* *********************************************************************** */

int meet (POINT *q, ENVELOPE *env, METROPOLIS *metrop)
/* To find where two chords intersect */
/* q         : to store point of intersection */
/* *env      : envelope attributes */
/* *metrop   : for metropolis step */

{
  double gl,gr,grl,dl,dr;
  int il,ir,irl;

  if(q->f){
    /* this is not an intersection point */
      error("exit 30");
  }

  /* calculate coordinates of point of intersection */
  if ((q->pl != NULL) && (q->pl->pl->pl != NULL)){
    /* chord gradient can be calculated at left end of interval */
    gl = (q->pl->y - q->pl->pl->pl->y)/(q->pl->x - q->pl->pl->pl->x);
    il = 1;
  } else {
    /* no chord gradient on left */
    il = 0;
  }
  if ((q->pr != NULL) && (q->pr->pr->pr != NULL)){
    /* chord gradient can be calculated at right end of interval */
    gr = (q->pr->y - q->pr->pr->pr->y)/(q->pr->x - q->pr->pr->pr->x);
    ir = 1;
  } else {
    /* no chord gradient on right */
    ir = 0;
  }
  if ((q->pl != NULL) && (q->pr != NULL)){
    /* chord gradient can be calculated across interval */
    grl = (q->pr->y - q->pl->y)/(q->pr->x - q->pl->x);
    irl = 1;
  } else {
    irl = 0;
  }

  if(irl && il && (gl<grl)){
    /* convexity on left exceeds current threshold */
    if(!(metrop->on)){
      /* envelope violation without metropolis */
      return 1;
    }
    /* adjust left gradient */
    gl = gl + (1.0 + *(env->convex)) * (grl - gl);
  }

  if(irl && ir && (gr>grl)){
    /* convexity on right exceeds current threshold */
    if(!(metrop->on)){
      /* envelope violation without metropolis */
      return 1;
    }
    /* adjust right gradient */
    gr = gr + (1.0 + *(env->convex)) * (grl - gr);
  }

  if(il && irl){
    dr = (gl - grl) * (q->pr->x - q->pl->x);
    if(dr < YEPS){
      /* adjust dr to avoid numerical problems */
      dr = YEPS;
    }
  }

  if(ir && irl){
    dl = (grl - gr) * (q->pr->x - q->pl->x);
    if(dl < YEPS){
      /* adjust dl to avoid numerical problems */
      dl = YEPS;
    }
  }

  if(il && ir && irl){
    /* gradients on both sides */
    q->x = (dl * q->pr->x + dr * q->pl->x)/(dl + dr);
    q->y = (dl * q->pr->y + dr * q->pl->y + dl * dr)/(dl + dr);
  } else if (il && irl){
    /* gradient only on left side, but not right hand bound */
    q->x = q->pr->x;
    q->y = q->pr->y + dr;
  } else if (ir && irl){
    /* gradient only on right side, but not left hand bound */
    q->x = q->pl->x;
    q->y = q->pl->y + dl;
  } else if (il){
    /* right hand bound */
    q->y = q->pl->y + gl * (q->x - q->pl->x);
  } else if (ir){
    /* left hand bound */
    q->y = q->pr->y - gr * (q->pr->x - q->x);
  } else {
    /* gradient on neither side - should be impossible */
      error("exit 31");
  }
  if(((q->pl != NULL) && (q->x < q->pl->x)) ||
     ((q->pr != NULL) && (q->x > q->pr->x))){
    /* intersection point outside interval (through imprecision) */
      error("exit 32");
  }
  /* successful exit : intersection has been calculated */
  return 0;
}

/* *********************************************************************** */

double area(POINT *q)

/* To integrate piece of exponentiated envelope to left of POINT q */

{
  double a;

  if(q->pl == NULL){
    /* this is leftmost point in envelope */
      error("exit 1");
  } else if(q->pl->x == q->x){
    /* interval is zero length */
    a = 0.;
  } else if (fabs(q->y - q->pl->y) < YEPS){
    /* integrate straight line piece */
    a = 0.5*(q->ey + q->pl->ey)*(q->x - q->pl->x);
  } else {
    /* integrate exponential piece */
    a = ((q->ey - q->pl->ey)/(q->y - q->pl->y))*(q->x - q->pl->x);
  }
  return a;
}

/* *********************************************************************** */

double expshift(double y, double y0)

/* to exponentiate shifted y without underflow */
{
  if(y - y0 > -2.0 * YCEIL){
    return exp(y - y0 + YCEIL);
  } else {
    return 0.0;
  }
}

/* *********************************************************************** */

double logshift(double y, double y0)

/* inverse of function expshift */
{
  return (log(y) + y0 - YCEIL);
}

/* *********************************************************************** */

double perfunc(SEXP myldens, ENVELOPE *env, double x, SEXP rho)

/* to evaluate log density and increment count of evaluations */

/* myldens : R function to evaluate log density */
/* *env    : envelope attributes */
/* x       : point at which to evaluate log density */
/* rho     : R environment in which the logdensity is evaluated */
{
  double y;
  SEXP R_fcall, arg;

  /* evaluate logdensity function */
  PROTECT(R_fcall = lang2(myldens, R_NilValue));
  PROTECT(arg = NEW_NUMERIC(1));
  NUMERIC_POINTER(arg)[0] = x;
  SETCADR(R_fcall, arg);
  y = REAL(eval(R_fcall, rho))[0];
  UNPROTECT(2);

  /* increment count of function evaluations */
  (*(env->neval))++;

  return y;
}

/* *********************************************************************** */

void display(FILE *f, ENVELOPE *env)

/* to display envelope - for debugging only */
{
  POINT *q;

  /* print envelope attributes */
  fprintf(f,"========================================================\n");
  fprintf(f,"envelope attributes:\n");
  fprintf(f,"points in use = %d, points available = %d\n",
          env->cpoint,env->npoint);
  fprintf(f,"function evaluations = %d\n",*(env->neval));
  fprintf(f,"ymax = %f, p = %x\n",env->ymax,env->p);
  fprintf(f,"convexity adjustment = %f\n",*(env->convex));
  fprintf(f,"--------------------------------------------------------\n");

  /* find leftmost POINT */
  q = env->p;
  while(q->pl != NULL)q = q->pl;

  /* now print each POINT from left to right */
  for(q = env->p; q != NULL; q = q->pr){
    fprintf(f,"point at %x, left at %x, right at %x\n",q,q->pl,q->pr);
    fprintf(f,"x = %f, y = %f, ey = %f, cum = %f, f = %d\n",
            q->x,q->y,q->ey,q->cum,q->f);
  }
  fprintf(f,"========================================================\n");

  return;
}

/* *********************************************************************** */

double u_random()

/* to return a standard uniform random number */
{
    double x;
    GetRNGstate();
    x = unif_rand();
    PutRNGstate();
    return x;

}

/* *********************************************************************** */

####$$$$ dlm\src/dlm.c
# include <stdio.h>
# include <R.h>
# include <Rinternals.h>
# include <Rmath.h>


static double sqrarg;
# define SQR(x) ((sqrarg = (x)) == 0.0 ? 0.0 : sqrarg*sqrarg)

SEXP dlmLL();
SEXP dlmLL0(); /* for time-invariant models */
SEXP dlmFilter();
SEXP dlmFilter0(); /* for time-invariant models */
SEXP dlmSmooth();
SEXP dlmSmooth0(); /* for time-invariant models */
SEXP dlmForecast();
SEXP ARtranspar();

void F77_NAME(dgesdd)(const char *jobz,
                      const int *m, const int *n,
                      double *a, const int *lda, double *s,
                      double *u, const int *ldu,
                      double *vt, const int *ldvt,
                      double *work, const int *lwork, int *iwork, int *info);

void pmatrix();
void pIntMatrix();

void pmatrix(char *txt, double *x, /* print matrix, for debugging */
             int ldx, int m, int n)
{
    int i, j;
    Rprintf("%s\n",txt);
    for (i=0; i<m; i++)
    {
        for (j=0; j<n; j++)
            Rprintf("%6.5lg ",x[i+j*ldx]);
        Rprintf("\n");
    }
    Rprintf("\n");
}

void pIntMatrix(char *txt, int *x, /* print int matrix, for debugging */
             int ldx, int m, int n)
{
    int i, j;
    Rprintf("%s\n",txt);
    for (i=0; i<m; i++)
    {
        for (j=0; j<n; j++)
            Rprintf("%d ",x[i+j*ldx]);
        Rprintf("\n");
    }
    Rprintf("\n");
}

SEXP dlmLL(SEXP y, SEXP mod, SEXP tvFF, SEXP tvV, SEXP tvGG, SEXP tvW)
{
/***** Warning: the function relies on the order of the  *****/
/***** components of the list 'mod', not on their names. *****/     

    SEXP val;
    int i, j, k, l, p, m, n, t, max_m_p, la_m, la_n, la_info=0, la_lwork, *la_iwork,
      numNA, *whereNA, numGood, *good, warn;
    int stvFF=INTEGER(tvFF)[0], stvV=INTEGER(tvV)[0], stvGG=INTEGER(tvGG)[0], 
	stvW=INTEGER(tvW)[0], stvFV, *sJFF, *sJV, *sJGG, *sJW, nrJFF, nrJV, nrJGG, nrJW;
    double *sy=REAL(y), *sm0, *sFF, *sV, *sGG, *sW, *sX, *Ux,  
        *Dx, *sqrtV, *sqrtW, 
        *sqrtVinv, *a, *Ux_prior, *Dx_prior, *f, *Uy, *Dy,
        *e, *tF_Vinv, ll=0.0;
    double tmp, tmp1, *tmpMat, *tmpMat2, *la_s, *la_u, *la_vt, *la_work,
      *sqrtVTMP, *sqrtVinvTMP, *tF_VinvTMP, eps;
    char la_jobz='S';

    eps = DBL_EPSILON * 100.0;
    PROTECT(val = allocVector(REALSXP, 1));
    m = INTEGER(getAttrib( VECTOR_ELT(mod,2), R_DimSymbol ))[0];
    p = INTEGER(getAttrib( VECTOR_ELT(mod,2), R_DimSymbol ))[1];
    max_m_p = m > p ? m : p;
    la_n = max_m_p;
    la_m = la_n + p;
    n = length(y) / m; 
    sm0 = (double *) R_alloc( p, sizeof(double) );
    for (i = 0; i < p; i++)
        sm0[i] = REAL(VECTOR_ELT(mod,0))[i];
    sFF = REAL(VECTOR_ELT(mod,2));
    sV = REAL(VECTOR_ELT(mod,3));
    sGG = REAL(VECTOR_ELT(mod,4));
    sW = REAL(VECTOR_ELT(mod,5));
    sqrtV = (double *) R_alloc( m * m, sizeof(double) );
    sqrtVinv = (double *) R_alloc( m * m, sizeof(double) );
    sqrtW = (double *) R_alloc( p * p, sizeof(double) );
    tF_Vinv = (double *) R_alloc( p * m, sizeof(double) );
    Ux = (double *) R_alloc( p * p, sizeof(double) ); 
    Dx = (double *) R_alloc( p, sizeof(double) ); 
    Ux_prior = (double *) R_alloc( p * p, sizeof(double) ); 
    Dx_prior = (double *) R_alloc( p, sizeof(double) ); 
    a = (double *) R_alloc( p, sizeof(double) ); 
    f = (double *) R_alloc( m, sizeof(double) ); 
    Uy = (double *) R_alloc( m * m, sizeof(double) );
    Dy = (double *) R_alloc( m, sizeof(double) ); 
    e = (double *) R_alloc( m, sizeof(double) );
    tmpMat2 = (double *) R_alloc( m * p, sizeof(double) );

    /* space needed to deal with missing values */
    whereNA = (int *) R_alloc( m, sizeof(int) );
    if (m > 1){
	good = (int *) R_alloc( m, sizeof(int) );
	sqrtVTMP = (double *) R_alloc( m * m, sizeof(double) );
	sqrtVinvTMP = (double *) R_alloc( m * m, sizeof(double) );
	tF_VinvTMP = (double *) R_alloc( p * m, sizeof(double) );
    }
    /* allocate space for a la_m by la_n matrix */
    tmpMat = (double *) R_alloc( la_m * la_n, sizeof(double) ); 
    /* space for singular values */
    la_s = (double *) R_alloc( max_m_p, sizeof(double) );
    /* space for U matrix and Vt matrix (singular vectors) */
    la_u = (double *) R_alloc( la_m * max_m_p, sizeof(double) );
    la_vt = (double *) R_alloc( max_m_p * max_m_p, sizeof(double) );
    /* space for la_iwork */
    la_iwork = (int *) R_alloc( 8 * p, sizeof(int) );

    /* ask for optimal size of work array */
    la_lwork = -1;
    F77_CALL(dgesdd)(&la_jobz,
                     &la_m, &la_n, tmpMat, &la_m, la_s,
                     la_u, &la_m,
                     la_vt, &max_m_p,
                     &tmp, &la_lwork, la_iwork, &la_info);
    if (la_info != 0)
        error("error code %d from Lapack routine dgesdd", la_info);
    la_lwork = (int) tmp;
    la_work = (double *) R_alloc( la_lwork, sizeof(double) );

    /** preliminaries: compute svd of C0, etc... **/
    for (i = 0; i < p; i++) {
        for (j = 0; j<i; j++) 
            tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
                REAL(VECTOR_ELT(mod,1))[i + p * j]; /* C0 */
        tmpMat[i + la_m * j] = REAL(VECTOR_ELT(mod,1))[i + p * j];
    }
    F77_CALL(dgesdd)(&la_jobz,
                     &p, &p, tmpMat, &la_m, la_s,
                     la_u, &la_m,
                     la_vt, &max_m_p,
                     la_work, &la_lwork, la_iwork, &la_info);
    if (la_info != 0)
        error("error code %d from Lapack routine dgesdd", la_info);
    for (i = 0; i < p; i++) {
        for (j = 0; j < p; j++)
            Ux[i + j * p] = la_vt[j + i * max_m_p];
        Dx[i] = sqrt( la_s[i] );
    }
    /* time-varying matrices stuff */
    stvFV = stvFF || stvV;
    sX = REAL(VECTOR_ELT(mod,10));
    if (stvFF) {
	sJFF=INTEGER(VECTOR_ELT(mod,6));
	nrJFF=INTEGER(getAttrib( VECTOR_ELT(mod,6), R_DimSymbol ))[0];
    }
    if (stvV) {
	sJV=INTEGER(VECTOR_ELT(mod,7));
	nrJV=INTEGER(getAttrib( VECTOR_ELT(mod,7), R_DimSymbol ))[0];
    } else {
	/* compute sqrtV, time-invariant*/
	for (i = 0; i < m; i++) {
	    for (j = 0; j<i; j++) 
		tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
		    sV[i + m * j];
	    tmpMat[i + la_m * j] = sV[i + m * j];
	}
	F77_CALL(dgesdd)(&la_jobz,
			 &m, &m, tmpMat, &la_m, la_s,
			 la_u, &la_m,
			 la_vt, &max_m_p,
			 la_work, &la_lwork, la_iwork, &la_info);
	if (la_info != 0)
	    error("error code %d from Lapack routine dgesdd", la_info);
	warn = 0;
	for (i = 0; i < m; i++) {
	  if (la_s[i] < eps) {
	    tmp = sqrt(eps);
	    if (la_s[i] > 0) warn = 1;
	  } else 
	    tmp = sqrt(la_s[i]);
	  tmp1 = 1 / tmp;
	  for (j = 0; j<m; j++) {
	    sqrtV[i + j * m] = tmp * la_vt[i + j * max_m_p];
	    sqrtVinv[i + j * m] = tmp1 * la_vt[i + j * max_m_p];
	  }
	}
	if (warn)
	    warning("a numerically singular 'V' has been slightly perturbed to make it nonsingular");

	if (!stvFF) {
	    /* compute also tF_Vinv, time-invariant */
	    for (i = 0; i < m; i++) {
		for (j = 0; j < i; j++) {
		    tmp = 0.0;
		    for (k = 0; k < m; k++)
			tmp += sqrtVinv[k + i * m] * sqrtVinv[k + j * m];
		    tmpMat[i + j * la_m] = tmpMat[j + i * la_m] = tmp;
		}
		tmp = 0.0;
		for (k = 0; k < m; k++)
		    tmp += SQR( sqrtVinv[k + i * m] );
		tmpMat[i + i * la_m] = tmp;
	    }
	    for (i = 0; i < p ; i++) 
		for (j = 0; j < m; j++) {
		    tmp = 0.0;
		    for (k = 0; k < m; k++)
			tmp += sFF[k + i * m] * tmpMat[k + j * la_m];
		    tF_Vinv[i + j * p] = tmp;
		}
	}
    }
    if (stvGG) {
	sJGG=INTEGER(VECTOR_ELT(mod,8));
	nrJGG=INTEGER(getAttrib( VECTOR_ELT(mod,8), R_DimSymbol ))[0];
    }
    if (stvW) {
	sJW=INTEGER(VECTOR_ELT(mod,9));
	nrJW=INTEGER(getAttrib( VECTOR_ELT(mod,9), R_DimSymbol ))[0];
    } else {
	/* compute sqrtW, time-invariant */
	for (i = 0; i < p; i++) {
	    for (j = 0; j < i; j++) 
		tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
		    sW[i + p * j];
	    tmpMat[i + la_m * j] = sW[i + p * j];
	}
	F77_CALL(dgesdd)(&la_jobz,
			 &p, &p, tmpMat, &la_m, la_s,
			 la_u, &la_m,
			 la_vt, &max_m_p,
			 la_work, &la_lwork, la_iwork, &la_info);
	if (la_info != 0)
	    error("error code %d from Lapack routine dgesdd", la_info);
	for (i = 0; i < p; i++) {
	    tmp = sqrt( la_s[i] );
	    for (j = 0; j < p; j++) 
		sqrtW[i + j * p] = tmp * la_vt[i + j * max_m_p];
	}
    }
    
    /** loop over observations **/
    for (t = 0; t < n; t++) { 
	/** set time-varying matrices **/
	if (stvFF) 
	    for (i = 0; i < nrJFF; i++)
		sFF[ sJFF[i] + m * sJFF[i + nrJFF] ] = sX[ t + n * sJFF[i + 2 * nrJFF] ];
	if (stvV) {
	    for (i = 0; i < nrJV; i++)
		sV[ sJV[i] + m * sJV[i + nrJV] ] = sX[ t + n * sJV[i + 2 * nrJV] ];
	    for (i = 0; i < m; i++) {
		for (j = 0; j<i; j++) 
		    tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
			sV[i + m * j];
		tmpMat[i + la_m * j] = sV[i + m * j];
	    }
	    F77_CALL(dgesdd)(&la_jobz,
			     &m, &m, tmpMat, &la_m, la_s,
			     la_u, &la_m,
			     la_vt, &max_m_p,
			     la_work, &la_lwork, la_iwork, &la_info);
	    if (la_info != 0)
		error("error code %d from Lapack routine dgesdd", la_info);
	    for (i = 0; i < m; i++) {
		tmp = sqrt( la_s[i] );
		tmp1 = 1 / tmp;
		tmp1 = R_FINITE(tmp1) ? tmp1 : 0.0;
		for (j = 0; j<m; j++) {
		    sqrtV[i + j * m] = tmp * la_vt[i + j * max_m_p];
		    sqrtVinv[i + j * m] = tmp1 * la_vt[i + j * max_m_p];
		}
	    }
	}
	if (stvGG) 
	    for (i = 0; i < nrJGG; i++)
		sGG[ sJGG[i] + p * sJGG[i + nrJGG] ] = sX[ t + n * sJGG[i + 2 * nrJGG] ];
	if (stvW) {
	    for (i = 0; i < nrJW; i++)
		sW[ sJW[i] + p * sJW[i + nrJW] ] = sX[ t + n * sJW[i + 2 * nrJW] ];
	    for (i = 0; i < p; i++) {
		for (j = 0; j < i; j++) 
		    tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
			sW[i + p * j];
		tmpMat[i + la_m * j] = sW[i + p * j];
	    }
	    F77_CALL(dgesdd)(&la_jobz,
			     &p, &p, tmpMat, &la_m, la_s,
			     la_u, &la_m,
			     la_vt, &max_m_p,
			     la_work, &la_lwork, la_iwork, &la_info);
	    if (la_info != 0)
		error("error code %d from Lapack routine dgesdd", la_info);
	    for (i = 0; i < p; i++) {
		tmp = sqrt( la_s[i] );
		for (j = 0; j < p; j++) 
		    sqrtW[i + j * p] = tmp * la_vt[i + j * max_m_p];
	    }
	}
	if (stvFV) {
	    for (i = 0; i < m; i++) {
		for (j = 0; j < i; j++) {
		    tmp = 0.0;
		    for (k = 0; k < m; k++)
			tmp += sqrtVinv[k + i * m] * sqrtVinv[k + j * m];
		    tmpMat[i + j * la_m] = tmpMat[j + i * la_m] = tmp;
		}
		tmp = 0.0;
		for (k = 0; k < m; k++)
		    tmp += SQR( sqrtVinv[k + i * m] );
		tmpMat[i + i * la_m] = tmp;
	    }
	    for (i = 0; i < p ; i++) 
		for (j = 0; j < m; j++) {
		    tmp = 0.0;
		    for (k = 0; k < m; k++)
			tmp += sFF[k + i * m] * tmpMat[k + j * la_m];
		    tF_Vinv[i + j * p] = tmp;
		}
	}

	/** check for missing values **/
	numNA = 0;
	for (i = 0; i < m; i++)
	    if (ISNA(sy[t + i * n]))  
		whereNA[numNA++] = i; 

	if (numNA == 0) { /** no missing values **/

	    /** Prior **/
	    for (i = 0; i < p; i++) {
		tmp = 0.0;
		for (k = 0; k < p; k++)
		    tmp += sGG[i + p * k] * sm0[k];
		a[i] = tmp;
	    }
        
	    for (i = 0; i < p; i++) {
		tmp1 = Dx[i];
		for (j = 0; j < p; j++) {
		    tmp = 0.0;
		    for (l = 0; l < p; l++)
			tmp += sGG[j + l * p] * Ux[i * p + l];
		    tmpMat[i + j * la_m] = tmp * tmp1;
		}
            
	    }
	    for (i = 0; i < p; i++) 
		for (j = 0; j < p; j++) 
		    tmpMat[i + p + j * la_m] = sqrtW[i + j * p];
	    l = 2 * p;
	    F77_CALL(dgesdd)(&la_jobz,
			     &l, &p, tmpMat, &la_m, la_s,
			     la_u, &la_m,
			     la_vt, &max_m_p,
			     la_work, &la_lwork, la_iwork, &la_info);
	    if (la_info != 0)
		error("error code %d from Lapack routine dgesdd", la_info);
	    for (i = 0; i < p; i++) {
		for (j = 0; j < p; j++)
		    Ux_prior[i + j * p] = la_vt[j + i * max_m_p];
		Dx_prior[i] = la_s[i];
	    }

	    /** One-step forecast **/
	    for (i = 0; i < m; i++) {
		tmp = 0.0;
		for (j = 0; j < p; j++)
		    tmp += sFF[i + j * m] * a[j];
		f[i] = tmp;
	    }
	    for (i = 0; i < p; i++) {
		tmp1 = Dx_prior[i];
		for (j = 0; j < m; j++) {
		    tmp = 0.0;
		    for (l = 0; l < p; l++)
			tmp += sFF[j + l * m] * Ux_prior[l + i * p];
		    tmpMat[i + j * la_m] = tmp * tmp1;
		}
            
	    }
	    for (i = 0; i < m; i++) 
		for (j = 0; j < m; j++) 
		    tmpMat[i + p + j * la_m] = sqrtV[i + j * m];
        
	    l = p + m;
	    F77_CALL(dgesdd)(&la_jobz,
			     &l, &m, tmpMat, &la_m, la_s,
			     la_u, &la_m,
			     la_vt, &max_m_p,
			     la_work, &la_lwork, la_iwork, &la_info);
	    if (la_info != 0)
		error("error code %d from Lapack routine dgesdd", la_info);
	    for (i = 0; i < m; i++) {
		for (j = 0; j < m; j++)
		    Uy[i + j * m] = la_vt[j + i * max_m_p];
		Dy[i] = la_s[i];
	    }
        
	    /** Posterior **/
	    for (i = 0; i < m; i++)
		for (j = 0; j < p; j++) {
		    tmp = 0.0;
		    for (k = 0; k < m; k++)
			tmp += sqrtVinv[i + k * m] * sFF[k + j * m];
		    tmpMat2[i + j * m] = tmp;
		}
	    for (i = 0; i < m; i++)
		for (j = 0; j < p; j++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += tmpMat2[i + k * m] * Ux_prior[k + j * p];
		    tmpMat[i + j * la_m] = tmp;
		}
	    for (i = 0; i < p; i++) {
		tmp = 1 / Dx_prior[i];
		tmpMat[i + m + i * la_m] = R_FINITE(tmp) ? tmp : 0.0;
		for (j = i + 1; j < p; j++) 
		    tmpMat[j + m + i * la_m] = tmpMat[i + m + j * la_m] = 0.0;
	    }
	    l = p + m;
	    F77_CALL(dgesdd)(&la_jobz,
			     &l, &p, tmpMat, &la_m, la_s,
			     la_u, &la_m,
			     la_vt, &max_m_p,
			     la_work, &la_lwork, la_iwork, &la_info);
	    if (la_info != 0)
		error("error code %d from Lapack routine dgesdd", la_info);
	    for (i = 0; i < p; i++) {
		for (j = 0; j < p; j++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += Ux_prior[i + k * p] * la_vt[j + k * max_m_p];
		    Ux[i + j * p] = tmp;
		}
		tmp = 1 / la_s[i];
		Dx[i] = R_FINITE(tmp) ? tmp : 0.0;
	    }
	    for (i = 0; i < m; i++)
		e[i] = sy[t + i * n] - f[i];
	    for (i = 0; i < p; i++)
		for (j = 0; j < m; j++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += SQR(Dx[i]) * Ux[k + i * p] * tF_Vinv[k + j * p];
		    tmpMat[i + j * la_m] = tmp;
		}
	    for (i = 0; i < p; i++)
		for (j = 0; j < m; j++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += Ux[i + k * p] * tmpMat[k + j * la_m];
		    tmpMat2[j + i * m] = tmp;
		}
	    for (i = 0; i < p; i++) {
		tmp = a[i];
		for (j = 0; j < m; j++)
		    tmp += tmpMat2[j + i * m] * e[j];
		sm0[i] = tmp;
	    }

	    /** Update negative log likelihood **/
	    for (i = 0; i < m; i++) {
		tmp =0.0;
		for (j = 0; j < m; j++)
		    tmp += Uy[j + i * m] * e[j];
		ll += SQR( tmp / Dy[i] ) + 2.0 * log( Dy[i] );
	    }
	} else {
	    if (numNA == m) { /** all missing **/

		for (i = 0; i < p; i++) {
		    tmp = 0.0;
		    for (j = 0; j < p; j++)
			tmp += sGG[i + j * p] * sm0[j];
		    tmpMat2[i] = tmp;
		}
		for (i = 0; i < p; i++)
		    sm0[i] = tmpMat2[i];
		
		for (i = 0; i < p; i++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += sGG[i + p * k] * sm0[k];
		    a[i] = tmp;
		}
		for (i = 0; i < p; i++) {
		    tmp1 = Dx[i];
		    for (j = 0; j < p; j++) {
			tmp = 0.0;
			for (l = 0; l < p; l++)
			    tmp += sGG[j + l * p] * Ux[i * p + l];
			tmpMat[i + j * la_m] = tmp * tmp1;
		    }
		    
		}
		for (i = 0; i < p; i++) 
		    for (j = 0; j < p; j++) 
			tmpMat[i + p + j * la_m] = sqrtW[i + j * p];
		l = 2 * p;
		F77_CALL(dgesdd)(&la_jobz,
				 &l, &p, tmpMat, &la_m, la_s,
				 la_u, &la_m,
				 la_vt, &max_m_p,
				 la_work, &la_lwork, la_iwork, &la_info);
		if (la_info != 0)
		    error("error code %d from Lapack routine dgesdd", la_info);
		for (i = 0; i < p; i++) {
		    for (j = 0; j < p; j++)
			Ux[i + j * p] = la_vt[j + i * max_m_p];
		    Dx[i] = la_s[i];
		}

	    } else { /** some missing **/

		numGood = m - numNA;
		for (i = j = k = 0; i < m; i++) 
		    if (k + 1 <= numNA && whereNA[k] == i) 
			k++;
		    else
			good[j++] = i;
		for (i = 0; i < numGood; i++) {
		    for (j = 0; j < i; j++) 
			tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
			    REAL(VECTOR_ELT(mod,3))[good[i] + m * good[j]]; /* V */
		    tmpMat[i + la_m * j] = REAL(VECTOR_ELT(mod,3))[good[i] + m * good[j]];
		}
		F77_CALL(dgesdd)(&la_jobz,
				 &numGood, &numGood, tmpMat, &la_m, la_s,
				 la_u, &la_m,
				 la_vt, &max_m_p,
				 la_work, &la_lwork, la_iwork, &la_info);
		if (la_info != 0)
		    error("error code %d from Lapack routine dgesdd", la_info);
		for (i = 0; i < numGood; i++) {
		    tmp = sqrt( la_s[i] );
		    tmp1 = 1 / tmp;
		    tmp1 = R_FINITE(tmp1) ? tmp1 : 0.0;
		    for (j = 0; j < numGood; j++) {
			sqrtVTMP[i + j * m] = tmp * la_vt[i + j * max_m_p]; 
			sqrtVinvTMP[i + j * m] = tmp1 * la_vt[i + j * max_m_p];
		    }
		}

		for (i = 0; i < numGood; i++) {
		    for (j = 0; j < i; j++) {
			tmp = 0.0;
			for (k = 0; k < numGood; k++)
			    tmp += sqrtVinvTMP[k + i * m] * sqrtVinvTMP[k + j * m];
			tmpMat[i + j * la_m] = tmpMat[j + i * la_m] = tmp;
		    }
		    tmp = 0.0;
		    for (k = 0; k < numGood; k++)
			tmp += SQR( sqrtVinvTMP[k + i * m] );
		    tmpMat[i + i * la_m] = tmp;
		}
		for (i = 0; i < p ; i++) 
		    for (j = 0; j < numGood; j++) {
			tmp = 0.0;
			for (k = 0; k < numGood; k++)
			    tmp += sFF[good[k] + i * m] * tmpMat[k + j * la_m];
			tF_VinvTMP[i + j * p] = tmp;
		    }

		/** Prior **/
		for (i = 0; i < p; i++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += sGG[i + p * k] * sm0[k];
		    a[i] = tmp;
		}
		
		for (i = 0; i < p; i++) {
		    tmp1 = Dx[i];
		    for (j = 0; j < p; j++) {
			tmp = 0.0;
			for (l = 0; l < p; l++)
			    tmp += sGG[j + l * p] * Ux[i * p + l];
			tmpMat[i + j * la_m] = tmp * tmp1;
		    }
            
		}
		for (i = 0; i < p; i++) 
		    for (j = 0; j < p; j++) 
			tmpMat[i + p + j * la_m] = sqrtW[i + j * p];
		l = 2 * p;
		F77_CALL(dgesdd)(&la_jobz,
				 &l, &p, tmpMat, &la_m, la_s,
				 la_u, &la_m,
				 la_vt, &max_m_p,
				 la_work, &la_lwork, la_iwork, &la_info);
		if (la_info != 0)
		    error("error code %d from Lapack routine dgesdd", la_info);
		for (i = 0; i < p; i++) {
		    for (j = 0; j < p; j++)
			Ux_prior[i + j * p] = la_vt[j + i * max_m_p];
		    Dx_prior[i] = la_s[i];
		}

		/** One-step forecast **/
		for (i = 0; i < numGood; i++) {
		    tmp = 0.0;
		    for (j = 0; j < p; j++)
			tmp += sFF[good[i] + j * m] * a[j];
		    f[i] = tmp;
		}
		for (i = 0; i < p; i++) {
		    tmp1 = Dx_prior[i];
		    for (j = 0; j < numGood; j++) {
			tmp = 0.0;
			for (l = 0; l < p; l++)
			    tmp += sFF[good[j] + l * m] * Ux_prior[l + i * p];
			tmpMat[i + j * la_m] = tmp * tmp1;
		    }
            
		}
		for (i = 0; i < numGood; i++) 
		    for (j = 0; j < numGood; j++) 
			tmpMat[i + p + j * la_m] = sqrtVTMP[i + j * m];

		l = p + numGood;
		F77_CALL(dgesdd)(&la_jobz,
				 &l, &numGood, tmpMat, &la_m, la_s,
				 la_u, &la_m,
				 la_vt, &max_m_p,
				 la_work, &la_lwork, la_iwork, &la_info);
		if (la_info != 0)
		    error("error code %d from Lapack routine dgesdd", la_info);
		for (i = 0; i < numGood; i++) {
		    for (j = 0; j < numGood; j++)
			Uy[i + j * m] = la_vt[j + i * max_m_p];
		    Dy[i] = la_s[i];
		}

		/** Posterior **/
		for (i = 0; i < numGood; i++)
		    for (j = 0; j < p; j++) {
			tmp = 0.0;
			for (k = 0; k < numGood; k++)
			    tmp += sqrtVinvTMP[i + k * m] * sFF[good[k] + j * m];
			tmpMat2[i + j * m] = tmp;
		    }
		for (i = 0; i < numGood; i++)
		    for (j = 0; j < p; j++) {
			tmp = 0.0;
			for (k = 0; k < p; k++)
			    tmp += tmpMat2[i + k * m] * Ux_prior[k + j * p];
			tmpMat[i + j * la_m] = tmp;
		    }
		for (i = 0; i < p; i++) {
		    tmp = 1 / Dx_prior[i];
		    tmpMat[i + numGood + i * la_m] = R_FINITE(tmp) ? tmp : 0.0;
		    for (j = i + 1; j < p; j++) 
			tmpMat[j + numGood + i * la_m] = tmpMat[i + numGood + j * la_m] = 0.0;
		}
		l = p + numGood;
		F77_CALL(dgesdd)(&la_jobz,
				 &l, &p, tmpMat, &la_m, la_s,
				 la_u, &la_m,
				 la_vt, &max_m_p,
				 la_work, &la_lwork, la_iwork, &la_info);
		if (la_info != 0)
		    error("error code %d from Lapack routine dgesdd", la_info);
		for (i = 0; i < p; i++) {
		    for (j = 0; j < p; j++) {
			tmp = 0.0;
			for (k = 0; k < p; k++)
			    tmp += Ux_prior[i + k * p] * la_vt[j + k * max_m_p];
			Ux[i + j * p] = tmp;
		    }
		    tmp = 1 / la_s[i];
		    Dx[i] = R_FINITE(tmp) ? tmp : 0.0;
		}
		for (i = 0; i < numGood; i++)
		    e[i] = sy[t + good[i] * n] - f[i];
		for (i = 0; i < p; i++)
		    for (j = 0; j < numGood; j++) {
			tmp = 0.0;
			for (k = 0; k < p; k++)
			    tmp += SQR(Dx[i]) * Ux[k + i * p] * tF_VinvTMP[k + j * p];
			tmpMat[i + j * la_m] = tmp;
		    }
		for (i = 0; i < p; i++)
		    for (j = 0; j < numGood; j++) {
			tmp = 0.0;
			for (k = 0; k < p; k++)
			    tmp += Ux[i + k * p] * tmpMat[k + j * la_m];
			tmpMat2[j + i * m] = tmp;
		    }
		for (i = 0; i < p; i++) {
		    tmp = a[i];
		    for (j = 0; j < numGood; j++)
   			tmp += tmpMat2[j + i * m] * e[j];
		    sm0[i] = tmp;
		}
		
		/** Update negative log likelihood **/
		for (i = 0; i < numGood; i++) {
		    tmp =0.0;
		    for (j = 0; j < numGood; j++)
			tmp += Uy[j + i * m] * e[j];
		    ll += SQR( tmp / Dy[i] ) + 2.0 * log( Dy[i] );
		}
	    }
	}
    }

    REAL(val)[0] = 0.5 * ll;
    UNPROTECT(1);
    return(val);

}


SEXP dlmLL0(SEXP y, SEXP mod) 
{
/***** Warning: the function relies on the order of the  *****/
/***** components of the list 'mod', not on their names. *****/     

    SEXP val;
    int i, j, k, l, p, m, n, t, max_m_p, la_m, la_n, la_info=0, la_lwork, *la_iwork,
      numNA, *whereNA, numGood, *good, warn;
    double *sy=REAL(y), *sm0, *sFF, *sGG, *Ux,  
        *Dx, *sqrtV, *sqrtW, 
        *sqrtVinv, *a, *Ux_prior, *Dx_prior, *f, *Uy, *Dy,
        *e, *tF_Vinv, ll=0.0;
    double tmp, tmp1, *tmpMat, *tmpMat2, *la_s, *la_u, *la_vt, *la_work,
      *sqrtVTMP, *sqrtVinvTMP, *tF_VinvTMP, eps;
    char la_jobz='S';

    eps = DBL_EPSILON * 100.0;
    PROTECT(val = allocVector(REALSXP, 1));
    m = INTEGER(getAttrib( VECTOR_ELT(mod,2), R_DimSymbol ))[0];
    p = INTEGER(getAttrib( VECTOR_ELT(mod,2), R_DimSymbol ))[1];
    max_m_p = m > p ? m : p;
    la_n = max_m_p;
    la_m = la_n + p;
    n = length(y) / m; 
    sm0 = (double *) R_alloc( p, sizeof(double) );
    for (i = 0; i < p; i++)
        sm0[i] = REAL(VECTOR_ELT(mod,0))[i];
    sFF = REAL(VECTOR_ELT(mod,2));
    sGG = REAL(VECTOR_ELT(mod,4));
    sqrtV = (double *) R_alloc( m * m, sizeof(double) );
    sqrtVinv = (double *) R_alloc( m * m, sizeof(double) );
    sqrtW = (double *) R_alloc( p * p, sizeof(double) );
    tF_Vinv = (double *) R_alloc( p * m, sizeof(double) );
    Ux = (double *) R_alloc( p * p, sizeof(double) ); 
    Dx = (double *) R_alloc( p, sizeof(double) ); 
    Ux_prior = (double *) R_alloc( p * p, sizeof(double) ); 
    Dx_prior = (double *) R_alloc( p, sizeof(double) ); 
    a = (double *) R_alloc( p, sizeof(double) ); 
    f = (double *) R_alloc( m, sizeof(double) ); 
    Uy = (double *) R_alloc( m * m, sizeof(double) );
    Dy = (double *) R_alloc( m, sizeof(double) ); 
    e = (double *) R_alloc( m, sizeof(double) );
    tmpMat2 = (double *) R_alloc( m * p, sizeof(double) );

    /* space needed to deal with missing values */
    whereNA = (int *) R_alloc( m, sizeof(int) );
    if (m > 1){
	good = (int *) R_alloc( m, sizeof(int) );
	sqrtVTMP = (double *) R_alloc( m * m, sizeof(double) );
	sqrtVinvTMP = (double *) R_alloc( m * m, sizeof(double) );
	tF_VinvTMP = (double *) R_alloc( p * m, sizeof(double) );
    }
    /* allocate space for a la_m by la_n matrix */
    tmpMat = (double *) R_alloc( la_m * la_n, sizeof(double) ); 
    /* space for singular values */
    la_s = (double *) R_alloc( max_m_p, sizeof(double) );
    /* space for U matrix and Vt matrix (singular vectors) */
    la_u = (double *) R_alloc( la_m * max_m_p, sizeof(double) );
    la_vt = (double *) R_alloc( max_m_p * max_m_p, sizeof(double) );
    /* space for la_iwork */
    la_iwork = (int *) R_alloc( 8 * p, sizeof(int) );

    /* ask for optimal size of work array */
    la_lwork = -1;
    F77_CALL(dgesdd)(&la_jobz,
                     &la_m, &la_n, tmpMat, &la_m, la_s,
                     la_u, &la_m,
                     la_vt, &max_m_p,
                     &tmp, &la_lwork, la_iwork, &la_info);
    if (la_info != 0)
        error("error code %d from Lapack routine dgesdd", la_info);
    la_lwork = (int) tmp;
    la_work = (double *) R_alloc( la_lwork, sizeof(double) );

    /** preliminaries: compute svd of C0, sqrt(V), sqrt(W), etc... **/
    for (i = 0; i < p; i++) {
        for (j = 0; j<i; j++) 
            tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
                REAL(VECTOR_ELT(mod,1))[i + p * j]; /* C0 */
        tmpMat[i + la_m * j] = REAL(VECTOR_ELT(mod,1))[i + p * j];
    }
    F77_CALL(dgesdd)(&la_jobz,
                     &p, &p, tmpMat, &la_m, la_s,
                     la_u, &la_m,
                     la_vt, &max_m_p,
                     la_work, &la_lwork, la_iwork, &la_info);
    if (la_info != 0)
        error("error code %d from Lapack routine dgesdd", la_info);
    for (i = 0; i < p; i++) {
        for (j = 0; j < p; j++)
            Ux[i + j * p] = la_vt[j + i * max_m_p];
        Dx[i] = sqrt( la_s[i] );
    }
    for (i = 0; i < p; i++) {
        for (j = 0; j < i; j++) 
            tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
                REAL(VECTOR_ELT(mod,5))[i + p * j]; /* W */
        tmpMat[i + la_m * j] = REAL(VECTOR_ELT(mod,5))[i + p * j];
    }
    F77_CALL(dgesdd)(&la_jobz,
                     &p, &p, tmpMat, &la_m, la_s,
                     la_u, &la_m,
                     la_vt, &max_m_p,
                     la_work, &la_lwork, la_iwork, &la_info);
    if (la_info != 0)
        error("error code %d from Lapack routine dgesdd", la_info);
    for (i = 0; i < p; i++) {
        tmp = sqrt( la_s[i] );
        for (j = 0; j < p; j++) 
            sqrtW[i + j * p] = tmp * la_vt[i + j * max_m_p];
    }
    for (i = 0; i < m; i++) {
        for (j = 0; j<i; j++) 
            tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
                REAL(VECTOR_ELT(mod,3))[i + m * j]; /* V */
        tmpMat[i + la_m * j] = REAL(VECTOR_ELT(mod,3))[i + m * j];
    }
    F77_CALL(dgesdd)(&la_jobz,
                     &m, &m, tmpMat, &la_m, la_s,
                     la_u, &la_m,
                     la_vt, &max_m_p,
                     la_work, &la_lwork, la_iwork, &la_info);
    if (la_info != 0)
        error("error code %d from Lapack routine dgesdd", la_info);
    warn = 0;
    for (i = 0; i < m; i++) {
      if (la_s[i] < eps) {
	tmp = sqrt(eps);
	if (la_s[i] > 0) warn = 1;
      } else 
	tmp = sqrt(la_s[i]);
      tmp1 = 1 / tmp;
      for (j = 0; j<m; j++) {
	sqrtV[i + j * m] = tmp * la_vt[i + j * max_m_p];
	sqrtVinv[i + j * m] = tmp1 * la_vt[i + j * max_m_p];
      }
    }
    if (warn)
	warning("a numerically singular 'V' has been slightly perturbed to make it nonsingular");
    for (i = 0; i < m; i++) {
        for (j = 0; j < i; j++) {
            tmp = 0.0;
            for (k = 0; k < m; k++)
                tmp += sqrtVinv[k + i * m] * sqrtVinv[k + j * m];
            tmpMat[i + j * la_m] = tmpMat[j + i * la_m] = tmp;
        }
        tmp = 0.0;
        for (k = 0; k < m; k++)
            tmp += SQR( sqrtVinv[k + i * m] );
        tmpMat[i + i * la_m] = tmp;
    }
    for (i = 0; i < p ; i++) 
        for (j = 0; j < m; j++) {
            tmp = 0.0;
            for (k = 0; k < m; k++)
                tmp += sFF[k + i * m] * tmpMat[k + j * la_m];
            tF_Vinv[i + j * p] = tmp;
        }

    /** loop over observations **/
    for (t = 0; t < n; t++) { 
	/** check for missing values **/
	numNA = 0;
	for (i = 0; i < m; i++)
	    if (ISNA(sy[t + i * n]))  
		whereNA[numNA++] = i; 

	if (numNA == 0) { /** no missing values **/

	    /** Prior **/
	    for (i = 0; i < p; i++) {
		tmp = 0.0;
		for (k = 0; k < p; k++)
		    tmp += sGG[i + p * k] * sm0[k];
		a[i] = tmp;
	    }
        
	    for (i = 0; i < p; i++) {
		tmp1 = Dx[i];
		for (j = 0; j < p; j++) {
		    tmp = 0.0;
		    for (l = 0; l < p; l++)
			tmp += sGG[j + l * p] * Ux[i * p + l];
		    tmpMat[i + j * la_m] = tmp * tmp1;
		}
            
	    }
	    for (i = 0; i < p; i++) 
		for (j = 0; j < p; j++) 
		    tmpMat[i + p + j * la_m] = sqrtW[i + j * p];
	    l = 2 * p;
	    F77_CALL(dgesdd)(&la_jobz,
			     &l, &p, tmpMat, &la_m, la_s,
			     la_u, &la_m,
			     la_vt, &max_m_p,
			     la_work, &la_lwork, la_iwork, &la_info);
	    if (la_info != 0)
		error("error code %d from Lapack routine dgesdd", la_info);
	    for (i = 0; i < p; i++) {
		for (j = 0; j < p; j++)
		    Ux_prior[i + j * p] = la_vt[j + i * max_m_p];
		Dx_prior[i] = la_s[i];
	    }

	    /** One-step forecast **/
	    for (i = 0; i < m; i++) {
		tmp = 0.0;
		for (j = 0; j < p; j++)
		    tmp += sFF[i + j * m] * a[j];
		f[i] = tmp;
	    }
	    for (i = 0; i < p; i++) {
		tmp1 = Dx_prior[i];
		for (j = 0; j < m; j++) {
		    tmp = 0.0;
		    for (l = 0; l < p; l++)
			tmp += sFF[j + l * m] * Ux_prior[l + i * p];
		    tmpMat[i + j * la_m] = tmp * tmp1;
		}
            
	    }
	    for (i = 0; i < m; i++) 
		for (j = 0; j < m; j++) 
		    tmpMat[i + p + j * la_m] = sqrtV[i + j * m];
        
	    l = p + m;
	    F77_CALL(dgesdd)(&la_jobz,
			     &l, &m, tmpMat, &la_m, la_s,
			     la_u, &la_m,
			     la_vt, &max_m_p,
			     la_work, &la_lwork, la_iwork, &la_info);
	    if (la_info != 0)
		error("error code %d from Lapack routine dgesdd", la_info);
	    for (i = 0; i < m; i++) {
		for (j = 0; j < m; j++)
		    Uy[i + j * m] = la_vt[j + i * max_m_p];
		Dy[i] = la_s[i];
	    }
        
	    /** Posterior **/
	    for (i = 0; i < m; i++)
		for (j = 0; j < p; j++) {
		    tmp = 0.0;
		    for (k = 0; k < m; k++)
			tmp += sqrtVinv[i + k * m] * sFF[k + j * m];
		    tmpMat2[i + j * m] = tmp;
		}
	    for (i = 0; i < m; i++)
		for (j = 0; j < p; j++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += tmpMat2[i + k * m] * Ux_prior[k + j * p];
		    tmpMat[i + j * la_m] = tmp;
		}
	    for (i = 0; i < p; i++) {
		tmp = 1 / Dx_prior[i];
		tmpMat[i + m + i * la_m] = R_FINITE(tmp) ? tmp : 0.0;
		for (j = i + 1; j < p; j++) 
		    tmpMat[j + m + i * la_m] = tmpMat[i + m + j * la_m] = 0.0;
	    }
	    l = p + m;
	    F77_CALL(dgesdd)(&la_jobz,
			     &l, &p, tmpMat, &la_m, la_s,
			     la_u, &la_m,
			     la_vt, &max_m_p,
			     la_work, &la_lwork, la_iwork, &la_info);
	    if (la_info != 0)
		error("error code %d from Lapack routine dgesdd", la_info);
	    for (i = 0; i < p; i++) {
		for (j = 0; j < p; j++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += Ux_prior[i + k * p] * la_vt[j + k * max_m_p];
		    Ux[i + j * p] = tmp;
		}
		tmp = 1 / la_s[i];
		Dx[i] = R_FINITE(tmp) ? tmp : 0.0;
	    }
	    for (i = 0; i < m; i++)
		e[i] = sy[t + i * n] - f[i];
	    for (i = 0; i < p; i++)
		for (j = 0; j < m; j++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += SQR(Dx[i]) * Ux[k + i * p] * tF_Vinv[k + j * p];
		    tmpMat[i + j * la_m] = tmp;
		}
	    for (i = 0; i < p; i++)
		for (j = 0; j < m; j++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += Ux[i + k * p] * tmpMat[k + j * la_m];
		    tmpMat2[j + i * m] = tmp;
		}
	    for (i = 0; i < p; i++) {
		tmp = a[i];
		for (j = 0; j < m; j++)
		    tmp += tmpMat2[j + i * m] * e[j];
		sm0[i] = tmp;
	    }

	    /** Update negative log likelihood **/
	    for (i = 0; i < m; i++) {
		tmp =0.0;
		for (j = 0; j < m; j++)
		    tmp += Uy[j + i * m] * e[j];
		ll += SQR( tmp / Dy[i] ) + 2.0 * log( Dy[i] );
	    }
	} else {
	    if (numNA == m) { /** all missing **/

		for (i = 0; i < p; i++) {
		    tmp = 0.0;
		    for (j = 0; j < p; j++)
			tmp += sGG[i + j * p] * sm0[j];
		    tmpMat2[i] = tmp;
		}
		for (i = 0; i < p; i++)
		    sm0[i] = tmpMat2[i];
		
		for (i = 0; i < p; i++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += sGG[i + p * k] * sm0[k];
		    a[i] = tmp;
		}
		for (i = 0; i < p; i++) {
		    tmp1 = Dx[i];
		    for (j = 0; j < p; j++) {
			tmp = 0.0;
			for (l = 0; l < p; l++)
			    tmp += sGG[j + l * p] * Ux[i * p + l];
			tmpMat[i + j * la_m] = tmp * tmp1;
		    }
		    
		}
		for (i = 0; i < p; i++) 
		    for (j = 0; j < p; j++) 
			tmpMat[i + p + j * la_m] = sqrtW[i + j * p];
		l = 2 * p;
		F77_CALL(dgesdd)(&la_jobz,
				 &l, &p, tmpMat, &la_m, la_s,
				 la_u, &la_m,
				 la_vt, &max_m_p,
				 la_work, &la_lwork, la_iwork, &la_info);
		if (la_info != 0)
		    error("error code %d from Lapack routine dgesdd", la_info);
		for (i = 0; i < p; i++) {
		    for (j = 0; j < p; j++)
			Ux[i + j * p] = la_vt[j + i * max_m_p];
		    Dx[i] = la_s[i];
		}

	    } else { /** some missing **/

		numGood = m - numNA;
		for (i = j = k = 0; i < m; i++) 
		    if (k + 1 <= numNA && whereNA[k] == i) 
			k++;
		    else
			good[j++] = i;
		for (i = 0; i < numGood; i++) {
		    for (j = 0; j < i; j++) 
			tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
			    REAL(VECTOR_ELT(mod,3))[good[i] + m * good[j]]; /* V */
		    tmpMat[i + la_m * j] = REAL(VECTOR_ELT(mod,3))[good[i] + m * good[j]];
		}
		F77_CALL(dgesdd)(&la_jobz,
				 &numGood, &numGood, tmpMat, &la_m, la_s,
				 la_u, &la_m,
				 la_vt, &max_m_p,
				 la_work, &la_lwork, la_iwork, &la_info);
		if (la_info != 0)
		    error("error code %d from Lapack routine dgesdd", la_info);
		for (i = 0; i < numGood; i++) {
		    tmp = sqrt( la_s[i] );
		    tmp1 = 1 / tmp;
		    tmp1 = R_FINITE(tmp1) ? tmp1 : 0.0;
		    for (j = 0; j < numGood; j++) {
			sqrtVTMP[i + j * m] = tmp * la_vt[i + j * max_m_p]; 
			sqrtVinvTMP[i + j * m] = tmp1 * la_vt[i + j * max_m_p];
		    }
		}

		for (i = 0; i < numGood; i++) {
		    for (j = 0; j < i; j++) {
			tmp = 0.0;
			for (k = 0; k < numGood; k++)
			    tmp += sqrtVinvTMP[k + i * m] * sqrtVinvTMP[k + j * m];
			tmpMat[i + j * la_m] = tmpMat[j + i * la_m] = tmp;
		    }
		    tmp = 0.0;
		    for (k = 0; k < numGood; k++)
			tmp += SQR( sqrtVinvTMP[k + i * m] );
		    tmpMat[i + i * la_m] = tmp;
		}
		for (i = 0; i < p ; i++) 
		    for (j = 0; j < numGood; j++) {
			tmp = 0.0;
			for (k = 0; k < numGood; k++)
			    tmp += sFF[good[k] + i * m] * tmpMat[k + j * la_m];
			tF_VinvTMP[i + j * p] = tmp;
		    }

		/** Prior **/
		for (i = 0; i < p; i++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += sGG[i + p * k] * sm0[k];
		    a[i] = tmp;
		}
		
		for (i = 0; i < p; i++) {
		    tmp1 = Dx[i];
		    for (j = 0; j < p; j++) {
			tmp = 0.0;
			for (l = 0; l < p; l++)
			    tmp += sGG[j + l * p] * Ux[i * p + l];
			tmpMat[i + j * la_m] = tmp * tmp1;
		    }
            
		}
		for (i = 0; i < p; i++) 
		    for (j = 0; j < p; j++) 
			tmpMat[i + p + j * la_m] = sqrtW[i + j * p];
		l = 2 * p;
		F77_CALL(dgesdd)(&la_jobz,
				 &l, &p, tmpMat, &la_m, la_s,
				 la_u, &la_m,
				 la_vt, &max_m_p,
				 la_work, &la_lwork, la_iwork, &la_info);
		if (la_info != 0)
		    error("error code %d from Lapack routine dgesdd", la_info);
		for (i = 0; i < p; i++) {
		    for (j = 0; j < p; j++)
			Ux_prior[i + j * p] = la_vt[j + i * max_m_p];
		    Dx_prior[i] = la_s[i];
		}

		/** One-step forecast **/
		for (i = 0; i < numGood; i++) {
		    tmp = 0.0;
		    for (j = 0; j < p; j++)
			tmp += sFF[good[i] + j * m] * a[j];
		    f[i] = tmp;
		}
		for (i = 0; i < p; i++) {
		    tmp1 = Dx_prior[i];
		    for (j = 0; j < numGood; j++) {
			tmp = 0.0;
			for (l = 0; l < p; l++)
			    tmp += sFF[good[j] + l * m] * Ux_prior[l + i * p];
			tmpMat[i + j * la_m] = tmp * tmp1;
		    }
            
		}
		for (i = 0; i < numGood; i++) 
		    for (j = 0; j < numGood; j++) 
			tmpMat[i + p + j * la_m] = sqrtVTMP[i + j * m];

		l = p + numGood;
		F77_CALL(dgesdd)(&la_jobz,
				 &l, &numGood, tmpMat, &la_m, la_s,
				 la_u, &la_m,
				 la_vt, &max_m_p,
				 la_work, &la_lwork, la_iwork, &la_info);
		if (la_info != 0)
		    error("error code %d from Lapack routine dgesdd", la_info);
		for (i = 0; i < numGood; i++) {
		    for (j = 0; j < numGood; j++)
			Uy[i + j * m] = la_vt[j + i * max_m_p];
		    Dy[i] = la_s[i];
		}

		/** Posterior **/
		for (i = 0; i < numGood; i++)
		    for (j = 0; j < p; j++) {
			tmp = 0.0;
			for (k = 0; k < numGood; k++)
			    tmp += sqrtVinvTMP[i + k * m] * sFF[good[k] + j * m];
			tmpMat2[i + j * m] = tmp;
		    }
		for (i = 0; i < numGood; i++)
		    for (j = 0; j < p; j++) {
			tmp = 0.0;
			for (k = 0; k < p; k++)
			    tmp += tmpMat2[i + k * m] * Ux_prior[k + j * p];
			tmpMat[i + j * la_m] = tmp;
		    }
		for (i = 0; i < p; i++) {
		    tmp = 1 / Dx_prior[i];
		    tmpMat[i + numGood + i * la_m] = R_FINITE(tmp) ? tmp : 0.0;
		    for (j = i + 1; j < p; j++) 
			tmpMat[j + numGood + i * la_m] = tmpMat[i + numGood + j * la_m] = 0.0;
		}
		l = p + numGood;
		F77_CALL(dgesdd)(&la_jobz,
				 &l, &p, tmpMat, &la_m, la_s,
				 la_u, &la_m,
				 la_vt, &max_m_p,
				 la_work, &la_lwork, la_iwork, &la_info);
		if (la_info != 0)
		    error("error code %d from Lapack routine dgesdd", la_info);
		for (i = 0; i < p; i++) {
		    for (j = 0; j < p; j++) {
			tmp = 0.0;
			for (k = 0; k < p; k++)
			    tmp += Ux_prior[i + k * p] * la_vt[j + k * max_m_p];
			Ux[i + j * p] = tmp;
		    }
		    tmp = 1 / la_s[i];
		    Dx[i] = R_FINITE(tmp) ? tmp : 0.0;
		}
		for (i = 0; i < numGood; i++)
		    e[i] = sy[t + good[i] * n] - f[i];
		for (i = 0; i < p; i++)
		    for (j = 0; j < numGood; j++) {
			tmp = 0.0;
			for (k = 0; k < p; k++)
			    tmp += SQR(Dx[i]) * Ux[k + i * p] * tF_VinvTMP[k + j * p];
			tmpMat[i + j * la_m] = tmp;
		    }
		for (i = 0; i < p; i++)
		    for (j = 0; j < numGood; j++) {
			tmp = 0.0;
			for (k = 0; k < p; k++)
			    tmp += Ux[i + k * p] * tmpMat[k + j * la_m];
			tmpMat2[j + i * m] = tmp;
		    }
		for (i = 0; i < p; i++) {
		    tmp = a[i];
		    for (j = 0; j < numGood; j++)
   			tmp += tmpMat2[j + i * m] * e[j];
		    sm0[i] = tmp;
		}
		
		/** Update negative log likelihood **/
		for (i = 0; i < numGood; i++) {
		    tmp =0.0;
		    for (j = 0; j < numGood; j++)
			tmp += Uy[j + i * m] * e[j];
		    ll += SQR( tmp / Dy[i] ) + 2.0 * log( Dy[i] );
		}
	    }
	}
    }

    REAL(val)[0] = 0.5 * ll;
    UNPROTECT(1);
    return(val);

}


SEXP dlmFilter(SEXP y, SEXP mod, SEXP tvFF, SEXP tvV, SEXP tvGG, SEXP tvW)
{
/***** Warning: the function relies on the order of the  *****/
/***** components of the list 'mod', not on their names. *****/     

    SEXP val, mR, UxR, DxR, aR, Ux_priorR, Dx_priorR, fR;
    int i, j, k, l, p, m, n, nPlus, t, max_m_p, la_m, la_n, la_info=0, la_lwork, *la_iwork,
	numNA, *whereNA, numGood, *good, warn;
    int stvFF=INTEGER(tvFF)[0], stvV=INTEGER(tvV)[0], stvGG=INTEGER(tvGG)[0], 
	stvW=INTEGER(tvW)[0], stvFV, *sJFF, *sJV, *sJGG, *sJW, nrJFF, nrJV, nrJGG, nrJW;
    double *sy=REAL(y), *sm0, *sFF, *sV, *sGG, *sW, *sX, *Ux,  
        *Dx, *sqrtV, *sqrtW, 
        *sqrtVinv, *a, *Ux_prior, *Dx_prior, *f, *Uy, *Dy,
        *e, *tF_Vinv;
    double tmp, tmp1, *tmpMat, *tmpMat2, *la_s, *la_u, *la_vt, *la_work,
	*sqrtVinvTMP, *tF_VinvTMP, eps;
    char la_jobz='S';

    eps = DBL_EPSILON * 100.0;
    m = INTEGER(getAttrib( VECTOR_ELT(mod,2), R_DimSymbol ))[0];
    p = INTEGER(getAttrib( VECTOR_ELT(mod,2), R_DimSymbol ))[1];
    max_m_p = m > p ? m : p;
    la_n = max_m_p;
    la_m = la_n + p;
    n = length(y) / m; 
    nPlus = n + 1;
    PROTECT(mR = allocMatrix(REALSXP, nPlus, p));
    PROTECT(UxR = allocVector(VECSXP, nPlus));
    PROTECT(DxR = allocMatrix(REALSXP, nPlus, p));
    PROTECT(aR = allocMatrix(REALSXP, n, p));
    PROTECT(Ux_priorR = allocVector(VECSXP, n));
    PROTECT(Dx_priorR = allocMatrix(REALSXP, n, p));
    PROTECT(fR = allocMatrix(REALSXP, n, m));
    for (i = 0; i < p; i++)
	REAL(mR)[i * nPlus] = REAL(VECTOR_ELT(mod,0))[i];
    sm0 = REAL(mR);
    SET_VECTOR_ELT(UxR, 0, allocMatrix(REALSXP, p, p));
    Ux = REAL(VECTOR_ELT(UxR, 0));
    Dx = REAL(DxR);
    a = REAL(aR);
    f = REAL(fR);
    Dx_prior = REAL(Dx_priorR);
    sFF = REAL(VECTOR_ELT(mod,2));
    sV = REAL(VECTOR_ELT(mod,3));
    sGG = REAL(VECTOR_ELT(mod,4));
    sW = REAL(VECTOR_ELT(mod,5));
    sqrtV = (double *) R_alloc( m * m, sizeof(double) );
    sqrtVinv = (double *) R_alloc( m * m, sizeof(double) );
    sqrtW = (double *) R_alloc( p * p, sizeof(double) );
    tF_Vinv = (double *) R_alloc( p * m, sizeof(double) );
    Uy = (double *) R_alloc( m * m, sizeof(double) );
    Dy = (double *) R_alloc( m, sizeof(double) ); 
    e = (double *) R_alloc( m, sizeof(double) );
    tmpMat2 = (double *) R_alloc( m * p, sizeof(double) );

    /* space needed to deal with missing values */
    whereNA = (int *) R_alloc( m, sizeof(int) );
    if (m > 1){
	good = (int *) R_alloc( m, sizeof(int) );
	sqrtVinvTMP = (double *) R_alloc( m * m, sizeof(double) );
	tF_VinvTMP = (double *) R_alloc( p * m, sizeof(double) );
    }

    /* allocate space for a la_m by la_n matrix */
    tmpMat = (double *) R_alloc( la_m * la_n, sizeof(double) ); 
    /* space for singular values */
    la_s = (double *) R_alloc( max_m_p, sizeof(double) );
    /* space for U matrix and Vt matrix (singular vectors) */
    la_u = (double *) R_alloc( la_m * max_m_p, sizeof(double) );
    la_vt = (double *) R_alloc( max_m_p * max_m_p, sizeof(double) );
    /* space for la_iwork */
    la_iwork = (int *) R_alloc( 8 * p, sizeof(int) );

    /* ask for optimal size of work array */
    la_lwork = -1;
    F77_CALL(dgesdd)(&la_jobz,
                     &la_m, &la_n, tmpMat, &la_m, la_s,
                     la_u, &la_m,
                     la_vt, &max_m_p,
                     &tmp, &la_lwork, la_iwork, &la_info);
    if (la_info != 0)
        error("error code %d from Lapack routine dgesdd", la_info);
    la_lwork = (int) tmp;
    la_work = (double *) R_alloc( la_lwork, sizeof(double) );

    /** preliminaries: compute svd of C0, etc... **/
    for (i = 0; i < p; i++) {
        for (j = 0; j<i; j++) 
            tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
                REAL(VECTOR_ELT(mod,1))[i + p * j]; /* C0 */
        tmpMat[i + la_m * j] = REAL(VECTOR_ELT(mod,1))[i + p * j];
    }
    F77_CALL(dgesdd)(&la_jobz,
                     &p, &p, tmpMat, &la_m, la_s,
                     la_u, &la_m,
                     la_vt, &max_m_p,
                     la_work, &la_lwork, la_iwork, &la_info);
    if (la_info != 0)
        error("error code %d from Lapack routine dgesdd", la_info);
    for (i = 0; i < p; i++) {
        for (j = 0; j < p; j++)
            Ux[i + j * p] = la_vt[j + i * max_m_p];
        Dx[i * nPlus] = sqrt( la_s[i] );
    }
    /* time-varying matrices stuff */
    stvFV = stvFF || stvV;
    sX = REAL(VECTOR_ELT(mod,10));
    if (stvFF) {
	sJFF=INTEGER(VECTOR_ELT(mod,6));
	nrJFF=INTEGER(getAttrib( VECTOR_ELT(mod,6), R_DimSymbol ))[0];
    }
    if (stvV) {
	sJV=INTEGER(VECTOR_ELT(mod,7));
	nrJV=INTEGER(getAttrib( VECTOR_ELT(mod,7), R_DimSymbol ))[0];
    } else {
	/* compute sqrtV, time-invariant*/
	for (i = 0; i < m; i++) {
	    for (j = 0; j<i; j++) 
		tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
		    sV[i + m * j];
	    tmpMat[i + la_m * j] = sV[i + m * j];
	}
	F77_CALL(dgesdd)(&la_jobz,
			 &m, &m, tmpMat, &la_m, la_s,
			 la_u, &la_m,
			 la_vt, &max_m_p,
			 la_work, &la_lwork, la_iwork, &la_info);
	if (la_info != 0)
	    error("error code %d from Lapack routine dgesdd", la_info);
	warn = 0;
	for (i = 0; i < m; i++) {
	  if (la_s[i] < eps) {
	    tmp = sqrt(eps);
	    if (la_s[i] > 0) warn = 1;
	  } else 
	    tmp = sqrt(la_s[i]);
	  tmp1 = 1 / tmp;
	  for (j = 0; j<m; j++) {
	    sqrtV[i + j * m] = tmp * la_vt[i + j * max_m_p];
	    sqrtVinv[i + j * m] = tmp1 * la_vt[i + j * max_m_p];
	  }
	}
	if (warn)
	    warning("a numerically singular 'V' has been slightly perturbed to make it nonsingular");
	if (!stvFF) {
	    /* compute also tF_Vinv, time-invariant */
	    for (i = 0; i < m; i++) {
		for (j = 0; j < i; j++) {
		    tmp = 0.0;
		    for (k = 0; k < m; k++)
			tmp += sqrtVinv[k + i * m] * sqrtVinv[k + j * m];
		    tmpMat[i + j * la_m] = tmpMat[j + i * la_m] = tmp;
		}
		tmp = 0.0;
		for (k = 0; k < m; k++)
		    tmp += SQR( sqrtVinv[k + i * m] );
		tmpMat[i + i * la_m] = tmp;
	    }
	    for (i = 0; i < p ; i++) 
		for (j = 0; j < m; j++) {
		    tmp = 0.0;
		    for (k = 0; k < m; k++)
			tmp += sFF[k + i * m] * tmpMat[k + j * la_m];
		    tF_Vinv[i + j * p] = tmp;
		}
	}
    }
    if (stvGG) {
	sJGG=INTEGER(VECTOR_ELT(mod,8));
	nrJGG=INTEGER(getAttrib( VECTOR_ELT(mod,8), R_DimSymbol ))[0];
    }
    if (stvW) {
	sJW=INTEGER(VECTOR_ELT(mod,9));
	nrJW=INTEGER(getAttrib( VECTOR_ELT(mod,9), R_DimSymbol ))[0];
    } else {
	/* compute sqrtW, time-invariant */
	for (i = 0; i < p; i++) {
	    for (j = 0; j < i; j++) 
		tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
		    sW[i + p * j];
	    tmpMat[i + la_m * j] = sW[i + p * j];
	}
	F77_CALL(dgesdd)(&la_jobz,
			 &p, &p, tmpMat, &la_m, la_s,
			 la_u, &la_m,
			 la_vt, &max_m_p,
			 la_work, &la_lwork, la_iwork, &la_info);
	if (la_info != 0)
	    error("error code %d from Lapack routine dgesdd", la_info);
	for (i = 0; i < p; i++) {
	    tmp = sqrt( la_s[i] );
	    for (j = 0; j < p; j++) 
		sqrtW[i + j * p] = tmp * la_vt[i + j * max_m_p];
	}
    }

    /** loop over observations **/
    for (t = 0; t < n; t++) { 
	/** allocate matrices and make pointers point to 'current' **/
	SET_VECTOR_ELT(Ux_priorR, t, allocMatrix(REALSXP, p, p));
	Ux_prior = REAL(VECTOR_ELT(Ux_priorR, t));
	SET_VECTOR_ELT(UxR, t+1, allocMatrix(REALSXP, p, p));
	/** set time-varying matrices **/
	if (stvFF) 
	    for (i = 0; i < nrJFF; i++)
		sFF[ sJFF[i] + m * sJFF[i + nrJFF] ] = sX[ t + n * sJFF[i + 2 * nrJFF] ];
	if (stvV) {
	    for (i = 0; i < nrJV; i++)
		sV[ sJV[i] + m * sJV[i + nrJV] ] = sX[ t + n * sJV[i + 2 * nrJV] ];
	    for (i = 0; i < m; i++) {
		for (j = 0; j<i; j++) 
		    tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
			sV[i + m * j];
		tmpMat[i + la_m * j] = sV[i + m * j];
	    }
	    F77_CALL(dgesdd)(&la_jobz,
			     &m, &m, tmpMat, &la_m, la_s,
			     la_u, &la_m,
			     la_vt, &max_m_p,
			     la_work, &la_lwork, la_iwork, &la_info);
	    if (la_info != 0)
		error("error code %d from Lapack routine dgesdd", la_info);
	    for (i = 0; i < m; i++) {
		tmp = sqrt( la_s[i] );
		tmp1 = 1 / tmp;
		tmp1 = R_FINITE(tmp1) ? tmp1 : 0.0;
		for (j = 0; j<m; j++) {
		    sqrtV[i + j * m] = tmp * la_vt[i + j * max_m_p];
		    sqrtVinv[i + j * m] = tmp1 * la_vt[i + j * max_m_p];
		}
	    }
	}
	if (stvGG) 
	    for (i = 0; i < nrJGG; i++)
		sGG[ sJGG[i] + p * sJGG[i + nrJGG] ] = sX[ t + n * sJGG[i + 2 * nrJGG] ];
	if (stvW) {
	    for (i = 0; i < nrJW; i++)
		sW[ sJW[i] + p * sJW[i + nrJW] ] = sX[ t + n * sJW[i + 2 * nrJW] ];
	    for (i = 0; i < p; i++) {
		for (j = 0; j < i; j++) 
		    tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
			sW[i + p * j];
		tmpMat[i + la_m * j] = sW[i + p * j];
	    }
	    F77_CALL(dgesdd)(&la_jobz,
			     &p, &p, tmpMat, &la_m, la_s,
			     la_u, &la_m,
			     la_vt, &max_m_p,
			     la_work, &la_lwork, la_iwork, &la_info);
	    if (la_info != 0)
		error("error code %d from Lapack routine dgesdd", la_info);
	    for (i = 0; i < p; i++) {
		tmp = sqrt( la_s[i] );
		for (j = 0; j < p; j++) 
		    sqrtW[i + j * p] = tmp * la_vt[i + j * max_m_p];
	    }
	}
	if (stvFV) {
	    for (i = 0; i < m; i++) {
		for (j = 0; j < i; j++) {
		    tmp = 0.0;
		    for (k = 0; k < m; k++)
			tmp += sqrtVinv[k + i * m] * sqrtVinv[k + j * m];
		    tmpMat[i + j * la_m] = tmpMat[j + i * la_m] = tmp;
		}
		tmp = 0.0;
		for (k = 0; k < m; k++)
		    tmp += SQR( sqrtVinv[k + i * m] );
		tmpMat[i + i * la_m] = tmp;
	    }
	    for (i = 0; i < p ; i++) 
		for (j = 0; j < m; j++) {
		    tmp = 0.0;
		    for (k = 0; k < m; k++)
			tmp += sFF[k + i * m] * tmpMat[k + j * la_m];
		    tF_Vinv[i + j * p] = tmp;
		}
	}
	/** check for missing values **/
	numNA = 0;
	for (i = 0; i < m; i++)
	    if (ISNA(sy[i * n]))  
		whereNA[numNA++] = i; 
	
	if (numNA == 0) { /** no missing values **/

	    /** Prior **/
	    for (i = 0; i < p; i++) {
		tmp = 0.0;
		for (k = 0; k < p; k++)
		    tmp += sGG[i + p * k] * sm0[k * nPlus];
		a[i * n] = tmp;
	    }
        
	    for (i = 0; i < p; i++) {
		tmp1 = Dx[i * nPlus];
		for (j = 0; j < p; j++) {
		    tmp = 0.0;
		    for (l = 0; l < p; l++)
			tmp += sGG[j + l * p] * Ux[i * p + l];
		    tmpMat[i + j * la_m] = tmp * tmp1;
		}
            
	    }
	    for (i = 0; i < p; i++) 
		for (j = 0; j < p; j++) 
		    tmpMat[i + p + j * la_m] = sqrtW[i + j * p];
	    l = 2 * p;
	    F77_CALL(dgesdd)(&la_jobz,
			     &l, &p, tmpMat, &la_m, la_s,
			     la_u, &la_m,
			     la_vt, &max_m_p,
			     la_work, &la_lwork, la_iwork, &la_info);
	    if (la_info != 0)
		error("error code %d from Lapack routine dgesdd", la_info);
	    for (i = 0; i < p; i++) {
		for (j = 0; j < p; j++)
		    Ux_prior[i + j * p] = la_vt[j + i * max_m_p];
		Dx_prior[i * n] = la_s[i];
	    }

	    /** One-step forecast **/
	    for (i = 0; i < m; i++) {
		tmp = 0.0;
		for (j = 0; j < p; j++)
		    tmp += sFF[i + j * m] * a[j * n];
		f[i * n] = tmp;
	    }

	    /** Posterior **/
	    sm0++; Dx++;
	    Ux = REAL(VECTOR_ELT(UxR, t+1));
	    for (i = 0; i < m; i++)
		for (j = 0; j < p; j++) {
		    tmp = 0.0;
		    for (k = 0; k < m; k++)
			tmp += sqrtVinv[i + k * m] * sFF[k + j * m];
		    tmpMat2[i + j * m] = tmp;
		}
	    for (i = 0; i < m; i++)
		for (j = 0; j < p; j++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += tmpMat2[i + k * m] * Ux_prior[k + j * p];
		    tmpMat[i + j * la_m] = tmp;
		}
	    for (i = 0; i < p; i++) {
		tmp = 1 / Dx_prior[i * n];
		tmpMat[i + m + i * la_m] = R_FINITE(tmp) ? tmp : 0.0;
		for (j = i + 1; j < p; j++) 
		    tmpMat[j + m + i * la_m] = tmpMat[i + m + j * la_m] = 0.0;
	    }
	    l = p + m;
	    F77_CALL(dgesdd)(&la_jobz,
			     &l, &p, tmpMat, &la_m, la_s,
			     la_u, &la_m,
			     la_vt, &max_m_p,
			     la_work, &la_lwork, la_iwork, &la_info);
	    if (la_info != 0)
		error("error code %d from Lapack routine dgesdd", la_info);
	    for (i = 0; i < p; i++) {
		for (j = 0; j < p; j++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += Ux_prior[i + k * p] * la_vt[j + k * max_m_p];
		    Ux[i + j * p] = tmp;
		}
		tmp = 1 / la_s[i];
		Dx[i * nPlus] = R_FINITE(tmp) ? tmp : 0.0;
	    }
	    for (i = 0; i < m; i++)
		e[i] = sy[i * n] - f[i * n];
	    for (i = 0; i < p; i++)
		for (j = 0; j < m; j++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += SQR(Dx[i * nPlus]) * Ux[k + i * p] * tF_Vinv[k + j * p];
		    tmpMat[i + j * la_m] = tmp;
		}
	    for (i = 0; i < p; i++)
		for (j = 0; j < m; j++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += Ux[i + k * p] * tmpMat[k + j * la_m];
		    tmpMat2[j + i * m] = tmp;
		}
	    for (i = 0; i < p; i++) {
		tmp = a[i * n];
		for (j = 0; j < m; j++)
		    tmp += tmpMat2[j + i * m] * e[j];
		sm0[i * nPlus] = tmp;
	    }

	    /** increment pointers **/
	    sy++; a++; Dx_prior++, f++;

	} else { 
	    if (numNA == m) { /* all missing */

		/** Prior **/
		for (i = 0; i < p; i++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += sGG[i + p * k] * sm0[k * nPlus];
		    a[i * n] = tmp;
		}
        
		for (i = 0; i < p; i++) {
		    tmp1 = Dx[i * nPlus];
		    for (j = 0; j < p; j++) {
			tmp = 0.0;
			for (l = 0; l < p; l++)
			    tmp += sGG[j + l * p] * Ux[i * p + l];
			tmpMat[i + j * la_m] = tmp * tmp1;
		    }
            
		}
		for (i = 0; i < p; i++) 
		    for (j = 0; j < p; j++) 
			tmpMat[i + p + j * la_m] = sqrtW[i + j * p];
		l = 2 * p;
		F77_CALL(dgesdd)(&la_jobz,
				 &l, &p, tmpMat, &la_m, la_s,
				 la_u, &la_m,
				 la_vt, &max_m_p,
				 la_work, &la_lwork, la_iwork, &la_info);
		if (la_info != 0)
		    error("error code %d from Lapack routine dgesdd", la_info);
		for (i = 0; i < p; i++) {
		    for (j = 0; j < p; j++)
			Ux_prior[i + j * p] = la_vt[j + i * max_m_p];
		    Dx_prior[i * n] = la_s[i];
		}

		/** Posterior - same as prior **/
		sm0++; Dx++;
		Ux = REAL(VECTOR_ELT(UxR, t+1));
		for (i = 0; i < p; i++) {
		    sm0[i * nPlus] = a[i * n];
		    Dx[i * nPlus] = Dx_prior[i * n];
		    for (j = 0; j < p; j++)
			Ux[i + j * p] = Ux_prior[i + j * p];
		}

		/** One-step forecast **/
		for (i = 0; i < m; i++) {
		    tmp = 0.0;
		    for (j = 0; j < p; j++)
			tmp += sFF[i + j * m] * a[j * n];
		    f[i * n] = tmp;
		}

		/** increment pointers **/
		sy++; a++; Dx_prior++, f++;

	    } else { /* some missing */

		numGood = m - numNA;
		for (i = j = k = 0; i < m; i++) 
		    if (k + 1 <= numNA && whereNA[k] == i) 
			k++;
		    else
			good[j++] = i;
		for (i = 0; i < numGood; i++) {
		    for (j = 0; j < i; j++) 
			tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
			    REAL(VECTOR_ELT(mod,3))[good[i] + m * good[j]]; /* V */
		    tmpMat[i + la_m * j] = REAL(VECTOR_ELT(mod,3))[good[i] + m * good[j]];
		}
		F77_CALL(dgesdd)(&la_jobz,
				 &numGood, &numGood, tmpMat, &la_m, la_s,
				 la_u, &la_m,
				 la_vt, &max_m_p,
				 la_work, &la_lwork, la_iwork, &la_info);
		if (la_info != 0)
		    error("error code %d from Lapack routine dgesdd", la_info);
		for (i = 0; i < numGood; i++) {
		    tmp = sqrt( la_s[i] );
		    tmp1 = 1 / tmp;
		    tmp1 = R_FINITE(tmp1) ? tmp1 : 0.0;
		    for (j = 0; j < numGood; j++) 
			sqrtVinvTMP[i + j * m] = tmp1 * la_vt[i + j * max_m_p];
		    
		}

		for (i = 0; i < numGood; i++) {
		    for (j = 0; j < i; j++) {
			tmp = 0.0;
			for (k = 0; k < numGood; k++)
			    tmp += sqrtVinvTMP[k + i * m] * sqrtVinvTMP[k + j * m];
			tmpMat[i + j * la_m] = tmpMat[j + i * la_m] = tmp;
		    }
		    tmp = 0.0;
		    for (k = 0; k < numGood; k++)
			tmp += SQR( sqrtVinvTMP[k + i * m] );
		    tmpMat[i + i * la_m] = tmp;
		}
		for (i = 0; i < p ; i++) 
		    for (j = 0; j < numGood; j++) {
			tmp = 0.0;
			for (k = 0; k < numGood; k++)
			    tmp += sFF[good[k] + i * m] * tmpMat[k + j * la_m];
			tF_VinvTMP[i + j * p] = tmp;
		    }

		/** Prior **/
		for (i = 0; i < p; i++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += sGG[i + p * k] * sm0[k * nPlus];
		    a[i * n] = tmp;
		}

		for (i = 0; i < p; i++) {
		    tmp1 = Dx[i * nPlus];
		    for (j = 0; j < p; j++) {
			tmp = 0.0;
			for (l = 0; l < p; l++)
			    tmp += sGG[j + l * p] * Ux[i * p + l];
			tmpMat[i + j * la_m] = tmp * tmp1;
		    }
            
		}
		for (i = 0; i < p; i++) 
		    for (j = 0; j < p; j++) 
			tmpMat[i + p + j * la_m] = sqrtW[i + j * p];
		l = 2 * p;
		F77_CALL(dgesdd)(&la_jobz,
				 &l, &p, tmpMat, &la_m, la_s,
				 la_u, &la_m,
				 la_vt, &max_m_p,
				 la_work, &la_lwork, la_iwork, &la_info);
		if (la_info != 0)
		    error("error code %d from Lapack routine dgesdd", la_info);
		for (i = 0; i < p; i++) {
		    for (j = 0; j < p; j++)
			Ux_prior[i + j * p] = la_vt[j + i * max_m_p];
		    Dx_prior[i * n] = la_s[i];
		}

		/** One-step forecast **/
		for (i = 0; i < m; i++) {
		    tmp = 0.0;
		    for (j = 0; j < p; j++)
			tmp += sFF[i + j * m] * a[j * n];
		    f[i * n] = tmp;
		}

		/** Posterior **/
		sm0++; Dx++;
		Ux = REAL(VECTOR_ELT(UxR, t+1));
		for (i = 0; i < numGood; i++)
		    for (j = 0; j < p; j++) {
			tmp = 0.0;
			for (k = 0; k < numGood; k++)
			    tmp += sqrtVinvTMP[i + k * m] * sFF[good[k] + j * m];
			tmpMat2[i + j * m] = tmp;
		    }
		for (i = 0; i < numGood; i++)
		    for (j = 0; j < p; j++) {
			tmp = 0.0;
			for (k = 0; k < p; k++)
			    tmp += tmpMat2[i + k * m] * Ux_prior[k + j * p];
			tmpMat[i + j * la_m] = tmp;
		    }
		for (i = 0; i < p; i++) {
		    tmp = 1 / Dx_prior[i * n];
		    tmpMat[i + numGood + i * la_m] = R_FINITE(tmp) ? tmp : 0.0;
		    for (j = i + 1; j < p; j++) 
			tmpMat[j + numGood + i * la_m] = tmpMat[i + numGood + j * la_m] = 0.0;
		}
		l = p + numGood;
		F77_CALL(dgesdd)(&la_jobz,
				 &l, &p, tmpMat, &la_m, la_s,
				 la_u, &la_m,
				 la_vt, &max_m_p,
				 la_work, &la_lwork, la_iwork, &la_info);
		if (la_info != 0)
		    error("error code %d from Lapack routine dgesdd", la_info);
		for (i = 0; i < p; i++) {
		    for (j = 0; j < p; j++) {
			tmp = 0.0;
			for (k = 0; k < p; k++)
			    tmp += Ux_prior[i + k * p] * la_vt[j + k * max_m_p];
			Ux[i + j * p] = tmp;
		    }
		    tmp = 1 / la_s[i];
		    Dx[i * nPlus] = R_FINITE(tmp) ? tmp : 0.0;
		}
		for (i = 0; i < numGood; i++)
		    e[i] = sy[good[i] * n] - f[good[i] * n];
		for (i = 0; i < p; i++)
		    for (j = 0; j < numGood; j++) {
			tmp = 0.0;
			for (k = 0; k < p; k++)
			    tmp += SQR(Dx[i * nPlus]) * Ux[k + i * p] * tF_VinvTMP[k + j * p];
			tmpMat[i + j * la_m] = tmp;
		    }
		for (i = 0; i < p; i++)
		    for (j = 0; j < numGood; j++) {
			tmp = 0.0;
			for (k = 0; k < p; k++)
			    tmp += Ux[i + k * p] * tmpMat[k + j * la_m];
			tmpMat2[j + i * m] = tmp;
		    }
		for (i = 0; i < p; i++) {
		    tmp = a[i * n];
		    for (j = 0; j < numGood; j++)
			tmp += tmpMat2[j + i * m] * e[j];
		    sm0[i * nPlus] = tmp;
		}

		/** increment pointers **/
		sy++; a++; Dx_prior++, f++;
	    }
	}
    }

    PROTECT(val = allocVector(VECSXP, 7));
    SET_VECTOR_ELT(val, 0, mR);
    SET_VECTOR_ELT(val, 1, UxR);
    SET_VECTOR_ELT(val, 2, DxR);
    SET_VECTOR_ELT(val, 3, aR);
    SET_VECTOR_ELT(val, 4, Ux_priorR);
    SET_VECTOR_ELT(val, 5, Dx_priorR);
    SET_VECTOR_ELT(val, 6, fR);
    UNPROTECT(8);
    
    return(val);
}

SEXP dlmFilter0(SEXP y, SEXP mod)
{
/***** Warning: the function relies on the order of the  *****/
/***** components of the list 'mod', not on their names. *****/     

    SEXP val, mR, UxR, DxR, aR, Ux_priorR, Dx_priorR, fR;
    int i, j, k, l, p, m, n, nPlus, t, max_m_p, la_m, la_n, la_info=0, la_lwork, *la_iwork,
	numNA, *whereNA, numGood, *good, warn;
    double *sy=REAL(y), *sm0, *sFF, *sGG, *Ux,  
        *Dx, *sqrtW, 
        *sqrtVinv, *a, *Ux_prior, *Dx_prior, *f, *Uy, *Dy,
        *e, *tF_Vinv;
    double tmp, tmp1, *tmpMat, *tmpMat2, *la_s, *la_u, *la_vt, *la_work,
        *sqrtVinvTMP, *tF_VinvTMP, eps;
    char la_jobz='S';

    eps = DBL_EPSILON * 100.0;
    m = INTEGER(getAttrib( VECTOR_ELT(mod,2), R_DimSymbol ))[0];
    p = INTEGER(getAttrib( VECTOR_ELT(mod,2), R_DimSymbol ))[1];
    max_m_p = m > p ? m : p;
    la_n = max_m_p;
    la_m = la_n + p;
    n = length(y) / m; 
    nPlus = n + 1;
    PROTECT(mR = allocMatrix(REALSXP, nPlus, p));
    PROTECT(UxR = allocVector(VECSXP, nPlus));
    PROTECT(DxR = allocMatrix(REALSXP, nPlus, p));
    PROTECT(aR = allocMatrix(REALSXP, n, p));
    PROTECT(Ux_priorR = allocVector(VECSXP, n));
    PROTECT(Dx_priorR = allocMatrix(REALSXP, n, p));
    PROTECT(fR = allocMatrix(REALSXP, n, m));
    for (i = 0; i < p; i++)
	REAL(mR)[i * nPlus] = REAL(VECTOR_ELT(mod,0))[i];
    sm0 = REAL(mR);
    SET_VECTOR_ELT(UxR, 0, allocMatrix(REALSXP, p, p));
    Ux = REAL(VECTOR_ELT(UxR, 0));
    Dx = REAL(DxR);
    a = REAL(aR);
    f = REAL(fR);
    Dx_prior = REAL(Dx_priorR);
    sFF = REAL(VECTOR_ELT(mod,2));
    sGG = REAL(VECTOR_ELT(mod,4));
    sqrtVinv = (double *) R_alloc( m * m, sizeof(double) );
    sqrtW = (double *) R_alloc( p * p, sizeof(double) );
    tF_Vinv = (double *) R_alloc( p * m, sizeof(double) );
    Uy = (double *) R_alloc( m * m, sizeof(double) );
    Dy = (double *) R_alloc( m, sizeof(double) ); 
    e = (double *) R_alloc( m, sizeof(double) );
    tmpMat2 = (double *) R_alloc( m * p, sizeof(double) );

    /* space needed to deal with missing values */
    whereNA = (int *) R_alloc( m, sizeof(int) );
    if (m > 1){
	good = (int *) R_alloc( m, sizeof(int) );
	sqrtVinvTMP = (double *) R_alloc( m * m, sizeof(double) );
	tF_VinvTMP = (double *) R_alloc( p * m, sizeof(double) );
    }

    /* allocate space for a la_m by la_n matrix */
    tmpMat = (double *) R_alloc( la_m * la_n, sizeof(double) ); 
    /* space for singular values */
    la_s = (double *) R_alloc( max_m_p, sizeof(double) );
    /* space for U matrix and Vt matrix (singular vectors) */
    la_u = (double *) R_alloc( la_m * max_m_p, sizeof(double) );
    la_vt = (double *) R_alloc( max_m_p * max_m_p, sizeof(double) );
    /* space for la_iwork */
    la_iwork = (int *) R_alloc( 8 * p, sizeof(int) );

    /* ask for optimal size of work array */
    la_lwork = -1;
    F77_CALL(dgesdd)(&la_jobz,
                     &la_m, &la_n, tmpMat, &la_m, la_s,
                     la_u, &la_m,
                     la_vt, &max_m_p,
                     &tmp, &la_lwork, la_iwork, &la_info);
    if (la_info != 0)
        error("error code %d from Lapack routine dgesdd", la_info);
    la_lwork = (int) tmp;
    la_work = (double *) R_alloc( la_lwork, sizeof(double) );

    /** preliminaries: compute svd of C0, sqrt(V), sqrt(W), etc... **/
    for (i = 0; i < p; i++) {
	for (j = 0; j<i; j++) 
            tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
                REAL(VECTOR_ELT(mod,1))[i + p * j]; /* C0 */
        tmpMat[i + la_m * j] = REAL(VECTOR_ELT(mod,1))[i + p * j];
    }
    F77_CALL(dgesdd)(&la_jobz,
                     &p, &p, tmpMat, &la_m, la_s,
                     la_u, &la_m,
                     la_vt, &max_m_p,
                     la_work, &la_lwork, la_iwork, &la_info);
    if (la_info != 0)
        error("error code %d from Lapack routine dgesdd", la_info);
    for (i = 0; i < p; i++) {
        for (j = 0; j < p; j++)
            Ux[i + j * p] = la_vt[j + i * max_m_p];
        Dx[i * nPlus] = sqrt( la_s[i] );
    }
    for (i = 0; i < p; i++) {
        for (j = 0; j < i; j++) 
            tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
                REAL(VECTOR_ELT(mod,5))[i + p * j]; /* W */
        tmpMat[i + la_m * j] = REAL(VECTOR_ELT(mod,5))[i + p * j];
    }
    F77_CALL(dgesdd)(&la_jobz,
                     &p, &p, tmpMat, &la_m, la_s,
                     la_u, &la_m,
                     la_vt, &max_m_p,
                     la_work, &la_lwork, la_iwork, &la_info);
    if (la_info != 0)
        error("error code %d from Lapack routine dgesdd", la_info);
    for (i = 0; i < p; i++) {
        tmp = sqrt( la_s[i] );
        for (j = 0; j < p; j++) 
            sqrtW[i + j * p] = tmp * la_vt[i + j * max_m_p];
    }
    for (i = 0; i < m; i++) {
        for (j = 0; j<i; j++) 
            tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
                REAL(VECTOR_ELT(mod,3))[i + m * j]; /* V */
        tmpMat[i + la_m * j] = REAL(VECTOR_ELT(mod,3))[i + m * j];
    }
    F77_CALL(dgesdd)(&la_jobz,
                     &m, &m, tmpMat, &la_m, la_s,
                     la_u, &la_m,
                     la_vt, &max_m_p,
                     la_work, &la_lwork, la_iwork, &la_info);
    if (la_info != 0)
        error("error code %d from Lapack routine dgesdd", la_info);
    warn = 0;
    for (i = 0; i < m; i++) {
      if (la_s[i] < eps) {
	tmp = sqrt(eps);
	if (la_s[i] > 0) warn = 1;
      } else 
	tmp = sqrt(la_s[i]);
      tmp1 = 1 / tmp;
      for (j = 0; j < m; j++) 
	sqrtVinv[i + j * m] = tmp1 * la_vt[i + j * max_m_p];
    }
    if (warn)
	warning("a numerically singular 'V' has been slightly perturbed to make it nonsingular");
    for (i = 0; i < m; i++) {
        for (j = 0; j < i; j++) {
            tmp = 0.0;
            for (k = 0; k < m; k++)
                tmp += sqrtVinv[k + i * m] * sqrtVinv[k + j * m];
            tmpMat[i + j * la_m] = tmpMat[j + i * la_m] = tmp;
        }
        tmp = 0.0;
        for (k = 0; k < m; k++)
            tmp += SQR( sqrtVinv[k + i * m] );
        tmpMat[i + i * la_m] = tmp;
    }
    for (i = 0; i < p ; i++) 
        for (j = 0; j < m; j++) {
            tmp = 0.0;
            for (k = 0; k < m; k++)
                tmp += sFF[k + i * m] * tmpMat[k + j * la_m];
            tF_Vinv[i + j * p] = tmp;
        }

    /** loop over observations **/
    for (t = 0; t < n; t++) { 
	/** allocate matrices and make pointers point to 'current' **/
	SET_VECTOR_ELT(Ux_priorR, t, allocMatrix(REALSXP, p, p));
	Ux_prior = REAL(VECTOR_ELT(Ux_priorR, t));
	SET_VECTOR_ELT(UxR, t+1, allocMatrix(REALSXP, p, p));

	/** check for missing values **/
	numNA = 0;
	for (i = 0; i < m; i++)
	    if (ISNA(sy[i * n]))  
		whereNA[numNA++] = i; 
	
	if (numNA == 0) { /** no missing values **/

	    /** Prior **/
	    for (i = 0; i < p; i++) {
		tmp = 0.0;
		for (k = 0; k < p; k++)
		    tmp += sGG[i + p * k] * sm0[k * nPlus];
		a[i * n] = tmp;
	    }
        
	    for (i = 0; i < p; i++) {
		tmp1 = Dx[i * nPlus];
		for (j = 0; j < p; j++) {
		    tmp = 0.0;
		    for (l = 0; l < p; l++)
			tmp += sGG[j + l * p] * Ux[i * p + l];
		    tmpMat[i + j * la_m] = tmp * tmp1;
		}
            
	    }
	    for (i = 0; i < p; i++) 
		for (j = 0; j < p; j++) 
		    tmpMat[i + p + j * la_m] = sqrtW[i + j * p];
	    l = 2 * p;
	    F77_CALL(dgesdd)(&la_jobz,
			     &l, &p, tmpMat, &la_m, la_s,
			     la_u, &la_m,
			     la_vt, &max_m_p,
			     la_work, &la_lwork, la_iwork, &la_info);
	    if (la_info != 0)
		error("error code %d from Lapack routine dgesdd", la_info);
	    for (i = 0; i < p; i++) {
		for (j = 0; j < p; j++)
		    Ux_prior[i + j * p] = la_vt[j + i * max_m_p];
		Dx_prior[i * n] = la_s[i];
	    }

	    /** One-step forecast **/
	    for (i = 0; i < m; i++) {
		tmp = 0.0;
		for (j = 0; j < p; j++)
		    tmp += sFF[i + j * m] * a[j * n];
		f[i * n] = tmp;
	    }

	    /** Posterior **/
	    sm0++; Dx++;
	    Ux = REAL(VECTOR_ELT(UxR, t+1));
	    for (i = 0; i < m; i++)
		for (j = 0; j < p; j++) {
		    tmp = 0.0;
		    for (k = 0; k < m; k++)
			tmp += sqrtVinv[i + k * m] * sFF[k + j * m];
		    tmpMat2[i + j * m] = tmp;
		}
	    for (i = 0; i < m; i++)
		for (j = 0; j < p; j++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += tmpMat2[i + k * m] * Ux_prior[k + j * p];
		    tmpMat[i + j * la_m] = tmp;
		}
	    for (i = 0; i < p; i++) {
		tmp = 1 / Dx_prior[i * n];
		tmpMat[i + m + i * la_m] = R_FINITE(tmp) ? tmp : 0.0;
		for (j = i + 1; j < p; j++) 
		    tmpMat[j + m + i * la_m] = tmpMat[i + m + j * la_m] = 0.0;
	    }
	    l = p + m;
	    F77_CALL(dgesdd)(&la_jobz,
			     &l, &p, tmpMat, &la_m, la_s,
			     la_u, &la_m,
			     la_vt, &max_m_p,
			     la_work, &la_lwork, la_iwork, &la_info);
	    if (la_info != 0)
		error("error code %d from Lapack routine dgesdd", la_info);
	    for (i = 0; i < p; i++) {
		for (j = 0; j < p; j++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += Ux_prior[i + k * p] * la_vt[j + k * max_m_p];
		    Ux[i + j * p] = tmp;
		}
		tmp = 1 / la_s[i];
		Dx[i * nPlus] = R_FINITE(tmp) ? tmp : 0.0;
	    }
	    for (i = 0; i < m; i++)
		e[i] = sy[i * n] - f[i * n];
	    for (i = 0; i < p; i++)
		for (j = 0; j < m; j++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += SQR(Dx[i * nPlus]) * Ux[k + i * p] * tF_Vinv[k + j * p];
		    tmpMat[i + j * la_m] = tmp;
		}
	    for (i = 0; i < p; i++)
		for (j = 0; j < m; j++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += Ux[i + k * p] * tmpMat[k + j * la_m];
		    tmpMat2[j + i * m] = tmp;
		}
	    for (i = 0; i < p; i++) {
		tmp = a[i * n];
		for (j = 0; j < m; j++)
		    tmp += tmpMat2[j + i * m] * e[j];
		sm0[i * nPlus] = tmp;
	    }

	    /** increment pointers **/
	    sy++; a++; Dx_prior++, f++;

	} else { 
	    if (numNA == m) { /* all missing */

	    /** Prior **/
	    for (i = 0; i < p; i++) {
		tmp = 0.0;
		for (k = 0; k < p; k++)
		    tmp += sGG[i + p * k] * sm0[k * nPlus];
		a[i * n] = tmp;
	    }
        
	    for (i = 0; i < p; i++) {
		tmp1 = Dx[i * nPlus];
		for (j = 0; j < p; j++) {
		    tmp = 0.0;
		    for (l = 0; l < p; l++)
			tmp += sGG[j + l * p] * Ux[i * p + l];
		    tmpMat[i + j * la_m] = tmp * tmp1;
		}
            
	    }
	    for (i = 0; i < p; i++) 
		for (j = 0; j < p; j++) 
		    tmpMat[i + p + j * la_m] = sqrtW[i + j * p];
	    l = 2 * p;
	    F77_CALL(dgesdd)(&la_jobz,
			     &l, &p, tmpMat, &la_m, la_s,
			     la_u, &la_m,
			     la_vt, &max_m_p,
			     la_work, &la_lwork, la_iwork, &la_info);
	    if (la_info != 0)
		error("error code %d from Lapack routine dgesdd", la_info);
	    for (i = 0; i < p; i++) {
		for (j = 0; j < p; j++)
		    Ux_prior[i + j * p] = la_vt[j + i * max_m_p];
		Dx_prior[i * n] = la_s[i];
	    }

	    /** Posterior - same as prior **/
	    sm0++; Dx++;
	    Ux = REAL(VECTOR_ELT(UxR, t+1));
	    for (i = 0; i < p; i++) {
		sm0[i * nPlus] = a[i * n];
		Dx[i * nPlus] = Dx_prior[i * n];
		for (j = 0; j < p; j++)
		    Ux[i + j * p] = Ux_prior[i + j * p];
	    }

	    /** One-step forecast **/
	    for (i = 0; i < m; i++) {
		tmp = 0.0;
		for (j = 0; j < p; j++)
		    tmp += sFF[i + j * m] * a[j * n];
		f[i * n] = tmp;
	    }

	    /** increment pointers **/
	    sy++; a++; Dx_prior++, f++;

	    } else { /* some missing */

		numGood = m - numNA;
		for (i = j = k = 0; i < m; i++) 
		    if (k + 1 <= numNA && whereNA[k] == i) 
			k++;
		    else
			good[j++] = i;
		for (i = 0; i < numGood; i++) {
		    for (j = 0; j < i; j++) 
			tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
			    REAL(VECTOR_ELT(mod,3))[good[i] + m * good[j]]; /* V */
		    tmpMat[i + la_m * j] = REAL(VECTOR_ELT(mod,3))[good[i] + m * good[j]];
		}
		F77_CALL(dgesdd)(&la_jobz,
				 &numGood, &numGood, tmpMat, &la_m, la_s,
				 la_u, &la_m,
				 la_vt, &max_m_p,
				 la_work, &la_lwork, la_iwork, &la_info);
		if (la_info != 0)
		    error("error code %d from Lapack routine dgesdd", la_info);
		for (i = 0; i < numGood; i++) {
		    tmp = sqrt( la_s[i] );
		    tmp1 = 1 / tmp;
		    tmp1 = R_FINITE(tmp1) ? tmp1 : 0.0;
		    for (j = 0; j < numGood; j++) 
			sqrtVinvTMP[i + j * m] = tmp1 * la_vt[i + j * max_m_p];
		    
		}

		for (i = 0; i < numGood; i++) {
		    for (j = 0; j < i; j++) {
			tmp = 0.0;
			for (k = 0; k < numGood; k++)
			    tmp += sqrtVinvTMP[k + i * m] * sqrtVinvTMP[k + j * m];
			tmpMat[i + j * la_m] = tmpMat[j + i * la_m] = tmp;
		    }
		    tmp = 0.0;
		    for (k = 0; k < numGood; k++)
			tmp += SQR( sqrtVinvTMP[k + i * m] );
		    tmpMat[i + i * la_m] = tmp;
		}
		for (i = 0; i < p ; i++) 
		    for (j = 0; j < numGood; j++) {
			tmp = 0.0;
			for (k = 0; k < numGood; k++)
			    tmp += sFF[good[k] + i * m] * tmpMat[k + j * la_m];
			tF_VinvTMP[i + j * p] = tmp;
		    }

		/** Prior **/
		for (i = 0; i < p; i++) {
		    tmp = 0.0;
		    for (k = 0; k < p; k++)
			tmp += sGG[i + p * k] * sm0[k * nPlus];
		    a[i * n] = tmp;
		}

		for (i = 0; i < p; i++) {
		    tmp1 = Dx[i * nPlus];
		    for (j = 0; j < p; j++) {
			tmp = 0.0;
			for (l = 0; l < p; l++)
			    tmp += sGG[j + l * p] * Ux[i * p + l];
			tmpMat[i + j * la_m] = tmp * tmp1;
		    }
            
		}
		for (i = 0; i < p; i++) 
		    for (j = 0; j < p; j++) 
			tmpMat[i + p + j * la_m] = sqrtW[i + j * p];
		l = 2 * p;
		F77_CALL(dgesdd)(&la_jobz,
				 &l, &p, tmpMat, &la_m, la_s,
				 la_u, &la_m,
				 la_vt, &max_m_p,
				 la_work, &la_lwork, la_iwork, &la_info);
		if (la_info != 0)
		    error("error code %d from Lapack routine dgesdd", la_info);
		for (i = 0; i < p; i++) {
		    for (j = 0; j < p; j++)
			Ux_prior[i + j * p] = la_vt[j + i * max_m_p];
		    Dx_prior[i * n] = la_s[i];
		}

		/** One-step forecast **/
		for (i = 0; i < m; i++) {
		    tmp = 0.0;
		    for (j = 0; j < p; j++)
			tmp += sFF[i + j * m] * a[j * n];
		    f[i * n] = tmp;
		}

		/** Posterior **/
		sm0++; Dx++;
		Ux = REAL(VECTOR_ELT(UxR, t+1));
		for (i = 0; i < numGood; i++)
		    for (j = 0; j < p; j++) {
			tmp = 0.0;
			for (k = 0; k < numGood; k++)
			    tmp += sqrtVinvTMP[i + k * m] * sFF[good[k] + j * m];
			tmpMat2[i + j * m] = tmp;
		    }
		for (i = 0; i < numGood; i++)
		    for (j = 0; j < p; j++) {
			tmp = 0.0;
			for (k = 0; k < p; k++)
			    tmp += tmpMat2[i + k * m] * Ux_prior[k + j * p];
			tmpMat[i + j * la_m] = tmp;
		    }
		for (i = 0; i < p; i++) {
		    tmp = 1 / Dx_prior[i * n];
		    tmpMat[i + numGood + i * la_m] = R_FINITE(tmp) ? tmp : 0.0;
		    for (j = i + 1; j < p; j++) 
			tmpMat[j + numGood + i * la_m] = tmpMat[i + numGood + j * la_m] = 0.0;
		}
		l = p + numGood;
		F77_CALL(dgesdd)(&la_jobz,
				 &l, &p, tmpMat, &la_m, la_s,
				 la_u, &la_m,
				 la_vt, &max_m_p,
				 la_work, &la_lwork, la_iwork, &la_info);
		if (la_info != 0)
		    error("error code %d from Lapack routine dgesdd", la_info);
		for (i = 0; i < p; i++) {
		    for (j = 0; j < p; j++) {
			tmp = 0.0;
			for (k = 0; k < p; k++)
			    tmp += Ux_prior[i + k * p] * la_vt[j + k * max_m_p];
			Ux[i + j * p] = tmp;
		    }
		    tmp = 1 / la_s[i];
		    Dx[i * nPlus] = R_FINITE(tmp) ? tmp : 0.0;
		}
		for (i = 0; i < numGood; i++)
		    e[i] = sy[good[i] * n] - f[good[i] * n];
		for (i = 0; i < p; i++)
		    for (j = 0; j < numGood; j++) {
			tmp = 0.0;
			for (k = 0; k < p; k++)
			    tmp += SQR(Dx[i * nPlus]) * Ux[k + i * p] * tF_VinvTMP[k + j * p];
			tmpMat[i + j * la_m] = tmp;
		    }
		for (i = 0; i < p; i++)
		    for (j = 0; j < numGood; j++) {
			tmp = 0.0;
			for (k = 0; k < p; k++)
			    tmp += Ux[i + k * p] * tmpMat[k + j * la_m];
			tmpMat2[j + i * m] = tmp;
		    }
		for (i = 0; i < p; i++) {
		    tmp = a[i * n];
		    for (j = 0; j < numGood; j++)
			tmp += tmpMat2[j + i * m] * e[j];
		    sm0[i * nPlus] = tmp;
		}

		/** increment pointers **/
		sy++; a++; Dx_prior++, f++;
	    }
	}
    }

    PROTECT(val = allocVector(VECSXP, 7));
    SET_VECTOR_ELT(val, 0, mR);
    SET_VECTOR_ELT(val, 1, UxR);
    SET_VECTOR_ELT(val, 2, DxR);
    SET_VECTOR_ELT(val, 3, aR);
    SET_VECTOR_ELT(val, 4, Ux_priorR);
    SET_VECTOR_ELT(val, 5, Dx_priorR);
    SET_VECTOR_ELT(val, 6, fR);
    UNPROTECT(8);
    
    return(val);
}


SEXP dlmSmooth0(SEXP mod, SEXP big)
{
/***** Warning: the function relies on the order of the  *****/
/***** components of the list 'mod', not on their names. *****/     

    SEXP val, smoothR, US_R, DS_R;
    int t, i, j, k, p, n, nPlus, la_m, la_n, *la_iwork, la_lwork, la_info=0;
    double *sm, *smooth, *DS, *US, *sGG, *DC, *UC, *DR, *UR, *Ht, *C, *Rinv, 
	*sqrtWinv, tmp, tmp1,
	*tmpMat, *dPointer, *dptr, *dPointer1, *dptr1, *dptr2,
	*la_s, *la_u, *la_vt, *la_work, dBig = REAL(big)[0], eps;
    char la_jobz='S';

    eps = 1.0/dBig;
    p = INTEGER(getAttrib( VECTOR_ELT(mod,7), R_DimSymbol ))[0];
    sGG = REAL(VECTOR_ELT(mod, 6));
    nPlus = length( VECTOR_ELT(mod,1) ); 
    n = nPlus - 1;
    la_m = 2 * p; 
    la_n = p;

    PROTECT(smoothR = allocMatrix(REALSXP, nPlus, p));
    PROTECT(US_R = allocVector(VECSXP, nPlus));
    PROTECT(DS_R = allocMatrix(REALSXP, nPlus, p));
    /* set last value */
    SET_VECTOR_ELT(US_R, n, allocMatrix(REALSXP, p, p));
    US = REAL(VECTOR_ELT(US_R, n));
    DS = REAL(DS_R) + n;
    smooth = REAL(smoothR) + n;
    dptr = REAL(VECTOR_ELT(VECTOR_ELT(mod, 1), n));
    for (i = 0, k = p * p; i < k; i++)
	US[i] = dptr[i];
    dPointer = DS;
    dPointer1 = smooth;
    dptr = REAL(VECTOR_ELT(mod, 2))+ n;
    dptr1 = REAL(VECTOR_ELT(mod, 0)) + n;
    for (i = 0; i < p; i++) {
	*dPointer1 = *dptr1;
	*dPointer = *dptr;
	dPointer += nPlus;
	dPointer1 += nPlus;
	dptr += nPlus;
	dptr1 += nPlus;
    }
    sm = REAL(VECTOR_ELT(mod, 0)) + n - 1; /* m[n-2,] */

    /* allocate space for a la_m by la_n matrix */
    tmpMat = (double *) R_alloc( la_m * la_n, sizeof(double) ); 
    /* space for singular values */
    la_s = (double *) R_alloc( la_n, sizeof(double) );
    /* space for U matrix and Vt matrix (singular vectors) */
    la_u = (double *) R_alloc( la_m * la_n, sizeof(double) );
    la_vt = (double *) R_alloc( la_m * la_n, sizeof(double) );
    /* space for la_iwork */
    la_iwork = (int *) R_alloc( 8 * la_n, sizeof(int) );
    /* space for the square root of W^{-1} */
    sqrtWinv = (double *) R_alloc( p * p, sizeof(double) );
    C = (double *) R_alloc( p * p, sizeof(double) );
    Rinv = (double *) R_alloc( p * p, sizeof(double) );
    Ht = (double *) R_alloc( p * p, sizeof(double) );

    /* ask for optimal size of work array */
    la_lwork = -1;
    F77_CALL(dgesdd)(&la_jobz,
		     &la_m, &la_n, tmpMat, &la_m, la_s,
		     la_u, &la_m,
		     la_vt, &la_n,
		     &tmp, &la_lwork, la_iwork, &la_info);
    if (la_info != 0)
	error("error code %d from Lapack routine dgesdd", la_info);
    la_lwork = (int) tmp;
    la_work = (double *) R_alloc( la_lwork, sizeof(double) );
	
    /** preliminaries: compute sqrt(W^(-1)) **/
    dPointer = REAL(VECTOR_ELT(mod,7)); /* W */
    for (i = 0; i < p; i++) {
	for (j = 0; j < i; j++)
	    tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
		dPointer[i + p * j];
	tmpMat[i + la_m * i] = dPointer[i + p * i];
    }
    F77_CALL(dgesdd)(&la_jobz,
		     &p, &p, tmpMat, &la_m, la_s,
		     la_u, &la_m,
		     la_vt, &la_n,
		     la_work, &la_lwork, la_iwork, &la_info);
    if (la_info != 0)
	error("error code %d from Lapack routine dgesdd", la_info);
    for (i = 0; i < p; i++) {
	tmp = sqrt(la_s[i]);
 	tmp = ( tmp < eps ? dBig : 1.0 / tmp ); 
	for (j = 0; j < p; j++)
	    sqrtWinv[i + j * p] = tmp * la_vt[i + j * la_n];
    }
    
    /** loop over observations **/
    for (t = n; t > 0; t--) { 
	/* compute H */
	dPointer = tmpMat;
	dptr = UC = REAL(VECTOR_ELT(VECTOR_ELT(mod, 1), t-1)); /* U.C[[t]] */
	dptr1 = DC = REAL(VECTOR_ELT(mod, 2)) + t - 1; /* D.C[t,] */
	for (i = 0; i < p; i++) {
	    tmp = *dptr1;
	    for (j = 0; j < p; j++)
		*dPointer++ = *dptr++ * tmp;
	    dptr1 += nPlus;
	    dPointer += p;
	}
	for (i = 0; i< p; i++) {
	    for (j = 0; j < i; j++) {
		dptr = tmpMat + i;
		dptr1 = tmpMat + j;
		tmp = 0.0;
		for (k = 0; k < p; k++) {
		    tmp += *dptr * *dptr1;
		    dptr += la_m;
		    dptr1 += la_m;
		}
		C[i + j * p] = tmp;
	    }
	    dptr = tmpMat + i;
	    tmp = 0.0;
	    for (k = 0; k < p; k++) {
		tmp += SQR(*dptr);
		dptr += la_m;
	    }
	    C[i + i * p] = tmp;
	} /* lower-tri of C */
	dPointer = tmpMat;
	dptr = REAL(VECTOR_ELT(VECTOR_ELT(mod, 4), t-1)); /* U.R[[t]] */
	dptr1 = REAL(VECTOR_ELT(mod, 5)) + t - 1; /* D.R[t,] */
	for (i = 0; i < p; i++) {
	    tmp = 1.0 / *dptr1;
	    if ( !R_FINITE(tmp) ) tmp = 0.0;
	    for (j = 0; j < p; j++)
		*dPointer++ = *dptr++ * tmp;
	    dptr1 += n;
	    dPointer += p;
	}
	for (i = 0; i< p; i++) {
	    for (j = 0; j < i; j++) {
		dptr = tmpMat + i;
		dptr1 = tmpMat + j;
		tmp = 0.0;
		for (k = 0; k < p; k++) {
		    tmp += *dptr * *dptr1;
		    dptr += la_m;
		    dptr1 += la_m;
		}
		Rinv[i + j * p] = tmp;
	    }
	    dptr = tmpMat + i;
	    tmp = 0.0;
	    for (k = 0; k < p; k++) {
		tmp += SQR(*dptr);
		dptr += la_m;
	    }
	    Rinv[i + i * p] = tmp;
	} /* lower-tri of Rinv */
	for (i = 0; i < p; i++) {
	    dPointer = tmpMat + i;
	    for (j = 0; j < p; j++) {
		dptr = Rinv + i;
		dptr1 = sGG + p * j;
		tmp = 0.0;
		for (k = 0; k < i; k++) {
		    tmp += *dptr * *dptr1++;
		    dptr += p;
		}
		tmp += *dptr++ * *dptr1++;
		for (k = i + 1; k < p; k++) 
		    tmp += *dptr++ * *dptr1++;
		*dPointer = tmp;
		dPointer += la_m;
	    }
	}
	for (i = 0; i < p; i++) {
	    dPointer = Ht + i + p * (p - 1);
	    for (j = p - 1; j >= 0; j--) {
		dptr = tmpMat + i + la_m * (p - 1);
		dptr1 = C + p * (1 + j) - 1;
		tmp = 0.0;
		for (k = p - 1; k > j; k--) { 
		    tmp += *dptr * *dptr1--;
		    dptr -= la_m;
		}
		tmp += *dptr * *dptr1;
		for (k = j - 1; k >= 0; k--) {
		    dptr1 -= p;
		    dptr -= la_m;
		    tmp += *dptr * *dptr1;
		}
		*dPointer = tmp;
		dPointer -= p;
	    }
	} /* t(H) */
	for (j = 0; j < p; j++) {
	    dPointer = tmpMat + j * la_m;
	    for (i = 0; i < p; i++) {
		dptr = sqrtWinv + i;
		dptr1 = sGG + j * p;
		tmp = 0.0;
		for (k = 0; k < p; k++) {
		    tmp += *dptr * *dptr1++;
		    dptr += p;
		}
		*dPointer++ = tmp;
	    }
	}
	for (i = 0; i < p; i++) {
	    dPointer = tmpMat + p + i;
	    tmp = 1.0 / *(DC + i * nPlus);
	    if ( !R_FINITE(tmp) ) tmp = 0.0;
	    dptr = UC + i * p;
	    for (j = 0; j < p; j++) {
		*dPointer = *dptr++ * tmp;
		dPointer += la_m;
	    }
	}
	F77_CALL(dgesdd)(&la_jobz,
			 &la_m, &la_n, tmpMat, &la_m, la_s,
			 la_u, &la_m,
			 la_vt, &la_n,
			 la_work, &la_lwork, la_iwork, &la_info);
	if (la_info != 0)
	    error("error code %d from Lapack routine dgesdd", la_info);
	for (i = 0; i < p; i++) {
	    dPointer = tmpMat + i;
	    tmp = 1.0 / la_s[i];
	    if ( !R_FINITE(tmp) ) tmp = 0.0;
	    dptr = la_vt + i;
	    for (j = 0; j < p; j++) {
		*dPointer = *dptr * tmp;
		dPointer += la_m;
		dptr += la_n;
	    }
	}
	for (i = 0; i < p; i++) {
	    tmp1 = *(DS + i * nPlus);
	    dPointer = tmpMat + p + i;
	    for (j = 0; j < p; j++) {
		dptr = US + i * p;
		dptr1 = Ht + j * p;
		tmp = 0.0;
		for (k = 0; k < p; k++)
		    tmp += *dptr++ * *dptr1++;
		*dPointer = tmp * tmp1;
		dPointer += la_m;
	    }
	}
	F77_CALL(dgesdd)(&la_jobz,
			 &la_m, &la_n, tmpMat, &la_m, la_s,
			 la_u, &la_m,
			 la_vt, &la_n,
			 la_work, &la_lwork, la_iwork, &la_info);
	if (la_info != 0)
	    error("error code %d from Lapack routine dgesdd", la_info);
	/* store results */
	SET_VECTOR_ELT(US_R, t-1, allocMatrix(REALSXP, p, p));
	US = REAL(VECTOR_ELT(US_R, t-1));
  	DS--;
	dPointer1 = DS;
	dptr = la_vt;
	dptr1 = la_s;
	for (i = 0; i < p; i++) {
	    *dPointer1 = *dptr1++;
	    dPointer1 += nPlus;
	    dPointer = US + i;
	    for (j = 0; j < p; j++) {
		*dPointer = *dptr++;
		dPointer += p;
	    }
	}
	dPointer = tmpMat;
	dptr = smooth;
	dptr1 = REAL(VECTOR_ELT(mod, 3)) + t - 1; /* a[t,] */
	for (i = 0; i < p; i++) {
	    *dPointer++ = *dptr - *dptr1;
	    dptr += nPlus;
	    dptr1 += n;
	}
	dPointer = --smooth;
	dptr = Ht;
	dptr2 = sm--;
	for (i = 0; i < p; i++) {
	    dptr1 = tmpMat;
	    *dPointer = 0.0;
	    for (j = 0; j < p; j++) 
		*dPointer += *dptr++ * *dptr1++;
	    *dPointer += *dptr2;
	    dPointer += nPlus;
	    dptr2 += nPlus;
	}
    }
	
    /* set up return value */
    PROTECT(val = allocVector(VECSXP, 3));
    SET_VECTOR_ELT(val, 0, smoothR);
    SET_VECTOR_ELT(val, 1, US_R);
    SET_VECTOR_ELT(val, 2, DS_R);
    UNPROTECT(4);
    return(val);

}

SEXP dlmSmooth(SEXP mod, SEXP tvGG, SEXP tvW, SEXP big)
{
/***** Warning: the function relies on the order of the  *****/
/***** components of the list 'mod', not on their names. *****/     

    SEXP val, smoothR, US_R, DS_R;
    int t, i, j, k, p, n, nPlus, la_m, la_n, *la_iwork, la_lwork, la_info=0,
	stvGG=INTEGER(tvGG)[0], stvW=INTEGER(tvW)[0], *sJGG, *sJW, nrJGG, nrJW,
	nr;
    double *sm, *smooth, *DS, *US, *sGG, *DC, *UC, *DR, *UR, *Ht, *C, *Rinv, 
	*sW, *sqrtWinv, *sX, tmp, tmp1,
	*tmpMat, *dPointer, *dptr, *dPointer1, *dptr1, *dptr2,
	*la_s, *la_u, *la_vt, *la_work, dBig = REAL(big)[0], eps;
    char la_jobz='S';

    eps = 1.0/dBig;
    p = INTEGER(getAttrib( VECTOR_ELT(mod,7), R_DimSymbol ))[0];
    sGG = REAL(VECTOR_ELT(mod, 6));
    sX = REAL(VECTOR_ELT(mod, 10));
    nPlus = length( VECTOR_ELT(mod,1) ); 
    n = nPlus - 1;
    la_m = 2 * p; 
    la_n = p;

    PROTECT(smoothR = allocMatrix(REALSXP, nPlus, p));
    PROTECT(US_R = allocVector(VECSXP, nPlus));
    PROTECT(DS_R = allocMatrix(REALSXP, nPlus, p));
    /* set last value */
    SET_VECTOR_ELT(US_R, n, allocMatrix(REALSXP, p, p));
    US = REAL(VECTOR_ELT(US_R, n));
    DS = REAL(DS_R) + n;
    smooth = REAL(smoothR) + n;
    dptr = REAL(VECTOR_ELT(VECTOR_ELT(mod, 1), n));
    for (i = 0, k = p * p; i < k; i++)
	US[i] = dptr[i];
    dPointer = DS;
    dPointer1 = smooth;
    dptr = REAL(VECTOR_ELT(mod, 2))+ n;
    dptr1 = REAL(VECTOR_ELT(mod, 0)) + n;
    for (i = 0; i < p; i++) {
	*dPointer1 = *dptr1;
	*dPointer = *dptr;
	dPointer += nPlus;
	dPointer1 += nPlus;
	dptr += nPlus;
	dptr1 += nPlus;
    }
    sm = REAL(VECTOR_ELT(mod, 0)) + n - 1; /* m[n-2,] */

    /* allocate space for a la_m by la_n matrix */
    tmpMat = (double *) R_alloc( la_m * la_n, sizeof(double) ); 
    /* space for singular values */
    la_s = (double *) R_alloc( la_n, sizeof(double) );
    /* space for U matrix and Vt matrix (singular vectors) */
    la_u = (double *) R_alloc( la_m * la_n, sizeof(double) );
    la_vt = (double *) R_alloc( la_m * la_n, sizeof(double) );
    /* space for la_iwork */
    la_iwork = (int *) R_alloc( 8 * la_n, sizeof(int) );
    /* space for the square root of W^{-1} */
    sqrtWinv = (double *) R_alloc( p * p, sizeof(double) );
    C = (double *) R_alloc( p * p, sizeof(double) );
    Rinv = (double *) R_alloc( p * p, sizeof(double) );
    Ht = (double *) R_alloc( p * p, sizeof(double) );

    /* ask for optimal size of work array */
    la_lwork = -1;
    F77_CALL(dgesdd)(&la_jobz,
		     &la_m, &la_n, tmpMat, &la_m, la_s,
		     la_u, &la_m,
		     la_vt, &la_n,
		     &tmp, &la_lwork, la_iwork, &la_info);
    if (la_info != 0)
	error("error code %d from Lapack routine dgesdd", la_info);
    la_lwork = (int) tmp;
    la_work = (double *) R_alloc( la_lwork, sizeof(double) );
	
    /** preliminaries: compute sqrt(W^(-1)) if time-invariant **/
    if (stvW) {
	sJW = INTEGER(VECTOR_ELT(mod, 9));
	nrJW = INTEGER(getAttrib(VECTOR_ELT(mod, 9), R_DimSymbol))[0];
	sW = REAL(VECTOR_ELT(mod, 7));
    }
    else {
	dPointer = REAL(VECTOR_ELT(mod,7)); /* W */
	for (i = 0; i < p; i++) {
	    for (j = 0; j < i; j++)
		tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
		    dPointer[i + p * j];
	    tmpMat[i + la_m * i] = dPointer[i + p * i];
	}
	F77_CALL(dgesdd)(&la_jobz,
			 &p, &p, tmpMat, &la_m, la_s,
			 la_u, &la_m,
			 la_vt, &la_n,
			 la_work, &la_lwork, la_iwork, &la_info);
	if (la_info != 0)
	    error("error code %d from Lapack routine dgesdd", la_info);
	for (i = 0; i < p; i++) {
	    tmp = sqrt(la_s[i]);
	    tmp = ( tmp < eps ? dBig : 1.0 / tmp ); 
	    for (j = 0; j < p; j++)
		sqrtWinv[i + j * p] = tmp * la_vt[i + j * la_n];
	}
    }
    if (stvGG) {
	sJGG = INTEGER(VECTOR_ELT(mod, 8));
	nrJGG = INTEGER(getAttrib(VECTOR_ELT(mod, 8), R_DimSymbol))[0];
    }

    
    /** loop over observations **/
    for (t = n; t > 0; t--) { 
	/* set time-varying matrices */
	if (stvW) {
	    for (i = 0; i < nrJW; i++)
		sW[ sJW[i] + p * sJW[i + nrJW] ] = sX[ t - 1 + n * sJW[i + 2 * nrJW] ];
	    dPointer = sW;
	    for (i = 0; i < p; i++) {
		for (j = 0; j < i; j++)
		    tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
			dPointer[i + p * j];
		tmpMat[i + la_m * i] = dPointer[i + p * i];
	    }
	    F77_CALL(dgesdd)(&la_jobz,
			     &p, &p, tmpMat, &la_m, la_s,
			     la_u, &la_m,
			     la_vt, &la_n,
			     la_work, &la_lwork, la_iwork, &la_info);
	    if (la_info != 0)
		error("error code %d from Lapack routine dgesdd", la_info);
	    for (i = 0; i < p; i++) {
		tmp = sqrt(la_s[i]);
		tmp = ( tmp < eps ? dBig : 1.0 / tmp ); 
		for (j = 0; j < p; j++)
		    sqrtWinv[i + j * p] = tmp * la_vt[i + j * la_n];
	    }
	}
	if (stvGG) {
	    for (i = 0; i < nrJGG; i++)
		sGG[ sJGG[i] + p * sJGG[i + nrJGG] ] = sX[ t - 1 + n * sJGG[i + 2 * nrJGG] ];
	}
	/* compute H */
	dPointer = tmpMat;
	dptr = UC = REAL(VECTOR_ELT(VECTOR_ELT(mod, 1), t-1)); /* U.C[[t]] */
	dptr1 = DC = REAL(VECTOR_ELT(mod, 2)) + t - 1; /* D.C[t,] */
	for (i = 0; i < p; i++) {
	    tmp = *dptr1;
	    for (j = 0; j < p; j++)
		*dPointer++ = *dptr++ * tmp;
	    dptr1 += nPlus;
	    dPointer += p;
	}
	for (i = 0; i< p; i++) {
	    for (j = 0; j < i; j++) {
		dptr = tmpMat + i;
		dptr1 = tmpMat + j;
		tmp = 0.0;
		for (k = 0; k < p; k++) {
		    tmp += *dptr * *dptr1;
		    dptr += la_m;
		    dptr1 += la_m;
		}
		C[i + j * p] = tmp;
	    }
	    dptr = tmpMat + i;
	    tmp = 0.0;
	    for (k = 0; k < p; k++) {
		tmp += SQR(*dptr);
		dptr += la_m;
	    }
	    C[i + i * p] = tmp;
	} /* lower-tri of C */
	dPointer = tmpMat;
	dptr = REAL(VECTOR_ELT(VECTOR_ELT(mod, 4), t-1)); /* U.R[[t]] */
	dptr1 = REAL(VECTOR_ELT(mod, 5)) + t - 1; /* D.R[t,] */
	for (i = 0; i < p; i++) {
	    tmp = 1.0 / *dptr1;
	    if ( !R_FINITE(tmp) ) tmp = 0.0;
	    for (j = 0; j < p; j++)
		*dPointer++ = *dptr++ * tmp;
	    dptr1 += n;
	    dPointer += p;
	}
	for (i = 0; i< p; i++) {
	    for (j = 0; j < i; j++) {
		dptr = tmpMat + i;
		dptr1 = tmpMat + j;
		tmp = 0.0;
		for (k = 0; k < p; k++) {
		    tmp += *dptr * *dptr1;
		    dptr += la_m;
		    dptr1 += la_m;
		}
		Rinv[i + j * p] = tmp;
	    }
	    dptr = tmpMat + i;
	    tmp = 0.0;
	    for (k = 0; k < p; k++) {
		tmp += SQR(*dptr);
		dptr += la_m;
	    }
	    Rinv[i + i * p] = tmp;
	} /* lower-tri of Rinv */
	for (i = 0; i < p; i++) {
	    dPointer = tmpMat + i;
	    for (j = 0; j < p; j++) {
		dptr = Rinv + i;
		dptr1 = sGG + p * j;
		tmp = 0.0;
		for (k = 0; k < i; k++) {
		    tmp += *dptr * *dptr1++;
		    dptr += p;
		}
		tmp += *dptr++ * *dptr1++;
		for (k = i + 1; k < p; k++) 
		    tmp += *dptr++ * *dptr1++;
		*dPointer = tmp;
		dPointer += la_m;
	    }
	}
	for (i = 0; i < p; i++) {
	    dPointer = Ht + i + p * (p - 1);
	    for (j = p - 1; j >= 0; j--) {
		dptr = tmpMat + i + la_m * (p - 1);
		dptr1 = C + p * (1 + j) - 1;
		tmp = 0.0;
		for (k = p - 1; k > j; k--) { 
		    tmp += *dptr * *dptr1--;
		    dptr -= la_m;
		}
		tmp += *dptr * *dptr1;
		for (k = j - 1; k >= 0; k--) {
		    dptr1 -= p;
		    dptr -= la_m;
		    tmp += *dptr * *dptr1;
		}
		*dPointer = tmp;
		dPointer -= p;
	    }
	} /* t(H) */
	for (j = 0; j < p; j++) {
	    dPointer = tmpMat + j * la_m;
	    for (i = 0; i < p; i++) {
		dptr = sqrtWinv + i;
		dptr1 = sGG + j * p;
		tmp = 0.0;
		for (k = 0; k < p; k++) {
		    tmp += *dptr * *dptr1++;
		    dptr += p;
		}
		*dPointer++ = tmp;
	    }
	}
	for (i = 0; i < p; i++) {
	    dPointer = tmpMat + p + i;
	    tmp = 1.0 / *(DC + i * nPlus);
	    if ( !R_FINITE(tmp) ) tmp = 0.0;
	    dptr = UC + i * p;
	    for (j = 0; j < p; j++) {
		*dPointer = *dptr++ * tmp;
		dPointer += la_m;
	    }
	}
	F77_CALL(dgesdd)(&la_jobz,
			 &la_m, &la_n, tmpMat, &la_m, la_s,
			 la_u, &la_m,
			 la_vt, &la_n,
			 la_work, &la_lwork, la_iwork, &la_info);
	if (la_info != 0)
	    error("error code %d from Lapack routine dgesdd", la_info);
	for (i = 0; i < p; i++) {
	    dPointer = tmpMat + i;
	    tmp = 1.0 / la_s[i];
	    if ( !R_FINITE(tmp) ) tmp = 0.0;
	    dptr = la_vt + i;
	    for (j = 0; j < p; j++) {
		*dPointer = *dptr * tmp;
		dPointer += la_m;
		dptr += la_n;
	    }
	}
	for (i = 0; i < p; i++) {
	    tmp1 = *(DS + i * nPlus);
	    dPointer = tmpMat + p + i;
	    for (j = 0; j < p; j++) {
		dptr = US + i * p;
		dptr1 = Ht + j * p;
		tmp = 0.0;
		for (k = 0; k < p; k++)
		    tmp += *dptr++ * *dptr1++;
		*dPointer = tmp * tmp1;
		dPointer += la_m;
	    }
	}
	F77_CALL(dgesdd)(&la_jobz,
			 &la_m, &la_n, tmpMat, &la_m, la_s,
			 la_u, &la_m,
			 la_vt, &la_n,
			 la_work, &la_lwork, la_iwork, &la_info);
	if (la_info != 0)
	    error("error code %d from Lapack routine dgesdd", la_info);
	/* store results */
	SET_VECTOR_ELT(US_R, t-1, allocMatrix(REALSXP, p, p));
	US = REAL(VECTOR_ELT(US_R, t-1));
  	DS--;
	dPointer1 = DS;
	dptr = la_vt;
	dptr1 = la_s;
	for (i = 0; i < p; i++) {
	    *dPointer1 = *dptr1++;
	    dPointer1 += nPlus;
	    dPointer = US + i;
	    for (j = 0; j < p; j++) {
		*dPointer = *dptr++;
		dPointer += p;
	    }
	}
	dPointer = tmpMat;
	dptr = smooth;
	dptr1 = REAL(VECTOR_ELT(mod, 3)) + t - 1; /* a[t,] */
	for (i = 0; i < p; i++) {
	    *dPointer++ = *dptr - *dptr1;
	    dptr += nPlus;
	    dptr1 += n;
	}
	dPointer = --smooth;
	dptr = Ht;
	dptr2 = sm--;
	for (i = 0; i < p; i++) {
	    dptr1 = tmpMat;
	    *dPointer = 0.0;
	    for (j = 0; j < p; j++) 
		*dPointer += *dptr++ * *dptr1++;
	    *dPointer += *dptr2;
	    dPointer += nPlus;
	    dptr2 += nPlus;
	}
    }
	
    /* set up return value */
    PROTECT(val = allocVector(VECSXP, 3));
    SET_VECTOR_ELT(val, 0, smoothR);
    SET_VECTOR_ELT(val, 1, US_R);
    SET_VECTOR_ELT(val, 2, DS_R);
    UNPROTECT(4);
    return(val);

}

SEXP dlmForecast(SEXP mod, SEXP nAhead)
{
/***** Warning: the function relies on the order of the  *****/
/***** components of the list 'mod', not on their names. *****/     

    SEXP val, UxR, DxR, aR, fR, UyR, DyR;
    int i, j, k, l, p, m, n, nPlus, t, max_m_p, 
	la_m, la_n, la_info=0, la_lwork, *la_iwork;
    double *sFF, *sGG, *Ux, *Ux_next,  
        *Dx, *sqrtV, *sqrtW, *a, *f, *Uy, *Dy;
    double tmp, tmp1, *tmpMat, *la_s, *la_u, *la_vt, *la_work;
    char la_jobz='S';

    m = INTEGER(getAttrib( VECTOR_ELT(mod,2), R_DimSymbol ))[0];
    p = INTEGER(getAttrib( VECTOR_ELT(mod,2), R_DimSymbol ))[1];
    max_m_p = m > p ? m : p;
    la_n = max_m_p;
    la_m = 2 * la_n;
    n = INTEGER(nAhead)[0]; 
    nPlus = n + 1;
    PROTECT(aR = allocMatrix(REALSXP, nPlus, p));
    PROTECT(UxR = allocVector(VECSXP, nPlus));
    PROTECT(DxR = allocMatrix(REALSXP, nPlus, p));
    PROTECT(fR = allocMatrix(REALSXP, n, m));
    PROTECT(UyR = allocVector(VECSXP, n));
    PROTECT(DyR = allocMatrix(REALSXP, n, m));
    for (i = 0; i < p; i++)
	REAL(aR)[i * nPlus] = REAL(VECTOR_ELT(mod,0))[i];
    a = REAL(aR);
    Dx = REAL(DxR);
    SET_VECTOR_ELT(UxR, 0, allocMatrix(REALSXP, p, p));
    Ux = REAL(VECTOR_ELT(UxR, 0));
    f = REAL(fR);
    Dy = REAL(DyR);
    SET_VECTOR_ELT(UyR, 0, allocMatrix(REALSXP, m, m));
    Uy = REAL(VECTOR_ELT(UyR, 0));
    sFF = REAL(VECTOR_ELT(mod,2));
    sGG = REAL(VECTOR_ELT(mod,4));
    sqrtV = (double *) R_alloc( m * m, sizeof(double) );
    sqrtW = (double *) R_alloc( p * p, sizeof(double) );

    /* allocate space for a la_m by la_n matrix */
    tmpMat = (double *) R_alloc( la_m * la_n, sizeof(double) ); 
    /* space for singular values */
    la_s = (double *) R_alloc( max_m_p, sizeof(double) );
    /* space for U matrix and Vt matrix (singular vectors) */
    la_u = (double *) R_alloc( la_m * max_m_p, sizeof(double) );
    la_vt = (double *) R_alloc( max_m_p * max_m_p, sizeof(double) );
    /* space for la_iwork */
    la_iwork = (int *) R_alloc( 8 * p, sizeof(int) );

    /* ask for optimal size of work array */
    la_lwork = -1;
    F77_CALL(dgesdd)(&la_jobz,
                     &la_m, &la_n, tmpMat, &la_m, la_s,
                     la_u, &la_m,
                     la_vt, &max_m_p,
                     &tmp, &la_lwork, la_iwork, &la_info);
    if (la_info != 0)
        error("error code %d from Lapack routine dgesdd", la_info);
    la_lwork = (int) tmp;
    la_work = (double *) R_alloc( la_lwork, sizeof(double) );

    /** preliminaries: compute svd of C0, sqrt(V), sqrt(W), etc... **/
    for (i = 0; i < p; i++) {
        for (j = 0; j<i; j++) 
            tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
                REAL(VECTOR_ELT(mod,1))[i + p * j]; /* C0 */
        tmpMat[i + la_m * j] = REAL(VECTOR_ELT(mod,1))[i + p * j];
    }
    F77_CALL(dgesdd)(&la_jobz,
                     &p, &p, tmpMat, &la_m, la_s,
                     la_u, &la_m,
                     la_vt, &max_m_p,
                     la_work, &la_lwork, la_iwork, &la_info);
    if (la_info != 0)
        error("error code %d from Lapack routine dgesdd", la_info);
    for (i = 0; i < p; i++) {
        for (j = 0; j < p; j++)
            Ux[i + j * p] = la_vt[j + i * max_m_p];
        Dx[i * nPlus] = sqrt( la_s[i] );
    }
    for (i = 0; i < p; i++) {
        for (j = 0; j < i; j++) 
            tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
                REAL(VECTOR_ELT(mod,5))[i + p * j]; /* W */
        tmpMat[i + la_m * j] = REAL(VECTOR_ELT(mod,5))[i + p * j];
    }
    F77_CALL(dgesdd)(&la_jobz,
                     &p, &p, tmpMat, &la_m, la_s,
                     la_u, &la_m,
                     la_vt, &max_m_p,
                     la_work, &la_lwork, la_iwork, &la_info);
    if (la_info != 0)
        error("error code %d from Lapack routine dgesdd", la_info);
    for (i = 0; i < p; i++) {
        tmp = sqrt( la_s[i] );
        for (j = 0; j < p; j++) 
            sqrtW[i + j * p] = tmp * la_vt[i + j * max_m_p];
    }
    for (i = 0; i < m; i++) {
        for (j = 0; j<i; j++) 
            tmpMat[i + la_m * j] = tmpMat[j + la_m * i] = 
                REAL(VECTOR_ELT(mod,3))[i + m * j]; /* V */
        tmpMat[i + la_m * j] = REAL(VECTOR_ELT(mod,3))[i + m * j];
    }
    F77_CALL(dgesdd)(&la_jobz,
                     &m, &m, tmpMat, &la_m, la_s,
                     la_u, &la_m,
                     la_vt, &max_m_p,
                     la_work, &la_lwork, la_iwork, &la_info);
    if (la_info != 0)
        error("error code %d from Lapack routine dgesdd", la_info);
    for (i = 0; i < m; i++) {
        tmp = sqrt( la_s[i] );
        for (j = 0; j<m; j++) 
            sqrtV[i + j * m] = tmp * la_vt[i + j * max_m_p];
    }
    
    /** loop over future times **/
    for (t = 0; t < n; t++) { 
	/** allocate matrices and make pointers point to 'current' **/
	SET_VECTOR_ELT(UxR, t+1, allocMatrix(REALSXP, p, p));
	Ux_next = REAL(VECTOR_ELT(UxR, t+1));
	SET_VECTOR_ELT(UyR, t, allocMatrix(REALSXP, m, m));
	Uy = REAL(VECTOR_ELT(UyR, t));
        /** Prior **/
        for (i = 0; i < p; i++) {
            tmp = 0.0;
            for (k = 0; k < p; k++)
                tmp += sGG[i + p * k] * a[k * nPlus];
            a[i * nPlus + 1] = tmp;
        }
        
        for (i = 0; i < p; i++) {
            tmp1 = Dx[i * nPlus];
            for (j = 0; j < p; j++) {
                tmp = 0.0;
                for (l = 0; l < p; l++)
                    tmp += sGG[j + l * p] * Ux[i * p + l];
                tmpMat[i + j * la_m] = tmp * tmp1;
            }
            
        }
        for (i = 0; i < p; i++) 
            for (j = 0; j < p; j++) 
                tmpMat[i + p + j * la_m] = sqrtW[i + j * p];
        l = 2 * p;
        F77_CALL(dgesdd)(&la_jobz,
                         &l, &p, tmpMat, &la_m, la_s,
                         la_u, &la_m,
                         la_vt, &max_m_p,
                         la_work, &la_lwork, la_iwork, &la_info);
        if (la_info != 0)
            error("error code %d from Lapack routine dgesdd", la_info);
        for (i = 0; i < p; i++) {
            for (j = 0; j < p; j++)
                Ux_next[i + j * p] = la_vt[j + i * max_m_p];
            Dx[i * nPlus + 1] = la_s[i];
        }

	/** increment pointers (states) **/
	a++; Dx++;
	Ux = Ux_next;

        /** One-step forecast **/
        for (i = 0; i < m; i++) {
            tmp = 0.0;
            for (j = 0; j < p; j++)
                tmp += sFF[i + j * m] * a[j * nPlus];
            f[i * n] = tmp;
        }
        for (i = 0; i < p; i++) {
            tmp1 = Dx[i * nPlus];
            for (j = 0; j < m; j++) {
                tmp = 0.0;
                for (l = 0; l < p; l++)
                    tmp += sFF[j + l * m] * Ux[l + i * p];
                tmpMat[i + j * la_m] = tmp * tmp1;
            }
            
        }
        for (i = 0; i < m; i++) 
            for (j = 0; j < m; j++) 
                tmpMat[i + p + j * la_m] = sqrtV[i + j * m];
        
        l = p + m;
        F77_CALL(dgesdd)(&la_jobz,
                         &l, &m, tmpMat, &la_m, la_s,
                         la_u, &la_m,
                         la_vt, &max_m_p,
                         la_work, &la_lwork, la_iwork, &la_info);
        if (la_info != 0)
            error("error code %d from Lapack routine dgesdd", la_info);
        for (i = 0; i < m; i++) {
            for (j = 0; j < m; j++)
                Uy[i + j * m] = la_vt[j + i * max_m_p];
            Dy[i * n] = la_s[i];
        }

	/** increment pointers (observables) **/
	f++; Dy++;
    }

    PROTECT(val = allocVector(VECSXP, 6));
    SET_VECTOR_ELT(val, 0, aR);
    SET_VECTOR_ELT(val, 1, UxR);
    SET_VECTOR_ELT(val, 2, DxR);
    SET_VECTOR_ELT(val, 3, fR);
    SET_VECTOR_ELT(val, 4, UyR);
    SET_VECTOR_ELT(val, 5, DyR);
    UNPROTECT(7);
    
    return(val);
}


SEXP ARtranspar(SEXP Rp, SEXP Rraw)
{
/*** Adapted from 'partrans' in arima.c ***/ 
    int j, k, p;
    double a, work[50], *new, *raw=REAL(Rraw);
    SEXP Rnew;

    p = INTEGER(Rp)[0];
    if(p > 50) error("can only transform 50 pars in ARtranspar");
    PROTECT( Rnew = allocVector(REALSXP, p));
    new = REAL(Rnew);

    /* Step one: map (-Inf, Inf) to (-1, 1) via tanh
       The parameters are now the pacf phi_{kk} */
    for(j = 0; j < p; j++) work[j] = new[j] = tanh(raw[j]);
    /* Step two: run the Durbin-Levinson recursions to find phi_{j.},
       j = 2, ..., p and phi_{p.} are the autoregression coefficients */
    for(j = 1; j < p; j++) {
        a = new[j];
        for(k = 0; k < j; k++)
            work[k] -= a * new[j - k - 1];
        for(k = 0; k < j; k++) new[k] = work[k];
    }
    UNPROTECT(1);
    return( Rnew );
}

####$$$$ dlm\src/Makevars
PKG_LIBS = $(LAPACK_LIBS) $(BLAS_LIBS) $(FLIBS)
